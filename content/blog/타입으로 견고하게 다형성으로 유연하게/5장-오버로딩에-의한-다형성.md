---
title: 5장 오버로딩에 의한 다형성
date: 2024-08-26 10:08:74
category: 타입으로 견고하게 다형성으로 유연하게
tags: []
draft: true
---

## 5.1 오버로딩

- 함수 오버로딩(function overloading)은 한 함수가 여러 타입의 인자를 받아야 할 때 이거나 타입보다 훨씬 간단하고 직관적인 해결책을 제공하는 기능이다.
  - 이름이 같은 함수들의 매개변수 타입은 서로 달라야 한다.

### 가장 특화된 함수

- 가장 특화된 함수라는 개념이 서브타입으로 표현되기에 함수 선택 시 타입 검사기가 관여한다.
- 대부분의 언어에서는 함수 선택 시에 정적 타입만을 고려한다.
- 함수 오버로딩은 서로 완전히 다른 타입들의 값을 인자로 받는 함수를 정의하는 용도로 사용하는 게 좋다.

### 함수 선택 규칙

1. 인자의 타입에 맞는 함수를 고른다.
2. (인자의 타입에 맞는 함수가 여럿이면) 인자의 타입에 가장 특화된 함수를 고른다.
3. 함수를 고를 때는 인자의 정적 타입만 고려한다.

### 메서드 오버로딩

- 메서드 오버로딩은 특화된 동작을 정의 하는 데 함수 오버로딩만큼이나 별 도움이 되지 않는다. 전혀 다른 타업들의 값을 인자로 받고 싶을 때는 함수 오버로딩만큼이나 메서드 오버로딩도 유용하다.

## 5.2 메서드 오버라이딩

- 메서드 오버라이딩은 특화된 동작을 정의하는 가장 좋은 방법이다.
  - overriding이라는 단어의 사전적인 뜻은 ‘자동으로 진행되는 동작을 사람이 개입하여 중단시킨 뒤 스스로 조작하는 것’이다.
- 메서드 오버라이딩을 사용하면 서브타업을 위해 더 특화된 동작을 정의하고, 정적 타입에 상관없이 언제나 그 특화된 동작이 사용되도록 만들 수 있다.
- 오버로딩을 사용했을 때는 한 클래스에 정의된 같은 이름의 메서드들 중 하나를 선택하는 것이었다면, 오로라이딩은 부모 클래스와 자식 클래스에 같은 이름의 메서드가 정의되어 있으니 그중 무엇을 호출할지 선택하는는 것이다. 즉, 메서드 선택은 메서드 오버로딩뿐 아니라 메서드 오버라이딩까지도 모두 고려해 메서드를 선택한다.
- 함수 선택은 인자의 정적 타입만 고려한다. 반면 메서드 선택은 인자의 정적 타입을 고려하는 것까지는 동일하지만, 거기에 더해 수신자(receiver)의 동적 타입 역시 고려한다.

### 메서드 선택 규칙

1. 인자의 타입에 맞는 함수를 고른다.
2. (인자의 타입에 맞는 함수가 여럿이면) 인자의 타입에 가장 특화된 함수를 고른다.
3. 메서드를 고를 때는 인자의 정적 타입을 고려한다.
4. 메서드를 고를 때는 수신자의 동적 타입도 고려한다.

### 메서드 선택의 한계

- 두 개를 받아서 처리하는 덧셈 같은 기능을 구현할 때 문제점이 드러난다. 수신자의 동적 타입만 고려하고 인자의 동적 타입은 고려하지 않는다는 특정 때문에 인자의 정적 타입과 동적타입이 다를때는 개발자의 기대와 다른 메서드를 호출하게 되는 것이다.
  - 올바르게 구현하기 위한 기본 전략은 메서드 안에서 수신자와 인자의 위치를 바꾸어 다시 한번 메서드를 호출하는 것이다.

### 메서드 오버라이딩과 결과 타입

- 메서드 오버라이딩과 결과 타입은 자식 클래스에 정의한 메서드의 결과 타입이 부모 클래스에 원래 있는 메서드의 결과타입의 서브타입이어야 한다.
  - 이런 다소 불편한 제약이 존재하는 이유는 동적 선택을 사용하면서도 타입 안전성을 지키기 위함이다.
- 동적 선택으로 인해 실행 전에 타입 검사기가 참고하는 메서드와 실제 실행 중에 호출되는 메서드가 다를 수 있다. 타입 검사기는 정적 타입 밖에 모르니 수신자의 정적 타입을 바탕으로 참고할 메서드를 정하는 데 반해, 실행 중에는 수신자의 동적 타입이 호출되는 메서드를 결정하기 때문이다. 이로 인한 문제를 막으려면, 타입 검사기가 참고한 메서드와 다른 메서드가 호출되더라도 참고한 메서드의 결과 타입이 지켜지도록 해야한다. 따라서 자식 클래스에 있는 메서드의 결과 타입이 부모 클래스에 있는 메서드의 결과 타입의 서브타입이어야 한다는 조건이 꼭 필요하다.

```ts
class Vector {
  add(v: SparesVector): Vector {}
}

class SparesVector extends Vector {
  add(v: SparesVector): SparesVector {}
}
```

## 5.3 타입 클래스

- 타입클래스는 특정 타입을 위한 어떤 함수가 존재한다는 사실을 표현한다.
  - 타입이 만족해야 하는 조건을 표현한다는 점에서 추상 클래스와 비슷한 역할을 한다.
- 특정 타입을 어떤 타입클래스에 속하게 만들고 싶다면 타입클래스 인스턴스(typeclass instance)를 정의해야 한다.
- 타입클래스에는 추상 클래스보다 개발자를 더 편하게 해 주는 장점들이 있다.
  - 라이브러리에 정의된 타입을 특정 추상 클래스의 서브타입으로 만드는 것은 일반적으로 불가능하지만, 특정 타입클래스에 속하게 만들기는 매우 쉽다.
  - 추상 클래스로는 제네릭 타입이 타입 인자에 상관없이 항상 만족하는 성질만 표현할 수 있다. 하지만 타입클래스로는 항상 만족하는 성질은 물론이고 특정 타입 인자를 받은 경우에만 만족하는 성질 역시 표현할 수 있다.

## 5.4 카인드

- 카인드는 곧 타입의 타입인 셈이다.
- 첫 번째 종류의 타입은 *라는 카인드에 속한다. “Int의 카인드는 *이다”나 “String의 카인드는 \*이다”와 같이 말할 수 있다.
- 두 번째 종류의 타입은 * => *라는 카인드에 속한다. 함수 타입을 떠올리변 * => *라는 카인드를 쉽게 이해할 수 있다.
- Map과 같이 타입 인자 두개를 받는 타입은 (\*, \*) => \* 카인드에 속한다.
- 타입클래스와 함께 사용한다면 타입 검사기에 메서드를 보장 할 수 있다.
