---
title: 2장 서브타입에 의한 다형성
date: 2024-07-15 00:07:15
category: 타입으로 견고하게 다형성으로 유연하게
tags: []
draft: true
---

## 2.1 객체와 서브타입

- 서브타입은 "A는 B다"라는 타입 사이의 관계다. 서브타입에 반대되는 의미로서 슈퍼타입이라는 용어를 사용한다.
- A가 B의 서브타입일 때 A 타입의 부품을 B 타입의 부품으로도 간주할 수 있게 하는 기능이 서브타입에 의한 다형성이다.
  - B 타입의 부품이 요구되는 자리에 A 타입의 부품이 오더라도 타입 검사기가 문제 삼지 않는 것이다.
- 서브탕비에 의한 다형성을 '반대 방향'으로 적용할 수 없다.

### 이름에 의한 서브타입

- 타입 검사기는 타입이 보여주는 클래스의 이름과 클래스 사이의 상속 관계만 고려한다.

  - 해당 클래스에 어떤 필드와 메서드가 있는지는 전혀 신경 쓰지 않는다.
  - 클래스 A가 클래스 B를 상속한다면 A가 B의 서브타입이다. 여기서 상속은 직접 상속과 간접 상속을 모두 포함한다.

### 구조에 의한 서브타입

- 이미 정의된 클래스를 수정할 수 없는 경우에는 이름에 의한 서브타입만으로는 부족할 수 있다.
- 구조에 의한 서브타입을 사용하는 경우, 타입 검사기는 클래스 사이의 상속 관계 대신 클래스의 구조, 즉 각 클래스에 어떤 필드와 메서드가 있는지 고려한다.
- 클래스 A가 클래스 B에 정의된 필드와 메서드를 모두 정의한다면 A는 B의 서브타입이다.
- 구조를 드러내는 타입

```ts
const sendEmail = (person: { email: string }): void => {
  let email: string = person.email;
};
sendEmail(st);
```

### 추상 메서드

- 추상 메서드는 정말로 메서드를 정의하지는 안되 '이 클래스를 상속하려면 특정 메서드를 반드시 정의해야 한다'는 사실을 표현하는 것이다.
- 추상 메서드는 몸통 없이 이름, 매개변수 타입, 결과 타입만 작성된 메서드다(매개변수 이름도 같이 적혀 있기는 하지만 별로 중요한 역할을 하지 않는다).
  - 이 셋을 묶어 메서드의 시그니처라고 부른다.
- 추상 메서드를 가지는 대신 객체를 직접 만들 수 없는 클래스를 추상 클래스라 부른다.
- 추상 클래스를 만드는 목적은 언제나 메서드의 존재에 관한 정보를 타입 검사기에 제공하려는 것이다.
- 언어가 구조에 의한 서브타입을 제공한다면 추상 메서드의 필요성이 다소 줄어든다.

## 2.2 집합론적 타입

### 최대 타입

- '아무 값이나 가능하다'는 타입
- 모든 값을 포함하는 타입
- 모든 타입은 최대 타입에 속한다.
- 모든 타입은 최대 타입의 서브타입이다.
- 최대 타입의 부품은 만들기 쉽다. 그런 만큼 최대 타입의 부품은 아무 값이나 결과로 낼 수 있기에 결과로 나온 값이 어떤 능력을 가지는지 모른다. 그래서 최대 타입의 부품은 조심스럽게, 별다른 특별한 능력을 요구하지 않는 곳에만 사용해야 한다.
- 타입스크립트에서 최대타입은 any가 아니라 unknown이다.

### 최소 타입

- '계산을 끝마치지 못한다'를 표현하는 타입
- 속하는 값이 존재하지 않는다.
- 최소 타입은 모든 타입의 서브타입이다.
- 최소 타입은 아무렇게나 어느 곳에든 사용할 수 있다. 대신 최소 타입의 부품은 만들기 어렵다. 예외를 발생시키거나 재귀 호출을 하는 등의 특별한 방법으로만 최소 타입의 부품을 만들 수 있다.
- 타입스크립트의 최소 타입의 이름은 never다.

### 이거나 타입

- 이거나 타입 은두개의 타입으로부터 만들어진다. 타입 A와 B로 만든 이거나 타입은 `A | B`라 쓰며 직관적으로 'A이거나 B'를 나타낸다.
- 위치에 민감한 타입 검사가 잘 작동하도록 프로그램의 구조를 단순하게 만들어야 한다.

```ts
function write(data: string | number): void {
  if (typeof data === 'string') {
    let str: string = data;
  } else {
    let num: number = data;
  }
}
```

### 이면서 타입

- 타입 A와 B로 만든 이면서 타입은 `A & B`라 쓰며 직관적으로 'A이면서 B'를 나타낸다. 즉, 어떤값이 A에도 속하고 B에도 속해야지만 `A & B`에 속한다.
- 이면서 타입은 다중상속이 있을 때 유용하다.``

## 2.3 함수와 서브타입

- 함수의 타입은 매개변수 타입과 결과 타입으로 구성된다.
- A가 B의 서브타입 일 때 C => A가 C => B의 서브타입이다. 즉, 함수 타입은 결과 타입의 서브타입 관계를 유지 한다.
- A가 B의 서브타입일 때 B => C가 A => C의 서브타입이다. 그 반대는 성립하지 않는다. 함수 타입은 매개변수 타입의 서브타입 관계를 뒤집는다.

```ts
class Person {
  email: string;
}
class Student {
  email: string;
  grad: number;
}
function startMentoring(select: (s: Student) => Person): void {
  let st: Student = new Student();
  let mentor: Person = select(st);
}
function selectStudentMentor(st: Student): Student {}
function sendEmails(needEmail: (s: Student) => Boolean): void {
  let st: Student = new Student();
  if (needEmail(st)) {
  }
}
function isHacked(pr: Person): Boolean {}
sendEmails(isHacked);
```

## 타입 검사기의 서브타입 관계 판단 규칙

- 객체타입
- 이름에 의한 서브타입을 시용하는 경우: 클래스 A가 B를 상속하면 A는 B의 서브타입이다.
- 구조에 의한 서브타입을 사용하는 경우 A가 B에 있는 필드와 메서드를 모두 가지고 있으면 A는 B의 서브타입이다.
- 최대타입
  - 모든타입은 최대 타입의 서브타입이다.
- 최소타입
  - 최소 타입은 모든 타입의 서브타입이다.
- 이거나타입
  - A와 B는 A|B의 서브타입이다.
- 이면서 타입
  - C가 A의 서브타입이면서 B의 서브타입이면 C는 A&B의 서브타입이다.
- 함수타입
  - A가 B의 서브타입이고 C가 D의 서브타입이면 B => C는 A => D의 서브타입이다.

---

[[번역] 집합론으로 이해하는 타입스크립트 thumbs up](https://itchallenger.tistory.com/874)
