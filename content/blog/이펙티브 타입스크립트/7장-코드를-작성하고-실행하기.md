---
title: 7장 코드를 작성하고 실행하기
date: 2021-08-25 00:08:61
category: 이펙티브 타입스크립트
tags: []
draft: true
---

## 아이템 53 : 타입스크립트 기능보다는 ECMAScript 기능을 사용하기

- 일반적으로 타입스크립트 코드에서 모든 타입 정보를 제거하면 자바스크립트가 되지만, 열거형, 매개변수 속성, 트리플 슬래시 임포트, 데코레이터는 타입 정보를 제거한다고 자바스크립트가 되지는 않습니다.
  - 자바스크립트에 추가된 기능은 타입스크립트 초기 버전에서 독립적으로 개발했던 기능과 호환성 문제를 발생시켰습니다. 타입스크립트팀은 대부분 자바스크립트의 신규 기능을 그대로 채택하고 타입스크립트 초기 버전과 호환성을 포기했습니다. 결국 TC39는 런타임 기능을 발전시키고, 타입스크립트 팀은 타입 기능만 발전시킨다는 명확한 원칙을 세우고 현재까지 지켜오고 있습니다.
- 타입스크립트의 역할을 명확하게 하려면, 열거형, 매개변수 속성, 트리플 슬래시 임포트, 데코레이터는 사용하지 않는 것이 좋습니다.

### 타입 공간(타입스크립트)과 값 공간(자바스크립트)의 경계를 혼란스럽게 만드는 기능들

#### 열거형(enum)

- 단순히 값을 나열하는 것보다 실수가 적고 명확하기 때문에 일반적로 열거형을 사용하는 것이 좋습니다.
- 열거형 대신 `리터럴 타입의 유니온`을 사용하는 것이 좋습니다.

##### 열거형의 문제점

- 숫자 열거형에 0, 1, 2 외의 다른 숫자가 할당되면 매우 위험합니다.(이 방법은 원래 비트 플래그 구조를 표현하기 위해 설계되었습니다.)
- 상수 열거형은 보통의 열거형과 달리 런타임에 완전히 제거됩니다.
- preserveConstEnums 플래그를 설정한 상태의 상수 열거형은 보통의 열거형처럼 런타임 코드에 상수 열거형 정보를 유지합니다.
- 문자열 열거형은 런타임ㅇ의 타입 안전성과 투명성을 제공합니다. 그러나 타입스크립트의 다른 타입과 구조적 타이핑이 아닌 명목적 타이핑을 사용합니다.
  - 이에 따라 자바스크립트와 타입스크립트의 동작이 달라집니다.

#### 매개변수 속성

- 일반적으로 클래스를 초기화할 때 속성을 할당하기 위해 생성자의 매개변수를 사용합니다.
- 클래스에 매개변수 속성만 존재한다면 클래스 대신 인ㅌ처페이스로 만들고 객체 리터럴을 사용하는 것이 좋습니다.
- 매개변수 속성을 사용하는 것이 좋은지에 대해서는 찬반 논란이 있스니다. 어떤 이들은 코드양이 줄어 들어서 좋아하기도 합니다. 매개변수 속성은 타입스클비트의 다른 패턴들과 이질적이고, 초급자에게 생소한 문법이라는 것을 기억해야 합니다. 또한 매개변수 속성과 일반 속성을 같이 사용하면 설계가 혼란스러워지기 때문에 한 가지만 사용하는 것이 좋습니다.

##### 매개변수 속성의 문제점

- 일반적으로 타입스크립트 컴파일은 타입 제거가 이루어지므로 코드가 줄어들지만, 매개변수 속성은 코드가 늘어나는 문법입니다.
- 매개변수 속성이 런타임에는 실제로 사용되지만, 타입스크립트 관점에서는 사용되지 않는 것처럼 보입니다.
- 매개변수 속성과 일반 속성을 섞어서 사용하면 클래스의 설계가 혼란스러워집니다.

#### 네임스페이스와 트리플 슬래시 임포트

- ECMAScript 2015 이전에는 자바스크립트에 공식적인 모듈 시스템이 없어 타입스크립트는 자체적으로 모듈 시스템을 구축했고, module 키워드와 `트리플 슬래시` 임포트를 사용했습니다.
- ECMAScript 2015가 공식적으로 모듈 시스템을 도입한 이후, 타입스크립트는 충돌을 피하기 위해 module과 같은 기능을 하는 `namespace` 키워드를 추가했습니다.
- 트리플 슬래시 임포트와 module 키워드는 호환성을 위해 남아 있을 뿐이며, 이제는 ECMAScript 2015 스타일의 모듈(import와 export)을 사용해야 합니다.

#### 데코레이터

- 데코레이터는 클래스, 메서드, 속성에 애너테이션(annotation)을 붙이거나 기능을 추가하는 데 사용할 수 있습니다.
- 애너테이션이 필요한 프로임워크를 사용하고 있는게 아니라면, 데코레이터가 표준이 되기 전에는 타입스크립트에서 데코레이터를 사용하지 않는 게 좋습니다.

## 아이템 54 : 객체를 순회하는 노하우

- 객체를 순회할 때, 키가 어떤 타입인지 정확히 파악하고 있다면 let k: keyof T와 for-in 루프를 사용합시다. 함수의 매개변수로 쓰이는 객체에는 추가적인 키가 존재할 수 있다는 점을 명심하빈다.
- 객체를 순회하며 키와 값을 얻는 가장 일반적인 방법은 Object.entries를 사용하는 것입니다.

## 아이템 55 : DOM 계층 구조 이해하기

- 자바스크립트를 사용할 때는 신경 쓰지 않았겠지만, DOM에는 타입 계층 구조가 있습니다. DOM 타입은 타입스크립트에서 중요한 정보이며, 브라우저 관련 프로젝트에서 타입스크립트를 사용할때 유용합니다.
- Node, Element, HTMLElement, EventTarget 간의 차이점, 그리고 Event, MouseEvent의 차이점을 알아야 합니다.
- DOM 엘리먼트와 이번트에는 충분히 구체적인 타입 정보를 사용하거나, 타입스크립트가 추론할 수 있도록 문맥 정보를 활용해야 합니다.
- DOM 관련해서는 타입스크립트보다 우리가 더 정확히 알고 있는 경우이므로 단언문을 사용해도 좋습니다.

| 타입              | 예시                         |
| ----------------- | ---------------------------- |
| EventTarget       | window, XMLHttpRequest       |
| Node              | document, Text, Comment      |
| Element           | HTMLElement, SVGElement 포함 |
| HTMLElement       | \<i>, \<b>                   |
| HTMLButtonElement | \<button>                    |

### Event

- 가장 추상화된 이벤트 입니다.

#### 더 구체적인 타입들

- UIEvent : 모든 종류의 사용자 인터페이스 이벤트
- MouseEvent : 클릭처럼 마우스로부터 발생되는 이벤트
- TouchEvent : 모바일 기기의 터치 이벤트
- WheelEvent : 스크롤 휠을 돌려 발생하는 이벤트
- KeyboardEvent : 키 누름 이벤트
-

### EventTarget

- DOM 타입 중 가장 추상화 된 타입이빈다.
- 이벤트 리스너를 추가하거나 제거하고, 이벤트를 보내는 것밖에 할 수 없습니다.

### Node

- Element가 아닌 Node인 경우를 몇 가지로 예로 들어 보면 텍스트 조각과 주석이 있습니다.

### Element와 HTMLElement

- SVG 태그의 전체 계층 구조를 포함하면서 HTML이 아닌 엘리먼트가 존재하는데, 바로 Element의 또 다른 종류인 SVGElement입니다.

### HTMLxxxElement

- HTMLxxxElement 형태의 특정 엘리먼트들은 자신만의 고유한 속성을 가지고 있습니다.

## 아이템 56 : 정보를 감추는 목적으로 private 사용하지 않기

- public, protected, private 접근 제어자는 타입 시스템에서만 강제될 뿐입니다. 런타임에는 소용이 없으므로 단언문을 통해 우회할 수 있습니다. 접근 제어자로 데이터를 감추려고 해서는 안 됩니다.
- 확실히 데이터를 감추고 싶다면 클로저를 사용해야 합니다.
  - 단, 메서드 정의가 생성자 내부에 존재하게 되면, 인스턴스를 생성 할 때마다 각 메서드의 복사본이 생성도히기 때문에 메모리를 낭비하게 됩니다. 또한 동일한 클래스로부터 생성된 인스턴스라고 하더라도 서로의 비공개 데이터에 접근하는 것이 불가능하기 때문에 철저하게 비공개이면서 동시에 불폄함이 따릅니다.
- 현재 표준화가 진행 중인 비공개 필드 기능을 사용할 수 있습니다. 비공개 필드 기능은 접두사로 #를 붙여서 타입 체크와 런타임 모두에서 비공개로 만드는 역할을 합니다.
  - 클로저 기법과는 다르게 클래스 메서드나 동일한 클래스의 개별 인스턴스끼리는 접근이 가능합니다.
  - 비공개 필드를 지원하지 않는 자바스크립트 버전으로 컴파일하게 되면, WeapMap을 사용한 구현으로 대체 됩니다.
- 만약 설계 관점의 캡슐화가 아닌 '보안'에 대해 걱정하고 있다면, 내장된 프로토타입과 함수에 대한 변조 같은 문제를 알고 있어야 합니다.

## 아이템 57 : 소슴뱁을 사용하여 타입스크립트 디버깅하기

- 원본 코드가 아닌 변환된 자바스크립트 코드를 디버깅하지 맙시다. 소스맵을 사용해서 런타임에 타입스크립트 코드를 디버깅합시다.
- 소스맵이 최종적으로 변환된 코드에 완전히 매핑되었는지 확인합시다.
- 소스맵에 원본 코드가 그대로 포함되도록 설정 되었을 수도 있습니다. 공개되지 않도록 설정을 확인합시다.

### 소스맵에 대해 알아야 할 몇가지 사항

- 타입스크립트와 함께 번들러(bundler)나 압축기(minifier)를 사용하고 있다면, 번들러나 압축기가 각자의 소스맵을 생성하게 됩니다. 이상적인 디버깅 환경이 되려면 생성된 자바스크립트가 아닌 원본 타입스크립트 소스로 매핑되도록 해야 합니다. 번들러가 기본저긍로 타입스크립트를 지원한다면 별도 설정 없이 잘 동작해야 합니다. 그렇지 않다면 번들러가 소스맵을 인식할 수 있도록 추가적인 설정이 필요합니다.
- 상용 환경에 소스맵이 유출도히고 있는지 확인해야 합니다. 디벅를 열지 않는 이상 소스맵이 로드되지 않으므로, 실제 사용자에게 성능 저하는 발생하지 않습니다. 그러나 소스맵에 원본 코드의 인라인 복사본이 ㅂ포함되어 있다면 공개해서는 안 될 내용이 들어 있을 수 있습니다. 저질 주석이나 내부 버그 추적을 위한 URL을 공개할 필요는 없습니다.
