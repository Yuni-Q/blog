---
title: 3장 타입 추론
date: 2021-08-15 16:08:06
category: 이펙티브 타입스크립트
tags: []
draft: true
---

- 타입스크립트는 타입 추론을 적극적으로 수행합니다.

## 아이템 19 : 추론 가능한 타입을 사용해 장환한 코드 방지하기

- 타입스크립트가 타입을 추론할 수 있다면 타입 구문을 작성하지 않는게 좋습니다.
- 이상적인 경우 함수/메서드의 시그니처에는 타입 구분이 있지만, 함수 내의 지역 변수에는 타입 구분이 없습니다.
- 추론될 수 있는 경우라도 객체 리터럴과 함수 반환에는 타입 명시를 고려해야 합니다. 이는 내부 구현의 오류가 사용자 코드 위치에 나타나는 것을 방지해 줍니다.
- eslint 규칙 중 no-interrable-types을 사용해서 작성된 모든 타입 구문이 정말로 필요한지 확인할 수 있습니다.

### 객체 리터럴에 타입을 명시해야 하는 이유

- 객체 리터럴에서 타입 구문을 제거한다면 잉여 속성 체크가 동작하지 않고, 객체 선언한 곳이 아니라 객체가 사용되는 곳에서 타입 오류가 발생합니다.

### 함수 반환에 타입을 명시해야 하는 이유

- 타입 추론이 가능할지라도 구현상의 오류가 함수를 호출하는 곳까지 영향을 미치지 않도록 하기 위해타입 구문을 명시하는 게 좋습니다.
- 반환 타입을 명시하면 함수에 대해 더욱 명확하게 알 수 있습니다. 미리 타입을 명시하는 방법은, 함수를 구현하기 전에 테스트를 먼저 작성하는 테스트 주도 개발과 비슷합니다.
- 명명된 타입을 사용하기 위해 명시해야 합니다. 반환 타입을 명시하면 더욱 직관적인 표현이 됩니다. 그리고 반환 값을 별도로 타입으로 정의하면 타입에 대한 주석을 작성할 수 있어서, 더욱 자세한 설명이 가능합니다. 추론된 반환 타입이 복잡해질수록 명명된 타입을 제공하는 이점이 커집니다.

## 아이템 20 : 다른 타입에는 다른 변수 사용하기

- 변수의 값은 바뀔 수 있지만 타입은 일반적으로 바뀌지 않습니다.
- 혼란을 막기 위해 타입이 다른 값을 다룰 때에는 변수를 재사용하지 않도록 합니다.
- 많은 개발자들이 린터 규칙을 통해 가려지는 변수를 사용하지 못하도록 하고 있습니다.

```ts
const id = '12-34-56';
fetchProduct(id);
{
  // 가려지는 변수
  const id = 123456;
  fetchProduct(id);
}
```

### 다른 타입에는 별도의 변수를 사용하는 게 바람직한 이유

- 서로 관련이 없는 두 개의 값을 분리합니다.
- 변수명을 더 구체저긍로 지을 수 있습니다.
- 타입 추론을 향상시키며, 타입 구문이 불필요해집니다.
- 타입이 좀 더 간결해집니다.
- let 대신 const로 변수를 선언하게 됩니다. const로 변수를 선언하면 코드가 간결해지고, 타입 체커가 타입을 추론하기에도 좋습니다.

## 아이템 21 : 타입 넓히기

- 타입스크립트는 명확성과 유연성 사이의 균형을 유지하려고 합니다. 오류를 잡기 위해서는 충분히 구체적으로 타입을 추론해야 하지만, 잘못된 추론(false positive)을 할 정도로 구체적으로 수행하지는 않습니다.
- 타입스크립트가 넓히기를 통해 상수의 타입을 추론하는 법을 이해해야 합니다.
  - 1과 같은 값으로 초기화되는 속성을 적당히 number의 타입으로 추론합니다.
  - 넗히기 과정을 제어할 수 있는 첫 번째 방법은 const입니다. let 대신 const로 변수를 선언하면 더 좁은 타입이 됩니다.
- 동작에 영향을 줄 수 있는 방법인 const, 타입 구문, 문맥, as const에 익숙해져야 합니다.

### 타입 추론의 강도를 직접 제어하려면 타입스크립트의 기본 동작을 재정의해야 합니다.

- 명시적 타입 구문을 제공합니다.
- 타입 체커에 추가적인 문맥을 제공합니다.
- const 단언문(as const)을 사용합니다.

```ts
const v1 = {
  x: 1,
  y: 2,
}; // 타입은 { x: number, y: number }

const v2 = {
  x: 1 as const,
  y: 2,
}; // 타입은 { x: 1, y: number }
const v3 = {
  x: 1,
  y: 2,
} as const; // 타입은 { readonly x: 1, readonly y: 2 }
```

## 아이템 22 : 타입 좁히기

- 분기문에서 예외를 던지거나 함수를 반환하여 블록의 나머지 부분에서 변수의 타입을 좁힐 수 있습니다.
- 분기문 외에도 여러 종류의 제어 흐름을 살펴보면 타입스크립트가 타입을 좁히는 과정을 이해해야 합니다.
  - instanceof를 사용해서 타입을 좁힐 수 있습니다.
  - 속성 체크로 타입을 좁힐 수 있습니다.
  - Array.isArray 같은 일부 내장 함수로도 타입을 좁힐 수 있습니다.
  - 명시적으로 '태그'를 붙여 타입을 좁힐 수 있습니다. 이 패턴은 `태그된 유니온(tagged union)` 또는 `구별된 유니온(discriminated union)`이라고 불립니다.
  - 식별을 돕기 위해 커스텀 함수를 이용해 타입을 좁힐 수 있습니다. 이러한 기법을 `사용자 정의 타입 가드`라고 합니다.

## 아이템 23 : 한꺼번에 객체 생성하기

- 속성을 제각각 추가하지 말고 한꺼번에 객체로 만들어야 합니다. 안전한 타입으로 속성을 추가하려면 객체 전개({...a, ...b})를 사용하면 됩니다.
- 객체에 조건부로 속성을 추가하는 방법을 익히도록 합니다.

```ts
// 선택적 속성을 가진 것으로 추론
declare let hasMiddle: boolean;
const firstLast = { first: 'Harry', last: 'Truman' };
const president = { ...firstLast, ...(hasMiddle ? { middle: 'S' } : {}) };
// {
//   middle?: string;
//   first: string;
//   last: string
// }

// 유니온으로 추론
declare let hasDates: boolean;
const nameTitle = { name: 'Khufu', title: 'Pharaoh' };
const pharaoh = {
  ...nameTitle,
  ...(hasDates ? { start: -2589, end: 2566 } : {}),
};
// {
//   start: number;
//   end: number;
//   name: string;
//   title: string;
// } } {
//   name: string;
//   title: string;
// }

// 유니온이 아닌 선택적 필드 방식으로 표현하기 위한 헬퍼 함수
function addOptional<T extends object, U extends object>(
  a: T,
  b: U | null,
): T & Partial<U> {
  return { ...a, ...b };
}
```

## 아이템 24 : 일관성 있는 별칭 사용하기

- 별칭은 타입스크립트가 타입을 좁히는 것을 방해합니다. 따라서 변수에 별칭을 사용할 때는 일관되게 사용해야 합니다.
- 비구조화 문법을 사용해서 일관된 이름을 사용하는 것이 좋습니다.
- 함수 호출이 객체 속성의 타입 정제를 무효화할 수 있다는 점을 주의해야 합니다. 속성보다 지역 변수를 사용하면 타입 정제를 믿을 수 있습니다.

## 아이템 25 : 비동기 코드에는 콜백 대신 async 함수 사용하기

- 콜백보다는 프로미스를 사용하는 게 코드 작성과 타입 추론 면에서 유리합니다.
- 가능하면 프로미스를 생성하기보다는 async와 await를 사용하는 것이 좋습니다. 간결하고 직관적인 코드를 작성할 수 있고 모든 종류의 오류를 제거 할 수 있습니다.0
- 어떤 함수가 프로미스르 반환한다면 async로 선언하는 것이 좋습니다.

## 아이템 26 : 타입 추론에 문맥이 어떻게 사용되는지 이해하기

- 타입 추론에서 문맥이 어떻게 쓰이는지 주의해서 살펴봐야 합니다.
  - 타입스크립트는 일반적으로 값이 처음 등장할 때 타입을 결정합니다.
- 변수를 뽑아서 별도로 선언했을 때 오류가 발생한다면 타입 선언을 추가해야 합니다.
- 변수가 정말로 상수라면 상수 단언(as const)을 사용해야 합니다. 그러나 상수 단언을 사용하면 정의한 곳이 아니라 사용한 곳에서 오류가 발생하므로 주의해야 합니다.

## 아이템 27 : 함수형 기법과 라이브러리로 타입 흐름 유지하기

- 타입 흐름을 개선하고, 가독성을 높이고, 명시적인 타입 구문의 필요성을 줄이기 위해 직접 구현하기보다는 내장된 함수형 기법과 로대시 같은 유틸리티 라이브러리를 사용하는 것이 좋습니다.
