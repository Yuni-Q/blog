---
title: 2장 타입스크립트의 타입 시스템
date: 2021-08-11 21:08:76
category: 이펙티브 타입스크립트
tags: []
draft: true
---

## 아이템 6 : 편집기를 사용하여 타입 시스템 탐색하기

- 편집기에서 타입스크립트 언어 서빗스를 적극 활용해야 합니다.
- 편집기를 사용하면 어떻게 타입 시스템이 동작하는지, 그리고 타입스크립트가 어덯게 타입을 추록하는지 개념을 잡을 수 있습니다.
- 타입스크립트가 동작을 어떻게 모델링하는지 알기 위해 타입 선언 파일을 찾아보는 방법을 터득해야 합니다.

## 아이템 7 : 타입이 값들의 집합이라고 생각하기

- 타입을 값의 집합으로 생각하면 이해하기 편합니다(타입의 '범위'). 이 집합은 유한(boolean 또는 리터럴 타입)하거나 무한(number 또는 string)합니다.
- 타입스크립트 타입은 엄격한 상속 관계가 아니라 겹쳐지는 집합(벤 다이어그램)으로 표시됩니다. 두 타입은 서로 서브타입이 아니면서도 겹칠 수 있습니다.
- 한 객체의 추가적인 속성이 타입 선언에 언급되지 않더라도 그 타입에 속할 수 있습니다.
- 타입 연산은 집합의 범위에 적용됩니다. A와 B의 인터센션은 A의 범위와 B의 범위의 인터섹션입니다. 객체 타입에서는 A & B인 값이 A와 B의 속성을 모두 가짐을 의미합니다.
- 'A는 B를 상속', 'A는 B에 할당 가능', 'A는 B의 서브타입'은 'A는 B의 부분 집합'과 같은 의미입니다.

### 타입 집합

- 가장 작은 집합은 아무 값도 포함하고 있지 않는 공집합이며, 타입스크립트에서는 `never` 타입입니다.
- 그 다음으로 작은 집합은 한 가지 값만 포함하는 타입입니다. 유닛(unit), 리터럴(literal)
- 두 개 혹은 세 개로 묶으려면 유니온(union) 타입을 사용합니다.
- 세 개 이상 타입을 묶을 때도 동일하게 |로 이어주면 됩니다. 유니온 타입은 값 집합들의 합집합을 일컫습니다.

### 부분 집합

```ts
type AB = 'A' | 'B';
type AB12 = 'A' | 'B' | 12;

const ab: AB = Math.random() < 0.5 ? 'A' : 'B';
const ab12: AB12 = ab;
```

### 타입 연산

```ts
keyof(A & B) = keyof(A) | keyof(B);
keyof(A | B) = keyof(A) & keyof(B);
```

### extends

- 타입이 집합이라는 관점에서 extends의 의미는 `~에 할당 가능한`과 비슷하게 `~의 부분 집합`이라는 의미로 받아 들일 수 있습니다.
- extends 키워드는 제너릭 타입에서 `한정자`로도 쓰이며, 이 문맥에서는 `~의 부분 집합`을 의미하기도 합니다.

### 타입스크립트 용어와 집합 이론 용어 사이의 관계 대응

| 타입스크립트 용어           | 집합용어             |
| --------------------------- | -------------------- | ---------------- |
| never                       | 공집합               |
| 리터럴 타입                 | 원소가 1개인 집합    |
| 값이 T에 할당               | 값이 T의 원소        |
| T1이 T2에 할당 가능         | T1이 T2의 부분 집합  |
| T1이 T2를 상속              | T이 T의 부분 집합    |
| T1                          | T2(T1과 T2의 유니온) | T1과 T2의 합집합 |
| T1 & T2(T1와 T2의 인터섹션) | T1과 T2의 교집합     |
| unknown                     | 전체(universal) 집합 |

## 아이템 8 : 타입 공간과 값 공간의 심벌 구분하기

- 타입스크립트 코드를 읽을 때 타입인지 값인지 구분하는 방법을 터득해야 합니다. 타입스크립트 플레이그라운드를 활용해 개념을 잡는 것이 좋습니다.
  - 컴파일 과정에서 타입 정보는 제거되기 때문에, 심벌이 사라진다면 그것은 타입에 해당될 것입니다.
  - instanceof는 자바스크립트의 런타임 연산자이기 때문에 값에 대해서 연산을 합니다. 따라서 interface를 판단하지 못합니다. 또한, 값으로 정의되어 있을 경우 그것을 참조하기 때문에 오류를 일으킬 수 있습니다.
- 모든 값은 타입을 가지지만, 타입은 값을 가지지 않습니다. type과 interface 값은 키워드는 타입 공간에만 존재합니다.
- class나 enum 같은 키워드는 타입과 값 두 가지로 사용될 수 있습니다.
  - 클래스가 타입으로 쓰일 때는 형태(속성과 메서드)가 사용되는 반면, 값으로 쓰일 때는 생성자가 사용됩니다.
  - InstanceType 제너릭을 사용해 새엇ㅇ자 타입과 인스턴스타입을 전환할 수 있습니다.
  ```ts
  type C = InstanceType<typeof A>; // 타입이 A
  ```
- "foo"는 문자열 리터럴이거나, 문자열 리터럴 타입일 수 있습니다. 차이점을 알고 구별하는 방법을 터득해야 합니다.
- typeof, this 그리고 많은 다른 연산자들과 키워드들은 타입 공간과 값 공간에서 다른 목적으로 사용될 수 있습니다.
  - 타입의 관점에서, typeof는 값을 읽어서 타입스크립트 타입을 반환합니다. 타입 공간의 typeof는 보다 큰 타입의 일부분으로 사용할 수 있고, type 구분으로 이름을 붙이는 용도로도 사용할 수 있습니다. 값의 관점에서 typeof는 자바스크립트 런타임의 typeof 연산자가 됩니다. 값 공간의 typeof는 대상 심벌의 런타임 타입을 가리키는 문자열을 반화하며, 타입스크립트 타입과는 다릅니다. 자바스크립트에는 단 6개(string, number, boolean, undefined, object, function)의 런타임 타입만이 존재합니다.
  - 값으로 쓰이는 this는 자바스크립트의 this 키워드입니다. 타입으로 쓰이는 this는, 일명 `다형성(polymorphic) this`라고 불리는 this의 타입스크립트 타입입니다. 서브클래스의 메서드 체인을 구현할 때 유용합니다.
  - 값에서 &와 |는 AND와 OR 비트연산입니다. 타입에서는 인터섹션과 유니온입니다.
  - const는 새 변수를 선언하지만, as const는 리터럴 또는 리터럴 표현식의 추론된 타입을 바꿉니다.
  - extends는 서브클래스(class A extends B) 또는 서브타입(interface A extends B) 또는 제너릭 타입의 한정자(Generic\<T extends number>)를 정의할 수 있습니다.
  - in은 루프(for (key of object)) 또는 매핑된(mapped) 타입에 등장합니다.

## 아이템 9 : 타입 단언보다는 타입 선언을 사용하기

- 타입 단언(as Type)보다 타입 선언(: Type)을 사용해야 합니다.
  - 타입 단언은 강제로 타입을 지정했으니 타입 체커에게 오류를 무시하라고 하는 것입니다.
- 화살표 함수의 반환 타입을 명시하는 방법을 터득해야 합니다.
- 타입스크립트보다 타입 정보를 더 잘 알고 있는 상황에서는 타입 단언문과 null이 아님 단언문을 사용하면 됩니다.
  - 타입스크립트는 DOM에 접근할 수 없기 때문에 DOM 엘리먼트에 대해서는 타입 단언이 필요합니다.
- 타입 단언문으로 임의의 타입 간에 변환을 할 수는 없습니다. A가 B의 부분 집합인 경우에 타입 단언문을 사용해 변환할 수 있습니다.
- 모든 타입은 unknown의 서브타입이기 때문에 unknown이 포함된 단언문은 항상 동작합니다. unknown 단언은 임의의 타입 간에 변환을 가능케 하지만, unknown을 사용한 이상 적어도 무언가 위험한 동작을 하고 있다는 걸 알 수 있습니다.

## 아이템 10 : 객체 래퍼 타입 피하기

- 기본형 값에 메서드를 제공하기 위해 객체 래퍼 타입이 어떻게 쓰이는지 이해해야 합니다. 직접 사용하거나 인스턴스를 생성하는 것은 피해야 합니다.
  - 기본형 값 : string, number, boolean, null, undefined, symbol, bigint
  - 기본형들은 불면이며 메서드를 가지지 않는다는 점에서 객체와 구분됩니다.
  - 자바스크립트는 기본형과 객체 타입을 서로 자유롭게 변환합니다. string 기본형에 메서드를 사용할 때, 자바스크립트는 기본형을 객체로 래핑하고, 메서드를 호출하고, 마지막에 래핑한 객체를 버립니다.
  - 기본형과 객체 래퍼가 항상 동일하게 동작하는 것은 아닙니다.
  - string은 String에 할당할 수 있지만 String은 string에 할당할 수 없습니다.
- 타입스크립트 객체 래퍼 타입은 지양하고, 대신 기본형 타입을 사용해야 합니다. String 대신 string, Number 대신 number, Boolean 대신 boolean, Symbol 대신 symbol, BigInt 대신 bigint를 사용해야 합니다.
