---
title: 5장 any 다루기
date: 2021-08-16 18:08:12
category: 이펙티브 타입스크립트
tags: []
draft: true
---

- 타입스크립트의 타입 시스템은 선택적(optional)이고 점진적(gradual)이기 때문에 정저깅면서도 동적인 특성을 동시에 가집니다. 따라서 타입스크립트는 프로그램의 일부분에서만 타입 시스템을 적용할 수 있습니다.

## 아이템 38 : any 타입은 가능한 한 좁은 범위에서만 사용하기

- 의도치 않은 타입 안전성의 손실을 피하기 위해서 any의 사용 범위를 최소한으로 좁혀야 합니다.
- 함수의 반환 타입이 any인 경우 타입 안정성이 나빠집니다. 따라서 any 타입을 반환하면 절대 안 됩니다.
- 강제로 타입 오류를 제거하려면 any 대신 @ts-ignore 사용하는 것이 좋습니다.

## 아이템 39 : any를 구체적으로 변형해서 사용하기

- any를 사용할 때는 정말로 모든 값이 허용되어야만 하는지 면밀히 검토해야 합니다.
- any보다 더 정확하게 모델링할 수 있도록 `any[]` 또는 `{[key: string]: any}` 또는 `() => any` 처럼 구체적인 형태를 사용해야 합니다.

### 객체 타입

- `{[key: string]: any}` :
- `object` : 모든 비기본형(non-primitive)타입을 포함하는 object 타입. object 타입은 객체의 키를 열거할 수는 있지만 속성에 접근할 수 없다는 점에서 `{[key: string]: any}`와 약간 다릅니다.
- unknown : 객체지만 속성에 접근할 수없어야 한다면 unknown 타입이 필요한 상황일 수 있습니다.

### 함수 타입

```ts
type Fn0 = () => any; // 매개변수 없이 호출 가능한 모든 함수
type Fn1 = (arg: any) => any; // 매개변수 1개
type FnN = (...arg: any[]) => any; // 모든 개수의 매개변수. "Function" 타입과 동일합니다.

const numArgsBad = (...args: any) => args.length; // any를 반환합니다.
const numArgsBad = (...args: any[]) => args.length; // number를 반환합니다.
```

## 아이템 40 : 함수 안으로 타입 단언문 감추기

- 함수 내부에는 타입 단언을 사용하고 함수 외부로 드러나는 타입 정의를 정확히 명시하는 정도록 끝내는 것이 나을 수도 있습니다.
- 타입 선언문은 일반적으로 타입을 위험하게 만들지만 상황에 따라 필요하기도 하고 현실적인 해결책이 되기도 합니다. 불가피하게 사용해야 한다면, 정확한 정의를 가지는 함수 안으로 숨기도록 합니다.

## 아이템 41 : any의 진화 이해하기

- 일반적인 타입들은 정제되기만 하는 반면, 암시적 any와 any[] 타입은 진화할 수 있습니다. 이러한 동작이 발생하는 코드를 인지하고 이해할 수 있어야 합니다.
  - any 타입의 진화는 `noImplicitAny`가 설정된 상태에서 변수의 타입이 암시적 any인 경우에만 일어납니다.
  - 타입 진화는 값을 할당하거나 배열에 요소를 넣은 후에만 일어나기 때문에, 편집기에서는 이상하게 보일 수 있습니다. 할당이 일어난 줄의 타입을 조사해 봐도 여전히 any 또는 any[]로 보입니다.
  - any 타입의 진화는 암시적 any 타입에 어떤 값을 할당할 때만 발생합니다. 그리고 어떤 변수가 암시적 any 상태일 때 값을 익으려고 하면 오류가 발생합니다.
  - 암시적 any 타입은 함수 호출을 거쳐도 진화하지 않습니다.
- any를 진화시키는 방식보다 명시적 타입 구문을 사용하는 것이 안전한 타입을 유지하는 방법입니다.

## 아이템 42 : 모르는 타입의 값에는 any 대신 unknown을 사용하기

- unknown은 any 대신 사용할 수 있는 안전한 타입입니다. 어떠한 값이 있지만 그 타입을 알지 못하는 경우라면 unknown을 사용하면 됩니다.
- 사용자가 타입 단언문이나 타입 체크를 사용하도록 강제항려면 unknown을 사용하면 됩니다.
- {}, object, unknown의 차이점을 이해해야 합니다.

### unknown

- unknown 타입은 any와 같이 어떠한 타입이든 unknown에 할당 가능합니다.
- unknown 타입은 any와 달리 unknown은 오직 unknown과 any에만 할당 가능합니다.
- never 타입은 unknown과 정반대입니다.
  - 어떠한 타입도 never에 할당할 수 없습니다.
  - 어떠한 타입으로도 할당 가능합니다.
- unknown 타입인 채로 값을 사용하면 오류가 발생합니다. unknown인 값에 함수 호출을 하거나 연산을 하려고 해도 마찬가지입니다. unknown 상태로 사용하려고 하면 오류가 발생하기 때문에, 적절한 타입으로 변환하도록 강제할 수 있습니다.
- 어떠한 값이 있지만 그 타입을 모르는 경우에 unknown을 사용합니다.
- 타입 단언문 또는 instanceof를 체크한 후 unknown에서 원하는 타입으로 변환할 수 있습니다. 사용자 정의 타입 가드도 unknown에서 원하는 타입으로 변환할 수 있습니다.
- 제네릭보다는 unknown을 반환하고 사용자가 직접 단언문을 사용하거나 원하는 대로 타입을 좁히도록 강제하는 것이 좋습니다.
- any의 경우는 분리되는 순간 그 영향력이 전염병처럼 퍼지게 됩니다. 그러나 unknown의 경우는 분리되는 즉시 오류를 발생하게 되므로 더 안전합니다.

### unknown과 유사하지만 조금 다른 타입

- `object` 또는 `{}`를 사용하는 방법 역시 unknown만큼 범위가 넓은 타입이지만, unknown보다는 범위가 약간 좁습니다.
  - `{}` 타입은 null과 undefined를 제외한 모든 값을 포함합니다.
  - `object` 타입은 모든 비기본형(non-primitive) 타입으로 이루어집니다. 여기에는 true 또는 12 또는 "foo"가 포함되지 않지만 객체와 배열은 포함됩니다.
  - 정말로 null과 undefined가 불가능하다고 판단되는 경우에만 unknown 대신 `{}`를 사용하면 됩니다.

## 아이템 43 : 몽키 패치보다는 안전한 타입을 사용하기

- 전역 변수나 DOM에 데이터를 저장하지 말고, 데이터를 분리하여 사용해야 합니다.
- 내장 타입에 데이터를 저장해야 하는 경우, 안전한 타입 접근법 중 하나(보강이나 상용자 정의 인터페이스로 단언)를 사용해야 합니다.
- 보강의 모듈 영역 문제를 이해해야 합니다. 모듈의 관점에서(타입스크립트 파일이 import/export를 사용하는 경우), 제대로 동작하게 하려면 global 선언을 추가해야 합니다. 보강을 사용할 때 주의할 점은 모듈 영역(scope)과 관련이 있습니다. 보강은 전역적으로 적용되기 때문에, 코드의 다른 부분이나 라이브러리로부터 분리할 수 없습니다. 그리고 애플리케이션이 실행되는 동안 속성을 할당하면 실행 시점에서 보강을 적용할 방법이 없습니다.

### 보강을 사용하는 방법이 any보다 나은 점

- 타입이 더 안전합니다. 타입 체커는 오타나 잘못된 타입의 할당을 오류로 표시합니다.
- 속성에 주석을 붙일 수 있습니다.
- 속성에 자동완성을 사용할 수 있습니다.
- 몽키 패치가 어떤 부분에 적용되었는지 정확환 기록이 남습니다.

## 아이템 44 : 타입 커버리지를 추가하여 타입 안정성 유지하기

- noImplicitAn가 설정되어 있어도, 명시적 any 또는 서드파티 타입 선언(@types)을 통해 any 타입은 코드 내에 여전히 존재할 수 있다는 점을 주의해야 합니다.
- 작성한 프로그램의 타입이 얼마나 잘 선언되었는지 추적해야 합니다. 추적함으로써 any의 사용을 줄여 나갈 수 있고 타입 안전성을 꾸준히 높을 수 있습니다.
- npm의 `type-cover-age` 패키지를 활용하여 any를 추적할 수 있습니다.
