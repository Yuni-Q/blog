---
title: 4장 타입 설계
date: 2021-08-16 02:08:38
category: 이펙티브 타입스크립트
tags: []
draft: true
---

- 타입 시스템의 가장 큰 장점 중 하나는 데이터 타입을 명확히 알 수 있어 코드를 이해하기 쉽다는 것입니다.

## 아이템 28 : 유효한 상태만 표현하는 타입을 지향하기

- 유효한 상태와 무효한 상태를 둘 다 표현하는 타입은 혼란을 초래하기 쉽고 오류를 유발하게 됩니다.
- 유효한 상태만 표현하는 타입을 지향해야 합니다. 코드가 길어지거나 표현하기 어렵지만 결국은 시간을 절약하고 고통을 줄일 수 있습니다.

## 아이템 29 : 사용할 때는 너그럽게, 생성할 때는 엄격하게

- 사용하기 편리한 API일수록 반환타입이 엄격합니다.
  - 보통 매개변수 타입은 반환 타입에 비해 범위가 넓은 경향이 있습니다. 선택적 속성과 유니온 타입은 반환 타입보다 매개변수 타입에 더 일반적입니다.
- 매개변수와 반환 타입의 재사용을 위해서 기본 형태(반환 타입)와 느슨한 형태(매개변수 타입)을 도입하는 것이 좋습니다.

## 아이템 30 : 문서에 타입 정보를 쓰지 않기

- 함수의 입력과 출력의 타입을 코드로 표현하는 것이 주석보다 더 나은 방법입니다. 그리고 타입 구문은 타입스크립트 컴파일러가 체크해 주기 떄문에, 절대로 구현체와의 정합성이 어긋나지 않습니다.
- 특정 매개변수를 설명하고 싶다면 JSDocs의 @param 구문을 사용하면 됩니다.
- 주석과 변수명에 타입 정보를 적는 것은 피해야 합니다. 타입 선언이 중복되는 것으로 끝나면 다행이지만 최악의 경우는 정보에 모순이 발생하게 됩니다.
- 타입이 명확하지 않은 경우는 변수명에 단위 정보를 포함하는 것을 고려하는 것이 좋습니다(예를 들어 timeMs 또는 temperatureC).

## 아이템 31 : 타입 주변에 null 값 배치하기

- 값이 전부 null이거나 전부 null이 아닌 경우로 분명히 구분된다면, 값이 섞여 있을 때보다 다루기 쉽습니다.
  - 한 값의 null 여부가 다른 값의 null 여부에 암시적으로 관련되도록 설계하면 안 됩니다.
- API 작성 시에는 반환 타입을 큰 객체로 만들고 반환 타입 전체가 null이거나 null이 아니게 만들어야 합니다. 사람과 타입 체커 모두에게 명료한 코드가 될 것입니다.
- 클래스를 만들 때는 필요한 모든 값이 준비되었을 때 생성하여 null이 존재하지 않도록 하는 것이 좋습니다.
- strictNullChecks를 설정하면 코드에 많은 오류가 표시되겠지만, null 값과 관련된 문제점을 찾아낼 수 있기 때문에 반드시 필요합니다.

## 아이템 32 : 유니온의 인터페이스보다는 인터페이스 유니온을 사용하기

- 유니온 타입의 속성을 여러 개 가지는 인터페이스에서는 속성 간의 관계가 분명하지 않기 때문에 실수가 자주 발생하므로 주의해야 합니다.
- 유니온의 인터페이스보다 인터페이스의 유니온이 더 정확하고 타입스크립트가 이해하기도 좋습니다.
- 타입스크립가 제어 흐름을 분석할 수 있도록 타입에 태그를 넣는 것을 고려해야 합니다. `태그된 유니온`은 타입스크립트와 매우 잘 맞기 때문에 자주 볼 수있는 패턴입니다.

```ts
// as-is
interface Layer {
  layout: FillLayout | LineLayout | PointLayout;
  paint: FillPaint | LinePaint | PointPaint;
}

// to-be(잘못된 조합으로 섞이는 경우를 방지)
interface FillLayer {
  layout: FillLayout;
  paint: FillPaint;
}
interface LineLayer {
  layout: LineLayout;
  paint: LinePaint;
}
interface PointLayer {
  layout: PointLayout;
  paint: PointPaint;
}
type Layer = FillLayer | LineLayer | PointLayer;
```

```ts
// as-is
interface Layer {
  type: 'fill' | 'line' | 'point';
  layout: FillLayout | LineLayout | PointLayout;
  paint: FillPaint | LinePaint | PointPaint;
}

// to-be(태그된 유니온)
interface FillLayer {
  type: 'fill';
  layout: FillLayout;
  paint: FillPaint;
}
interface LineLayer {
  type: 'line';
  layout: LineLayout;
  paint: LinePaint;
}
interface PointLayer {
  type: 'point';
  layout: PointLayout;
  paint: PointPaint;
}
type Layer = FillLayer | LineLayer | PointLayer;
```

```ts
// as-is
interface Person {
  name: string;
  // 다음 둘 다 동시에 있거나 동시에 없습니다.
  placeOfBirth?: string;
  dateOfBirth?: string;
}

// to-be(null 값을 경계로 두는 방법과 비슷)
interface Person {
  name: string;
  // 다음 둘 다 동시에 있거나 동시에 없습니다.
  birth?: {
    placeOfBirth?: string;
    dateOfBirth?: string;
  };
}

// to-be(타입의 구조를 손댈수 없는 상황)
// to-be(null 값을 경계로 두는 방법과 비슷)
interface Name {
  name: string;
}
interface PersonWithBirth extends Name {
  placeOfBirth?: string;
  dateOfBirth?: string;
}

type Person = Name | PersonWithBirth;
```

## 아이템 33 : string 타입보다 더 구체적인 타입 사용하기

- '문자열을 남발하여 선언된' 코드를 피합시다. 모든 문자열을 할당할 수 있는 string 타입보다는 구체적인 타입을 사용하는 것이 좋습니다.
- 변수의 범위를 보다 정확하게 표현하고 싶다면 string 타입보다는 문자열 리터럴 타입의 유니온을 사용하면 됩니다. 타입 체크를 더 엄격히 할 수 있고 생산성을 향상시킬 수 있습니다.
  - 타입을 명시적으로 정의함으로써 다른 곳으로 값이 전달되어도 타입 정보가 유지됩니다.
  - 타입을 명시적으로 정의하고 해당 타입의 의미를 설명하는 주석을 붙여 넣을 수 있습니다.
  - keyof 연산자로 더욱 세밀하게 객체의 속성 체크가 가능해집니다.
- 객체의 속성 이름을 함수 매개변수로 받을 때는 string보다 keyof T를 사용하는 것이 좋습니다.

## 아이템 34 : 부정확한 타입보다는 미완성 타입을 사용하기

- 타입 안전성에서 불쾌한 골짜기는 피해야 합니다. 타입이 없는 것보다 잘못된 게 더 나쁩니다.
- 정확하게 타입을 모델링할 수 없다면, 부정확하게 모델링하지 말아야 합니다. 또한 any와 unknown를 구별해서 사용해야 합니다.
- 타입 정보를 구체적으로 만들수록 오류 메시지와 자동 완성 기능에 주의를 기울여야 합니다. 정확도뿐만 아니라 개발 경험과도 관련됩니다.

## 아이템 35 : 데이터가 아닌, API와 명세를 보고 타입 만들기

- 코드의 구석 구석까지 타입 안전성을 얻기 위해 API 또는 데이터 형식에 대한 타입 생성을 고려해야 합니다.
- 데이터에 드러나지 않는 예외적인 경우들이 문제가 될 수 있기 때문에 데이터보다는 명세로 부터 코드를 생성하는 것이 좋습니다.

## 아이템 36 : 해당 분야의 용어로 타입 이름 짓기

- 가독성을 높이고, 추상화 수준을 올리기 위해서 해당 분야의 용어를 사용해야 합니다.
- 같은 의미에 다른 이름을 붙이면 안 됩니다. 특별한 읨미가 있을 때만 용어를 구분해야 합니다.

### 타입, 속성, 변수에 이름을 붙일 때 명심해야 할 세 가지 규칙

- 동일한 의미를 나타낼 때는 같은 용어를 사용해야 합니다. 글을 쓸 때나 말을 할 때, 같은 단어를 반복해서 사용하면 지루할 수 있기 때문에 동의어(의미가 같지만 다른 단어)를 사용합니다. 동의어를 사용하면 글을 읽을 때는 좋을 수 있지만, 코드에서는 좋지 않습니다. 정말로 의미저긍로 구분이 되어야 하는 경우에만 다른 용어를 사용해야 합니다.
- data, info, thing, item, object, entity 같은 모호하고 의미 없는 이름은 피해야 합니다. 만약 entity라는 용어가 해당 분야에서 특별한 의미를 가진다면 괜찮습니다. 그러나 귀찮다고 무심코 의미 없는 이름을 붙여서는 안 됩니다.
- 이름을 지을 때는 포함된 내용이나 계산 방식이 아니라 데이터 자체가 무엇인지를 고려해야 합니다. 예를 들어 INodeList보다는 Directory가 더 의미있는 이름입니다. Directory는 구현의 측면이 아니라 개념적인 측면에서 디렉터리를 생각하게 합니다. 좋은 이름은 추상화의 수준을 높이고 의도치 않은 충돌의 위험성을 줄여 줍니다.

## 아이템 37 : 공식 명칭에는 상표를 붙이기

- 타입스크립트는 구조적 타이핑(덕 타이핑)을 사용하기 때문에, 값을 세밀하게 구분하지 못하는 경우가 있습니다. 값을 구분하기 위해 공식 명칭이 필요하다면 상표를 붙이는 것을 고려해야 합니다.
- 상표 기법은 타입 시스템에서 동작하지만 런타임에 상표를 검사하는 것과 동일한 효과를 얻을 수 있습니다.

```ts
type Meters = number & { _brand: 'meters' };
type Seconds = number & { _brand: 'seconds' };

const meters = (m: number) => m as Meters;
const seconds = (s: number) => s as Seconds;

const oneKm = meters(1000); // 타입이 Meters
const oneMin = seconds(60); // 타입이 Seconds
```
