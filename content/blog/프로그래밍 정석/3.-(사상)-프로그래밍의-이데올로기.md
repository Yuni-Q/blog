---
title: 3. (사상) 프로그래밍의 이데올로기
date: 2020-05-08 09:05:61
category: 프로그래밍 정석
draft: false
---

## 3.1 프로그래밍 이론

- 좋은 프로그래머는 시간이 걸리더라도 언어, 도구, 기술, 문제 영역 등 분야를 막론하고 제대로 이해하고 나서 작업에 착수하는 경향이 있습니다.
- 제대로 이유를 설명할 수 있을 때까지 끈질기게 이해하고 나서 코드를 확정하도록 해야합니다.

## 3.2 의사소통

- 소프트웨어 개발 비용의 대부분은 최초 개발된 이후에 발생합니다.
- 즉, 유지보수에 드는 비용입니다.
- 코드는 작성하는 시간보다 읽는 시간이 압도적으로 많습니다. 코드를 통해 원활하게 의사소통을 하려면 코드를 작성할 때 다른 사람의 입장에서 생각해야 합니다.

## 3.3 단순함

- 코드가 단순하다는 것은 코드에서 불필요한 복잡성이 제거된 상태를 가리킵니다.
- 코드가 간결해지면 오류가 발생할 확률도 매우 낮아집니다.
- 본질적인 부분을 눈에 잘 띄게 만들고, 그 이외의 불필요한 부분이 거기에 섞여들지 않도록 설계합니다.
- 불필요한 복잡성을 제거하면 남은 본질이 더욱 두드러지고 이해가 쉬워지며 의사소통이 원활해집니다.

## 3.4 유연성

- 코드에서 유연성이란 코드 변경이 용이함을 뜻합니다. 기존 코드가 새롭게 추가되는 코드를 반발이나 거부 반응 없이 받아들일 수 있는 점, 자신이 망가지지 않도록 완충을 해서 받아들일 수 있는 점, 양쪽 관점으로 유연이라는 표현이 사용되고 있습니다.

## 3.9 선언형의 표현

- 선언형의 표현이란 코드의 의도를 전하고자 할 때 가능한 명령형보다는 선언형으로 표현하는 것을 뜻합니다.
- 명령형 프로그래밍은 문제의 해법, 즉 자료구조와 알고리즘을 기술합니다. 반면에 선언형 프로그래밍은 문제의 정의, 즉 해결해야 할 문제의 성질이나 이때 충족해야 할 제약을 기술합니다.

## 3.11 아키텍쳐 기본 기법

- 아키텍처 기본 기법이란 소프트웨어 아키텍쳐를 적절하게 구축하는 데 필요한 기초 원리입니다. 제대로 소프트웨어 아키텍처를 구축하려면 기초가 되는 몇 가지 원리에 기반을 두고 수행해야 합니다. 소프트웨어 개발의 역사 속에서 수 많은 프로그래머가 축적해 온 실천적이며 방대한 경험에 기반하고 있습니다. 어떤 문제에 대해 특정한 해결책이 다른 방법보다 뛰어나다는 사실을 프로그래머들이 인식하고 그 해결책을 여러 차례 재사용해 왔는데, 그것이 바로 기본 기법입니다.

## 3.12 추상

- 추상이란 개념적으로 명확한 선 긋기를 수행하는 것입니다. 선 긋기에 따라 어떤 모듈을 그 이외의 모듈로부터 명확하게 구별합니다. 추상은 사상과 일반화라는 2가지 관점에서 정리됩니다.

### 사상

- 복잡한 대상의 몇 가지 성질을 버리고 특정한 성질에 주목하는 것입니다.
- 불필요한 것을 버리고 본질을 파악하는 것입니다.

### 일반화

- 구체적인 대상으로부터 공통 성질을 추출해서 더욱 범용적인 개념으로 정식화하는 것입니다.
- 다른 여러 개의 대상에 집중할 때 공통된 성질을 찾아내고 공통점을 조합시켜 범용적인 개념을 구상합니다.

## 3.13 캡슐화

- 관련 있는 데이터와 로직을 그룹핑해서 하나의 모듈을 정의합니다. 관계성이 강한 데이터와 로직을 모듈이라는 껍질로 감싸는 것을 캡슐화라고 부릅니다.
- 그룹핑을 통해 관련 있는 요소끼리만 특정 추상 개념을 담당하도록 모듈로 모읍니다. 이렇게 하면 다음과 같은 장점을 얻을 수 있습니다.
  - 관련 없는 요소가 섞이지 않기 때문에 코드가 읽기 쉬워집니다.
  - 변경 시의 영향이 모듈 안으로 한정됩니다.
  - 영향도가 명확해지므로 코드의 변경이 쉬워집니다.
  - 각각 독립된 부품이므로 재사용성이 높아집니다.
  - 작은 단위로 분할되므로 복잡한 문제에 대처할 수 있습니다.

## 3.14 정보 은닉

- 모듈의 구현을 해당 모듈을 사용하는 클라이언트로부터 은닉합니다.
- 모듈이 클라이언트가 알 필요 없는 내부의 상세 부분을 은닉하면 인터페이스가 작아지고 정보의 교환이 단순해지며 코드 전체의 복잡성을 낮출 수 있습니다.
- 정보 은닉을 실현하려면 캡슐화를 사용합니다. 캡슐화와 정보 은닉은 원래 다른 개념입니다.

### 캡슐화

- 관계가 있는 요소를 모아 모듈화하는 것입니다.
- 관계가 깊은 데이터와 함수를 한군데로 모읍니다.

### 정보 은닉

- 모듈의 내부 상태나 내부 함수를 은닉하는 것입니다.
- 내부에 대한 외부로부터의 직접적인 접근을 차단합니다.

## 3.15 패키지화

- 모듈을 의미 있는 단위로 모든 다음 그룹화합니다. 이는 소프트웨어 전체를 의미 있는 단위로 분할하는 것입니다. 이렇게 분할된 단위를 패키지라고 부릅니다.
- 어느 정도 대규모 소프트웨어가 되면 이번에는 대량으로 작성된 모듈이 오히려 복잡성을 낳는 결과를 초래합니다. 이것이 바로 패키지입니다. 패키지화에는 다음과 같은 이점이 있습니다.
  - 소프트웨어 전체가 패키지라는 작은 단위로 분할되므로 복잡도가 낮아집니다.
  - 패키지 안에 관련 없는 모듈이 섞이지 않으므로 모듈을 관리하기 쉬워집니다.
  - 수정에 대한 영향도가 패키지 안에 머무를 가능성이 높으므로 코드를 변경하기 쉬워집니다.
  - 종속 관계가 정리되어 패키지 단위로 재사용하기 쉬워집니다.

## 3.16 관심의 분리

- 관심이란 소프트웨어의 기능이나 목적을 뜻합니다. 관심을 분리한다는 것은 각각의 관심에 관련된 코드를 모아 독립된 모듈로 만들어 다른 코드로부터 분리한다는 뜻입니다.
- 설계 기법에서 패턴의 대부분은 관심의 분리를 실현하려는 목표를 가지고 있습니다. 가장 대표 적인 패턴이 MVC 패턴입니다. MVC 패턴에서는 비즈니스 로직, 사용자에 대한 표시, 입력 처리를 분리합니다.

## 3.17 충족성, 완전성, 프리미티브성

- 캡슐화에 의해 관련 있는 요소들이 특정 추상 개념을 담당하는 모듈로 모여집니다. 모듈이 담당하는 추상에 대한 표현은 충분하고 완전하며 프리미티브여야 합니다.

### 충족성

- 충족성이란 모듈이 표현하고자 하는 추상이 그것을 전하기에 충분한지를 뜻합니다.
- 예를 들어 모듈이 컬렉션을 표현하고 있는 때 remove가 제공된다고 해도 add가 제공되지 않는다면 컬렉션이라는 점을 전하기에는 불충분합니다.

### 완전성

- 완전성이란 모듈이 표현하고자 하는 추상이 모든 특징을 갖추고 있는지를 뜻합니다.
- 뭔가 빠진 것이 없이 모든 것을 갖추고 있다면 어떤 클라이언트에서도 사용하기 쉬워집니다.
- 예를 들어 모듈이 컬렉션을 표현하고 있을 때 요소의 개수를 구하는 size가 제공되지 않는다면 완전하다고 할 수 없습니다.

### 프리미티브성

- 프리미티브성이란 모듈이 표현하고자 하는 추상이 모두 순수한지 아닌지를 의미합니다.
- 예를 들어 모듈이 켈렉션을 표현하고 있을 때 아이템 1개 추가하는 add가 제공된다면 아이템을 10개 추가하는 add10은 필요하지 않습니다.
- 추상의 순수성이라는 관점에서 보면 오히려 불필요한 기능입니다.

## 3.18 정책과 구현의 분리

- 모듈은 정책 혹은 구현을 다룹니다. 다만 하나의 모듈에서 양쪽 모두를 다루어서는 안 됩니다.

### 정책 모듈

- 해당 소프트웨어의 전체에 종속되는 비즈니스 로직이나 그 밖의 모듈에 대한 파라미터를 선택하는 부분입니다.
- 해당 소프트웨어에 특화되어 있습니다. 해당 소프트웨어에 변경이 생기면 정책 모듈은 변경을 강요 당합니다.

### 구현 모듈

- 해당 소프트웨어의 전제의 종속되지 않는 독립적 로직 부분입니다.
- 특정 소프트웨어에 종속되지 않는 순수한 모듈이므로 다른 소프트웨어에서도 재사용할 수 있습니다.

## 3.19 인터페이스와 구현의 분리

- 모듈은 인터페이스 파트와 구현 파트 2개의 분리된 부분으로 구성합니다.
- 인터페이스 파트란 모듈이 가진 기능을 정의하고 모듈의 사용 방법을 정하는 부분입니다. 클라이언트에서 접근할 수 있는 함수의 원형으로 구성됩니다.
- 구현 파트란 모듈이 가진 기능을 실현하는 코드 부분입니다. 모듈이 내부에서 사용하는 로직과 데이터가 표함됩니다. 구현 파트는 클라이언트에서 접근할 수 없습니다.
- 모듈의 인터페이스 사양만 제시되므로 단순하고 이해가 쉬워져 모듈을 쉽게 사용할 수 있습니다. 사용법과 기능의 실현 방법이 서로 독립성으로 확보할 수 있습니다.
- 모듈에 관한 설계 원리로 구현이 아닌 인터페이스에 맞춰 프로그래밍하라라는 격언이 있습니다. 이에 따라 모듈끼리의 호출은 서로 인터페이스만 사용하도록 합니다. 인터페이스의 구현은 인터페이스 뒤쪽으로 숨겨 이를 직접 호출하는 것을 허용하지 않도록 합니다.

## 3.20 참조의 단일성

- 모듈의 요소에 관한 선언과 정의는 1회로 제한합니다.
- 정의가 1회라는 말은 예를 들어 변수값을 초기화했다면 이후 값을 변경하지 않는다는 뜻입니다. 이렇게 하면 변수값의 변화를 추적하지 않아도 되므로 직관적인 코드가 됩니다.

### 참조 투과성

- 호출 결과가 파라미터에만 종속된다는 것은 파라미터로 같은 값을 넘겨주면 항상 같은 반환값을 돌려주는, 즉 반환값이 파라미터값에만 종속되는 특성입니다. 이런 특성을 가리켜 순수하다고 표현합니다.
- 호출이 다른 기능의 동작에 영향을 주지 않는는 것은 함수가 부작용을 갖지 않는다는 특성입니다. 부작용이란 어떤 처리가 상태의 변경을 일으켜 이후의 처리 결과에 영향을 주는 것입니다.

## 3.21 분할 정복

- 커다란 문제를 그 자체로 해결하려면 어려워지고 시간이 많이 걸립니다. 최악의 경우 해결할 수 없을 때도 있습니다. 규모가 너무 큰 탓에 문제가 너무 복잡하기 때문입니다. 제어하기 쉬운 규모까지 문제를 분할하고 거기서부터 착수하는 방식이 효율적입니다.

## 3.55 UNIX 철학

- UNIX 철학이란 UNIX의 배후에 있는 설계 철학으로, 말하자만 'UNIX적인 사고방식'입니다. UNIX는 오래전부터 존재했으며 아직도 업무 일선에서 계속 사용되고 있습니다. 설계 철학이 뛰어나고도 보편적이기 때문입니다.
- UNIX적인 사고방식
- 작은 것이 아름답다
  - 작게 만들고 작게 유지하도록 한다
  - 장점
    - 이해가 쉽다
    - 보수가 쉽다
    - 머신 자원에 부담을 주지 않는다
    - 다른 소프트웨어와 조합하기 쉽다
  - 한 번에 하나의 작업
    - 하나의 소프트웨어에는 하나의 작업만 제대로 시킨다
    - 가장 좋은 소프트웨어란 생애 중에 단 하나의 작업만을 제대로 완수하는 소프트웨어다
  - 즉시 프로토타입 진행
    - 가능한 한 빨리 프로토타입을 작성한다
    - 어떤 아이디어가 성공할 것 같은지, 눈에 보이는 형태로 현실화 할 수 있는지를 확인하려면 시험 삼아 만들어보는 방법이 가장 좋다
  - 효율성보다 이식성
    - 소프트웨어 설계는 선택의 연속이다
    - 이식성과 개발 효율성이라는 이율배반적인 선택을 해야되는데 이때는 이식성을 우선시해야 한다
  - 데이터는 텍스트로
    - 데이터는 텍스트 파일로 저장한다
    - 데이터의 이식성도 중시해야 한다
    - 거의 모든 면에서 바이너리 파일보다 뛰어나다
  - 레버리지 소프트웨어
    - 레버리지(지렛대)
    - 코드를 대량으로 작성하는 가장 좋은 방법은 빌려 오는 것이다
    - 각각이 단일 기능이며 단일 가치에 집중하는 작은 소프트웨어를 작성하자
  - 셸 스크립트 활용
    - 셸 스크립트를 통해 지렛대 효과와 이식성을 높인다
    - 셸 스크립트는 이식성이 높다
  - 대화형 인터페이스 회피
    - 대화형 인터페이스 회피
    - 지나친 대화형 인터페이스를 피하도록 한다
    - 대화형 인터페이스의 문제
      - 소프트웨어별로 독자적인 대화 방법을 기억해야 한다
      - 소프트웨어끼리 대화할 수 없다
      - 대기 시간이 많아진다
      - 입력 부분에 대한 해석 코드가 많아지고 흉해진다
      - 큰 것이 아름다운 접근법으로 변질된다
  - 필터화
    - 모든 소프트웨어를 필터로 설계한다
    - 필터란 입력 스트립을 데이터로 받아들여 어떤 형태로든 가공한 다음 가공된 데이터를 출력 스트림으로 송출하는 것이다
    - 소프트웨어의 본질은 데이터를 처리하는 것이지 생성하는 것이 아니다
- UNIX 철학과 작은 정리
  - 환경 커스터마이즈
  - 작고 가벼운 커널
  - 소문자 사용
  - 자연 보호
  - 침묵은 금
  - 병령 사고
  - 부품 협력
  - 90%의 해
  - 열등해야 뛰어나다
  - 계층 지향

## 3.56 작은 것이 아름답다

- 작은 소프트웨어는 단순하고 다루기 쉬우며 큰 소프트웨어보다 훨씬 뛰어납니다. 따라서 소프트웨어는 작게 만들고 작게 유지하도록 합니다.

### ​장점

- 이해가 쉽습니다.
- 보수가 쉽습니다.
- 다른 소프트웨어와 조합하기 쉽습니다.

### 단점

- 복잡하고 코드를 이해하기 어렵습니다.
- 예측하지 못하고 사태에 대응할 수 없습니다.

## 3.57 한 번에 하나의 작업

- 가장 좋은 소프트웨어란 생애 중에 단 하나의 작업만을 제대로 완수하는 소프트웨입니다.
- 하나의 작업에 집중함으로써 코드에 불필요한 부분을 없앨 수 있습니다.
- 하나의 작업에 집중함으로써 해당 작업의 본질을 파악할 수 있습니다.
- 하나의 작업을 제대로 하는 소프트웨어를 만들 수 없다면 문제를 아직 완전하게 이해하지 못했다는 뜻입니다.

## 3.58 즉시 프로토타입 진행

- 어떤 아이디어가 성공할 것 같은지, 눈에 보이는 형태로 현실화할 수 있는지를 확인하려면 시험 삼아 만들어보는 방법이 가장 좋습니다. 이렇게 만든 시제품을 프로토타입이라고 부릅니다. 프로토타입을 작성하면 전제의 착오가 조기에 발견되어 작은 피해에 머무릅니다. 잘못된 전제 그대로 몇 개월 동안이나 개발을 진행하다가 배포 직전이 되어 불의의 습격을 받을 일은 없습니다.

## 참고

- [프로그래밍의 정석 도서 정리](https://peter-cho.gitbook.io/book/11/undefined-7)
