---
title: CHAPTER 01 리팩터링 : 첫 번째 예시
date: 2021-06-14 01:06:03
category: 리팩토링 2판
tags: []
draft: true
---

## 리팩토링이 필요한 이유

- 변경 때문입니다.
  - 잘 작동하고 나중에 변경할 일이 절대 없다면 코드를 현재 상태로 놔눠도 아무런 문제가 없습니다.
- 다른 사람이 읽고 이해해야 할 일이 생겼는데 로직을 파악하기 어렵다면 뭔가 대책을 마련해야 합니다.

## 리팩터링의 첫 단계

- 테스트 코드들 부터 마련해야 합니다.

## 함수 추출하기

- 코드 조각을 별도 함수로 추출하는 방식으로 파악한 정보를 코드에 반영합니다.
- 추출한 함수에는 그 코드가 하는 일을 설명하는 이름을 지어줍니다.
- 코드 조각을 함수로 추출할 때 실수를 최소화해주는 절차를 마련해둡니다.
- 이 절차를 따로 기록해두고, 나중에 참조하기 쉽도록 `함수 추출하기`란 이름을 붙입니다.

### 순서

1. 먼저 별도 함수로 빼냈을 때 유효범위를 벗어나는 변수, 즉 새 함수에서는 곧바로 사용할 수 없는 변수가 있는지 확인합니다.

2. 추출한 새 함수에서도 필요하지만 값을 변경하지 않는 값은 매개변수로 전달합니다.

3. 바뀌는 값은 초기화 코드와 반환을 통해 정의합니다.

## 리팩터링의 핵심

- 아무리 간단한 수정이라도 리팩터링 후에는 항상 테스트하는 습관을 들이는 것이 바람직합니다.
- 조금씩 변경하고 매번 테스트하는 것은 리팩터링 절차의 핵심입니다.
  - 리팩터링은 프로그램 수정을 작은 단계로 나눠 진행합니다. 그래서 중간에 실수를 하더라도 버그를 쉽게 찾을 수 있습니다.
- 컴퓨터가 이해하는 코드는 바보도 작성할 수 있습니다. 사람이 이해하도록 작성하는 프로그래머가 진정한 실력자입니다.

## 리팩토링 순서

1. 임시 변수를 질의 함수로 바꾸기

- 임시 변수들 때문에 로컬 범위에 존재하는 이름이 늘어나서 추출 작업이 복잡해지는 것을 해결해줍니다.

2. 변수 인라인하기

3. 함수 선언 바꾸기

4. 반복문 쪼개기

5. 문장 슬라이드하기

6. 함수로 추출

7. 변수를 인라인

8. 반복문을 파이프라인으로 바꾸기

9. 조건부 로직을 다형성으로 바꾸기

10. 타입 코드를 서브클래스로 바꾸기

11. 생성자를 팩터리 함수로 바꾸기

## 리팩토링 과정에서 오는 쟁점

- 지역 변수를 제거해서 얻는 가장 큰 장점은 추출 작업이 쉬워진다는 것입니다. 유효범위를 신경 써야 할 대상이 줄어들기 때문입니다.
- 리팩터링으로 인한 성능 문제는 특별한 경우가 아니라면 일단 무시합니다. 리팩터링 때문에 성능이 떨어진다면, 하던 리팩터링을 마무리하고 나서 성능을 개선합니다.
- 리팩토링 시 단계를 작게 나누고 자주 커밋을 한다면 작업 속도가 빨라집니다.
- 처음보다 코드량이 늘어날 수 있습니다. 하지만 추가된 코드 덕분에 전체 로직을 구성하는 요소 각각이 더 뚜렷이 부각되고, 계산하는 부분과 형식을 다루는 부분이 분리됩니다. 이렇게 모듈화하면 각 부분이 하는 일과 그 부분들이 맞물려 돌아가는 과정을 파악하기 쉬워집니다. 프로그래밍에서는 간결함보다 명료함이 진화할수 있는 소프트웨어의 정수입니다.
- 항시 코드베이스를 작업 시작 전보다 건강하게 만들어놓고 떠나야 합니다.
- 수정이 일어나는 기준으로 코드를 분리해야 합니다.
- 좋은 코드를 가늠하는 확실한 방법은 `얼마나 수정하기 쉬운가`입니다.
