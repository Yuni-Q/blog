---
title: CHAPTER 12 - 상속 다루기
date: 2021-09-22 02:09:81
category: 리팩토링 2판
tags: []
draft: true
---

## 12.1 메서드 올리기(Pull Up Method)

- 반대 리팩터링 : 메서드 내리기

```js
// as-is
class Employee {
  // ...
}

class Salesperson extends Employee {
  get name() {
    // ...
  }
}

class Engineer extends Employee {
  get name() {
    // ...
  }
}

// to-be
class Employee {
  get name() {
    // ...
  }
}

class Salesperson extends Employee {}
class Engineer extends Employee {}
```

- 중복 코드 제거는 중요합니다.
- 두 메서드의 전체 흐름은 비슷하지만 세부 내용이 다르다면 템플릿 메서드 만들기를 고려해봅니다.

### 절차

1. 똑같이 동작하는 메서드인지 면밀히 살펴봅니다.

- 실질적으로 하는 일은 같지만 코드가 다르다면 본문 코드가 똑같아질 때까지 리팩터링합니다.

2. 메서드 안에서 호출하는 다른 메서드와 함조하는 필드들을 슈퍼클래스에서도 호출하고 참조할 수 있는지 확인합니다.
3. 메서드 시그니처가 다르다면 함수 선언 바꾸기로 슈퍼클래스에서 사용하고 싶은 형태로 통일합니다.
4. 슈퍼클래스에 새로운 메서드를 생성하고, 대상 메서드의 코드를 복사해넣습니다.
5. 정적 검사를 수행합니다.
6. 서브클래스 중 하나의 메서드를 제거합니다.
7. 테스트합니다.
8. 모든 서브클래스의 메서드가 없어질 때까지 다른 서브클래스의 메서들르 하나씩 제거합니다.

## 12.2 필드 올리기(Pull up Field)

- 반대 리팩터링 : 필드 내리기

```java
// as-is
class Employee {
  // ...
}

class Salesperson extends Employee {
  private String name;
}
class Engineer extends Employee {
  private String name;
}

// to-be
class Employee {
  private String name;
}

class Salesperson extends Employee {}
class Engineer extends Employee {}
```

- 필드 올리기를 사용하면 데이터 중복 선언을 없애고 필드를 사용하는 동작을 서브클래스에서 슈퍼클래스로 옮길 수 있습니다.
- 동적 언어 중에는 필드를 클래스 정의에 포함시키지 않는 경우가 많습니다. 그 대신 필드에 가장 처음 값이 대입될 때 등장합니다. 이런 경우라면 필드를 올리기 전에 반드시 생성자 본문부터 올려야 합니다.

### 절차

1. 후보 필드들을 사용하는 곳 모두가 그 필드들을 똑같은 방식으로 사용하는지 면밀히 살핍니다.
2. 필드들의 이름이 각기 다르다면 똑같은 이름으로 바꿉니다.
3. 슈퍼클래스에 새로운 필드를 생성합니다.

- 서브클래스에서 이 필드에 접근할 수 있어야 합니다(대부분 언어에서는 protected로 선언하면 됩니다.)

4. 서브클래스의 필드들을 제거합니다.
5. 테스트합니다.

## 12.3 생성자 본문 올리기(Pull Up Constructor Body)

```js
// as-is
class Party {
  // ...
}

class Employee extends Party {
  constructor(name, id, monthlyCost) {
    super();
    this._name = name;
    this._id = id;
    this._monthlyCost = monthlyCost;
  }
}

// to-be
class Party {
  constructor(name) {
    this._name = name;
  }
}

class Employee extends Party {
  constructor(name, id, monthlyCost) {
    super(name);
    this._id = id;
    this._monthlyCost = monthlyCost;
  }
}
```

- 생성자는 다루기 까다롭습니다. 일반 메서드와는 많이 달라서, 생성자에게 하는 일에 제약을 두는 편입니다.
- 이번 리팩터링이 간단히 끝날 것 같지 않다면 생성자를 팩터리 함수로 바꾸기를 고려해봅니다.

### 절차

1. 슈퍼클래스에 생성자가 없다면 하나 정의합니다. 서브클래스의 생성자들에서 이 생성자가 호출되는지 확인합니다.
2. 문장 스랄이드하기로 공통 문장 모두를 super() 호출 직후로 옮깁니다.
3. 공통 코드를 슈퍼클래스에 추가하고 서브클래스에서는 제거합니다. 생성자 매개변수 중 공통 코드에서 참조하는 값들을 모두 super()로 건넵니다.
4. 테스트합니다.
5. 생성자 시작 부분으로 옮길 수 없는 공통 코드에는 함수 추출하기와 메서드 올리기를 차례로 적용합니다.

## 12.4 메서드 내리기(Push Down Method)

- 반대 리팩터링 : 메서드 올리기

```js
// as-is
class Employee {
  get quota() {
    // ...
  }
}

class Engineer extends Employee {}
class Salesperson extends Employee {}

// to-be
class Employee {}

class Engineer extends Employee {}
class Salesperson extends Employee {
  get quota() {
    // ...
  }
}
```

- 특정 서브클래스 하나(혹은 소수)와만 관련된 메서드는 슈퍼클래스에서 제거하고 해당 서브클래스(들)에 추가하는 편이 깔끔합니다. 다만, 이 리팩터링은 해당 기능을 제공하는 서브클래스가 정확히 무엇인지를 호출자가 알고 있을 때만 적용할 수 있습니다. 그렇지 못한 상화잉라면 서브클래스에 따라 다르게 동작하는 슈퍼클래스의 기만적인 조건부 로직을 다형성으로 바꿔야합니다.

### 절차

1. 대상 메서드를 모두 서브클래스로 복사합니다.
2. 슈퍼클래스에서 그 메서드를 제거합니다.
3. 테스트합니다.
4. 이 메서드를 사용하지 않는 모든 서브클래스에서 제거합니다.
5. 테스트합니다.

## 12.5 필드 내리기(Push Down Field)

- 반대 리팩터링 : 필드 올리기

```java
// as-is
class Employee {
  private String quota;
}

class Salesperson extends Employee {}
class Engineer extends Employee {}

// to-be
class Employee {}

class Salesperson extends Employee {}
class Engineer extends Employee {
  protected String quota;
}
```

- 서브클래스 하나(혹은 소수)에서만 사용하는 필드는 해당 서브클래스(들)로 옮깁니다.

### 절차

1. 대상 필드를 모든 서브클래스에 정의합니다.
2. 슈퍼클래스에서 그 필드를 제거합니다.
3. 테스트합니다.
4. 이 필드를 사용하지 않는 모든 서브클래스에서 제거합니다.
5. 테스트합니다.

## 12.6 타입 코드를 서브클래스로 바꾸기(Replace Type Code with Subclasses)

- 반대 리팩터링 : 서브클래스 제거하기
- 하위 리팩터링
  - 타입 코드를 상태/전략 패턴으로 바꾸기
  - 서브클래스 추출하기

```js
// as-is
function createEmployee(name, type) {
  return Employee(name, type);
}

// to-be
function createEmployee(name, type) {
  switch (type) {
    case 'engineer':
      return Engineer(name, type);
    case 'salesperson':
      return Salesperson(name, type);
    case 'manager':
      return Manager(name, type);
  }
}
```

- 소프트웨어 시스템에서는 비슷한 대상들을 특정 특성에 따라 구분해야 할 때가 자주 있습니다. 이런 일을 다루는 수단으로는 타입 코드 필드가 있습니다. 타입 코드는 프로그래밍 언어에 따라 열거형이나 심볼, 문자열, 숫자 등으로 표현하며, 외부 서비스가 제공하는 데이터를 다루려 할때 딸려오는 일이 흔합니다.
- 타입 코드만으로도 특별히 불편한 상황은 별로 없지만 그 이상의 무언가가 필요할 때가 있습니다. 여기서 '그 이상'이라 하면 바로 서브클래스를 가리킵니다.
  서브클래스는 두 가지 면에서 특히 매력적입니다.
  - 첫째, 조건에 따라 다르게 동작하도록 해주는 다형성을 제공합니다.
  - 두 번째 매력은 특정 타입에서만 의미가 있는 값을 사용하는 필드나 메서드가 있을 때 발현됩니다.
- 이번 리팩터링은 대상 클래스에 직접 적용할지, 아니면 타입 코드 자체에 적용할지를 고민해야 합니다.

### 절차

1. 타입 코드 필드를 자가 캡슐화합니다.
2. 타입 코드 값 하나를 선택하여 그 값에 해당하는 서브클래스를 만듭니다. 타입 코드 게터 메서드를 오버라이드하여 해당 타입 코드의 리터럴 값을 반환하게 합니다.
3. 매개변수로 받은 타입 코드와 방금 만든 서브클래스를 매핑하는 선택 로직을 만듭니다.

- 직접 상속일 때는 생성자를 팩터리 함수로 바꾸기를 적용하고 선택 로직을 팩터리에 넣습니다. 간접 상속일 때는 선택 로직을 생성자에 두면 될 것입니다.

4. 테스트합니다.
5. 타입 코드 값 각각에 대해 서브클래스 생성과 선택 로직 추가를 반복합니다. 클래스 하나가 완성될 때마다 테스트합니다.
6. 타입 코드 필드를 제거합니다.
7. 테스트합니다.
8. 타입 코드 접근자를 이용하는 메서드 모두에 메서드 내리기와 조건부 로직을 다형성으로 바꾸기를 적용합니다.

## 12.7 서브클래스 제거하기(Remove Subclass)

- 반대 리팩터링 : 타입 코드를 서브클래스로 바꾸기
- 1판에서의 이름 : 하위클래스를 필드로 바꾸기

```js
// as-is
class Person {
  get genderCode() {
    return 'X';
  }
}
class Male extends Person {
  get genderCode() {
    return 'M';
  }
}
class Female extends Person {
  get genderCode() {
    return 'F';
  }
}

// to-be
class Person {
  get genderCode() {
    return this._genderCode;
  }
}
```

- 서브클래싱은 원래 데이터 구조와는 다른 변종을 만들거나 종류에 따라 동작이 달라지게 할 수 있는 유용한 메커니즘입니다. 다름을 프로그래밍하는 멋진 수단인 것입니다. 하지만 소프트웨어 시스템이 성장함에 따라 서브클래스로 만든 변종이 다른 모듈로 이동하거나 완전히 사라지기도 하면서 가치가 바래기도 합니다. 서브클래스는 결국 한 번도 활용되지 않기도 하며, 때론 서브클래스를 필요로 하지 않는 방시긍로 만들어진 기능에서만 쓰이기도 합니다.

### 절차

1. 서브클래스의 생성자를 팩터리 함수로 바꿉니다.

- 생성자를 사용하는 측에서 데이터를 필드를 이용해 어떤 서브클래스를 생성할지 결정한다면 그 결정 로직을 슈퍼클래스의 팩터리 메서드에 넣습니다.

2. 서브클래스이 타입을 검사하는 코드가 있다면 그 검사 코드에 함수 추출하기와 함수 옮기기를 차례로 적용하여 슈퍼클래스로 옮깁니다. 하나 변경할 때마다 테스트합니다.
3. 서브클래스의 타입을 나타내는 필드를 슈퍼클래스에 만듭니다.
4. 서브클래스를 참조하는 메서드가 방금 만든 타입 필드를 이용하도록 수정합니다.
5. 서브클래스를 지웁니다.
6. 테스트합니다.

## 12.8 슈퍼클래스 추출하기(Extract Superclass)

```js
// as-is
class Department {
  get totalAnnualCost() {
    // ...
  }
  get name() {
    // ...
  }
  get headCount() {
    // ...
  }
}
class Employee {
  get annualCost() {
    // ...
  }
  get name() {
    // ...
  }
  get id() {
    // ...
  }
}

// to-be
class Party {
  get name() {
    // ...
  }
  get annualCost() {
    // ...
  }
}

class Department extends Party {
  get annualCost() {
    // ...
  }
  get headCount() {
    // ...
  }
}
class Employee extends Party {
  get annualCost() {
    // ...
  }
  get id() {
    // ...
  }
}
```

- 비슷한 일을 수행하는 두 클래스가 보이면 상속 메커니즘을 이용해서 비슷한 부분을 공통의 슈퍼클래스로 옮겨 담을 수 있습니다.
- 슈퍼클래스 추출하기의 대안으로는 클래스 추출하기가 있습니다.

### 절차

1. 빈 슈퍼클래스를 만듭니다. 원래의 클래스들이 새 클래스를 상속하도록 합니다.

- 필요하다면 생성자에 함수 선언 바꾸기를 적용합니다.

2. 테스트합니다.
3. 생성자 본문 올리기, 메서드 올리기, 필드 올리기를 차례로 적용하여 공통 원소를 슈퍼클래스로 옮깁니다.
4. 서브클래스에 남은 메서드들을 검토합니다. 공통되는 부분이 있다면 함수로 추출한 다음 메서드 올리기를 적용합니다.
5. 원래 클래스들을 사용하는 코드를 검토하여 슈퍼클래스의 인터페이스를 사용할게 할지 고민합니다.

## 12.9 계층 합치기(Collapse Hierarchy)

```js
// as-is
class Employee {
  // ...
}
class Salesperson extends Employee {}

// to-be
class Employee {
  // ...
}
```

### 절차

1. 두 클래스 중 제거할 것을 고릅니다.

- 미래를 생각하여 더 적합한 이름의 클래스를 남깁니다. 둘 다 적절치 않다면 임의로 하나를 고릅니다.

2. 필드 올리기와 메서드 올리기 혹은 필드 내리기와 메서드 내리기를 적용하여 모든 요소를 하나의 클래스로 옮깁니다.
3. 제거할 클래스를 참조하던 모든 코드가 남겨질 클래스를 참조하도록 고칩니다.
4. 빈 클래스를 제거합니다.
5. 테스트합니다.

## 12.10 서브클래스 위임으로 바꾸기(Replace Subclass with Delegate)

```js
// as-is
class Order {
  get daysToShip() {
    return this._warehouse.daysToShip;
  }
}
class PriorityOrder extends Order {
  get daysToShip() {
    return this._priorityPlan.daysToShip;
  }
}

// to-be
class Order {
  get daysToShip() {
    return this._priorityPlan
      ? this._priorityPlan.daysToShip
      : this._warehouse.daysToShip;
  }
}
class PriorityOrder extends Order {
  get daysToShip() {
    return this._priorityPlan.daysToShip;
  }
}
```

- 속한 갈래에 따라 동작이 달라지는 객체들은 상속으로 표현하는 게 자연스럽습니다. 공통 데이터와 동작은 모두 슈퍼클래스에 두고 서브클래스는 자신에 맞게 기능을 추가하거나 오버라이드하면 됩니다. 객체 지향 언어로는 이런 형태로 구현하기가 쉽기 때문에 흔히 활용되는 메커니즘입니다.
- 상속에는 단점이 있습니다.
  - 가장 명확한 단점은 한 번만 쓸 수 있는 카드라는 것입니다. 무언가가 달라져야 하는 이유가 여러 개여도 상속에서는 그중 단 하나의 이유만 선택해 기준으로 삼을 수밖에 없습니다.
  - 상속은 클래스들의 관계를 아주 긴밀하게 결합합니다. 부모를 수정하면 이미 존재하는 자식들의 기능을 헤치기가 쉽기 때문에 각별히 주의해야 합니다.
- 위임은 상속의 두 문제를 모두 해결해줍니다. 다양한 클래스에 서로 다른 이유로 위임할 수 있습니다. 위임은 객체 사이의 일반적인 관계이므로 상호작용에 필요한 인터페이스를 명확히 정의할 수 있습니다. 즉, 상속보다 결합도가 훨씬 약합니다. 그래서 서브클래싱(상속) 관련 문제에 직면하게 되면 흔히들 서브클래스를 위임으로 바꾸곤 합니다.
- 유명한 원칙이 있습니다. `(클래스) 상속보다는 (객체) 컴포지션을 사용하라!` 여기서 컴포지션은 사실상 위임과 같은 말입니다. 이 말은 상속을 쓰지말라는게 아니라, 과용하는 데 따른 반작용으로 나온 것입니다. 상속을 사용하고 필요하면 언제든 서브클래스를 위임으로 바꿀 수 있습니다.
- 디자인패턴 책에 익숙한 사람이라면 이 리팩터링을 `서브클래스를 상태 패턴이나 전략 패턴으로 대체`한다고 생각하면 도움이 될 것입니다.

### 절차

1. 생성자를 호출하는 곳이 많다면 생성자를 팩터리 함수로 바꿉니다.
2. 위임으로 활용할 빈 클래스를 만듭니다. 이 클래스의 생성자는 서브클래스에 특화된 데이터를 전부 받아야 하며, 보통은 슈퍼클래스를 가리키는 역참조도 필요합니다.
3. 위임을 저장할 필드를 슈퍼클래스에 추가합니다.
4. 서브클래스 생성 코드를 수정하여 위임 인스턴스를 생성하고 위임 필드에 대입해 초기화합니다.

- 이 작업은 팩터리 함수가 수행합니다. 혹은 생성자가 정확한 위임 인스턴스를 생성할 수 있는 게 확실하다면 생성자에서 수행할 수도 있습니다.

5. 서브클래스의 메서드 중 위임 클래스로 이동할 것을 고릅니다.
6. 함수 옮기기를 적용해 위임 클래스로 옮깁니다. 원래 메서드에서 위임하는 코드는 지우지 않습니다.

- 이 메서드가 사용하는 원소 중 위임으로 옮겨야 하는 게 있다면 함께 옮깁니다. 슈퍼클래스에 유지해야 할 원소를 참조한다면 슈퍼클래스를 참조하는 필드를 위임에 추가합니다.

7. 서브클래스 외부에도 원래 메서드를 호출하는 코드가 있다면 서브클래스의 위임 코드를 슈퍼클래스로 옮깁니다. 이 때 위임이 존재하는지를 검사하는 보호 코드로 감싸야 합니다. 호출하는 외부 코드가 없다면 원래 메서드는 죽은 코드가 되므로 제거합니다.

- 서브클래스가 둘 이상이고 서브클래스들에서 중복이 생겨나기 시작했다면 슈퍼클래스를 추출합니다. 이렇게 하여 기본 동작이 위임 슈퍼클래스로 옮겨졌다면 슈퍼클래스의 위임 메섣들에는 보호 코드가 필요없습니다.

8. 테스트합니다.
9. 서브클래스의 모든 메서드가 옮겨질 때까지 5~8 과정을 반복합니다.
10. 서브클래스들의 생성자를 호출하는 코드를 찾아서 슈퍼클래스의 생성자를 사용하도록 수정합니다.
11. 테스트합니다.
12. 서브클래스를 삭제합니다.

## 12.11 슈퍼클래스를 위임으로 바꾸기(Replace Superclass with Delegate)

```js
// as-is
class List {
  // ...
}
class Stack extends List {}

// to-be
class Stack {
  constructor() {
    this._storage = new List();
  }
}
class List {}
```

- 객체 지향 프로그래밍에서 상속은 기존 기능을 재활용하는 강력하고 손쉬운 수단입니다. 기존 클래스를 상속하여 입맛에 맞게 오버라이드하거나 새 기능을 추가하면 됩니다. 하지만 상속이 혼란과 복잡도를 키우는 방식으로 이뤄지기도 합니다.
- 상속을 잘못 적용한 예로는 자바의 스택 클래스가 유명합니다.
- 제대로 된 상속이라면 서브클래스가 슈퍼클래스의 모든 기능을 사용함은 물론, 서브클래스의 인스턴스를 슈퍼클래스의 인스턴스로도 취급할 수 있어야 합니다.
- 위임을 이용하면 기능 일부만 빌려올 뿐인, 서로 별개인 개념임이 명확해집니다.
- 위임 기능을 이용할 호스트의 함수 모두를 전달 함수로 만들어야 한다는 단점이 있습니다.

### 절차

1. 슈퍼클래스 객체를 참조하는 필드를 서브클래스에 만듭니다(이번 리팩터링을 끝마치면 슈퍼클래스가 위임 객체가 될 것이므로 이 필드를 '위임 참조'라 부릅니다). 위임 참조를 새로운 슈퍼클래스 인스턴스로 초기화합니다.
2. 슈퍼클래스의 동작 각각에 대응하는 전달 함수를 서브클래스에 만듭니다(물론 위임 참조로 전달합니다). 서로 관련된 함수끼리 그룹으로 묶어 진행하며, 그룹을 하나씩 만들 때마다 테스트합니다.

- 대부분은 전달 함수 각각을 테스트할 수 있을 것입니다. 하지만 예컨대 게터와 세터 쌍은 둘 다 옮긴 후에야 테스트할 수 있습니다.

3. 슈퍼클래스의 동작 모두가 전달 함수로 오버라이드되었다면 상속 관계를 끊습니다.
