---
title: CHAPTER 11 - API 리팩터링
date: 2021-09-20 11:09:77
category: 리팩토링 2판
tags: []
draft: true
---

- 모듈과 함수는 소프트웨어를 구성하는 빌딩 블록이며, API는 이 블록들을 끼워 맞추는 연결부입니다.

## 11.1 질의 함수와 변경 함수 분리하기(Separate Query from Modifier)

```js
// as-is
function getTotalOutstandingAndSendBill() {
  const result = customer.invoices.reduce(
    (total, each) => each.amount + total,
    0,
  );
  sendBill();
  return result;
}

// to-be
function totalOutstanding() {
  return customer.invoices.reduce((total, each) => each.amount + total, 0);
}
function sendBill() {
  emailGateway.send(formatBill(customer));
}
```

- 우리는 외부에서 관찰할 수 있는 겉보기 부수효과가 전혀 없이 값을 반환해주는 함수를 추구해야 합니다. 아런 함수는 어느 때건 원하는 만큼 호출해도 아무 문제가 없습니다. 호출하는 문장의 위치를 호출하는 함수 안 어디로든 옮겨도 되며 테스트하기도 쉽습니다.
- 겉보기 부수효과가 있는 함수와 없는 함수는 명확히 구분하는 것이 좋습니다. 이를 위한 한 가지 방법은 '질의 함수(읽기 함수)는 모두 부수효과가 없어야 한다'는 규칙을 따르는 것입니다. 이를 `명령-질의 분리`라 합니다.

### 절차

1. 대상 함수를 복제하고 질의 목적에 충실한 이름을 짓습니다.

- 함수 내부를 살펴 무엇을 반환하는지 찾습니다. 어떤 변수의 값을 반환한다면 그 변수 이름이 훌륭한 단초가 될 것입니다.

2. 새 지르이 함수에서 부수효과를 모두 제거합니다.
3. 정적 검사를 수행합니다.
4. 원래 함수(변경 함수)를 호출하는 곳을 모두 찾아냅니다. 호출하는 곳에서 반환 값을 사용한다면 질의 함수를 호출하도록 바꾸고, 원래 함수를 호출하는 코드를 바로 아래 줄에 새로 추가합니다. 하나 수정할 때마다 테스트합니다.
5. 원래 함수에서 질의 관련 코드를 제거합니다.
6. 테스트합니다.

## 함수 매개변수화하기(Parameterize Function)

- 1판에서의 이름 : 메서드를 매개변수로 전환

```js
// as-is
function tenPercentRaise(aPerson) {
  aPerson.salary = aPerson.salary.multiply(1.1);
}
function fivePercentRaise(aPerson) {
  aPerson.salary = aPerson.salary.multiply(1.05);
}

// to-be
function raise(aPerson, factor) {
  aPerson.salary = aPerson.salary.multiply(factor);
}
```

### 절차

1. 비슷한 함수 중 하나를 선택합니다.
2. 함수 선언 바꾸기로 리터럴들을 매개변수로 추가합니다.
3. 이 함수를 호출하는 곳 모두에 적절한 리터럴 값을 추가합니다.
4. 테스트합니다.
5. 매개변수로 받은 값을 사용하도록 함수 본문을 수정합니다. 하나 수정할 때마다 테스트합니다.
6. 비슷한 다른 함수를 호출하는 코드를 찾아 매개변수화된 함수를 호출하도록 하나씩 수정합니다. 하나 수정할 때마다 테스트합니다.

- 매개변수화된 함수가 대체할 비슷한 함수와 다르게 동작한다면, 비슷한 함수의 동작도 처리할 수 있도록 본문 코드를 적절히 수정한 후 진행합니다.

## 11.3 플래그 인수 제거하기(Remove Flag Argument)

- 1판에서의 이름 : 메개변수를 메서드로 전환

```js
// as-is
function setDimension(name, value) {
  if (name === 'height') {
    this._height = value;
    return;
  }
  if (name === 'width') {
    this._width = value;
    return;
  }
}

// to-be
function setHeight(value) {
  this._height = value;
}
function setWidth(value) {
  this._width = value;
}
```

- 플래그 인수란 호출되는 함수가 실행할 로직을 호출하는 쪽에서 선택하기 위해 전달하는 인수입니다.
- 플래그 인수는 호출할 수 있는 함수들이 무엇이고 어떻게 호출해야 하는지를 이해히기 어렵게 합니다.
- 특정 기능 하나만 수행하는 명시적인 함수를 제공하는 편이 훨씬 깔끔합니다.
- 플래스 인수가 되려면 호출하는 쪽에서 불리언 값으로(프로그램에서 사용되는 데이터가 아닌) 리터럴 값을 건네야 합니다. 또한, 호출되는 함수는 그 인수를(다른 함수에 전달하는 데이터가 아닌) 제어 흐름을 결정하는 데 사용해야 합니다.
- 플래그 인수를 제거하면 코드가 깔끔해짐은 물론 프로그래밍 도구에도 도움을 줍니다.
- 함수 하나에서 플래그 인수를 두 개 이상 사용하면 플래그 인수를 써야 하는 합당한 근거가 될 수 있습니다. 하지만 함수 하나가 너무 많은 일을 처리하고 있다는 신호이기도 합니다.

### 절차

1. 매개변수로 주어질 수 있는 값 각각에 대응하는 명시적 함수들을 생성합니다.

- 주가 되는 함수에 깔끔한 분배 조건문이 포함되어 있다면 조건문 분해하기로 명시적인 함수들을 생성합니다. 그렇지 않다면 래핑 함수 형태로 만듭니다.

2. 원래 함수를 호출하는 코드들을 모두 찾아서 각 리터럴 값에 대응되는 명시적 함수를 호출하도록 수정합니다.

## 11.4 객체 통재로 넘기기(Preserve Whole Object)

```js
// as-is
const low = aRoom.daysTempRange.low;
const height = aRoom.daysTempRange.height;
if (aPlan.withinRange(low, heigh)) {
}

// to-be
if (aPlan.withinRange(aRoom.daysTempRange)) {
}
```

- 레코드를 통째로 넘기면 변화에 대응하기 쉽습니다.
- 함수가 레코드 자체에 의존하기를 원치 않을 때는 이 리팩터링을 수행하지 않는데, 레코드와 함수가 서로 다른 모듈에 속한 상황리면 특히 더 그렇습니다.
- 객체 통재로 넘기기는 특히 매개변수 객체 만들기 후, 즉 산재한 수많은 데이터 더미를 새로운 객체로 묵은 후 적용하곤 합니다.
- 한 객체가 제공하는 기능 중 항상 똑같은 일부만을 사용하는 코드가 많다면, 그 기능만 따로 묶어서 클래스로 추출하라는 신호일 수 있습니다.
- 다른 객체의 메서드를 호출하면서 호출하는 객체 자신이 가지고 있는 데이터 여러 개를 건네는 경우 데이터 여러 개 대신 객체 자신의 참조만 건네도록 수정할 수 있습니다(자바스크립트라면 this를 건넬 것입니다).

### 절차

1. 매개변수들을 우너항는 형태로 받는 빈 함수를 만듭니다.

- 마지막 단계에서 이 함수의 이름을 변경해야 하니 검색하기 쉬운 이름으로 지어줍니다.

2. 새 함수의 본문에서는 원래 함수를 호출하도록 하며, 새 매개변수와 원래 함수의 매개변수를 매핑합니다.
3. 정적 검사를 수행합니다.
4. 모든 호출자가 새 함수를 사용하게 수정합니다. 하니씩 수정하며 테스트합니다.

- 수정 후에는 원래의 매개변수를 만들어내는 코드 일부가 필요 없어질 수 있습니다. 따라서 죽은 코드 제거하기로 없앨 수 있을 것입니다.

5. 호출자를 모두 수정했다면 원래 함수를 인라인합니다.
6. 새 함수의 이름을 적절히 수정하고 모든 호출자에 반영합니다.

## 11.5 매개변수를 질의 함수로 바꾸기(Replace Parameter with Query)

- 반대 리팩터링 : 질의 함수를 매개변수로 바꾸기
- 1판에서의 이름 : 매개변수 세트를 메서드롤 전환

```js
// as-is
availableVacation(anEmployee, anEmployee.grade);

function availableVacation(anEmployee, grade) {
  // 연휴 계산 ...
}

// to-be
availableVacation(anEmployee);

function availableVacation(anEmployee) {
  const grade = anEmployee.grade;
  // 연휴 계산 ...
}
```

- 매개변수 목록은 함수의 변동 요인을 모아놓은 곳입니다. 즉, 함수의 동작에 변화를 줄 수 이쓴 일차적인 수단입니다. 다른 코드와 마찬가지로 이 목로겡서도 중복은 피하는 게 좋으며 짧을수록 이해하기 쉽습니다.
- 피호출 함수가 스스로 쉽게 결정할 수 있는 값을 매개변수로 건네는 것도 일종의 중복입니다.
- 매개변수를 제거하면 값을 결정하는 책임 주체가 달라집니다. 매개변수가 있다면 결정 주체가 호출자가 되고, 매개변수가 없다면 피호출 함수가 됩니다.
- 매개변수를 질의 함수로 바꾸지 말아야 할 상황도 있습니다. 가장 흔한 예는 매개변수를 제거하면 피호출 함수에 원치 않는 의존성이 생길 때 입니다. 이런 상황은 주로 함수 본문에서 외부 함수를 호출해야 하거나 나중에 함수 밖으로 빼내길 원하는 수용 객체에 담긴 데이터를 사용해야 할 때 일어납니다.
- 제거하려는 매개변수의 값을 다른 매개변수에 질의해서 얻을 수 있다면 안심하고 질의 함수로 바꿀 수 있습니다.
- 주의사항은 대상 함수가 참조 투명해야 합니다. 참조투명이란 '함수에 똑같은 값을 거네 호출하면 항상 똑같이 동작한다'는 뜻입니다.

### 절차

1. 필요하다면 대상 매개변수의 값을 계산하는 코드를 별도 함수로 추출해놓습니다.
2. 함수 본문에서 대상 매개변수로의 참조를 모두 찾아서 그 매개변수의 참조를 모두 찾아서 그 매개변수의 값을 만들어주는 표현식을 참조하도록 바꿉니다. 하나 수정할 때마다 테스트합니다.
3. 함수 선언 바꾸기로 대상 매개변수를 없앱니다.

## 11.6 질의 함수를 매개변수로 바꾸기(Replace Query with Parameter)

- 반대 리팩터링 : 매개변수를 질의 함수로 바꾸기

```js
// as-is
targetTemperature(aPlan);

function targetTemperature(aPlan) {
  currentTemperature = thermostat.currentTemptation;
  // 생략
}

// to-be
targetTemperature(aPlan, currentTemperature);

function targetTemperature(aPlan, currentTemperature) {
  // 생략
}
```

- 참조 투명하지 않은 원소에 ㄷ접근하는 모든 함수는 참조 투명성을 잃게 되는데, 이 문제는 해당 원소를 매개변수로 바꾸면 해결됩니다. 책임이 호출자로 옮겨진다는 점을 고려해야 하지만, 모듈을 ㅊ마조 투명하게 만들어 얻는 장점은 대체로 아주 큽니다.
- 이번 리팩터링을 활용하면 프로그램의 일부를 순수함수로 바꿀 수 있으며, 결과적으로 그 부분은 테스트하거나 다루기가 쉬워집니다.
- 이 리팩터링의 단점은 질의 함수를 매개변수로 바꾸면 어떤 값을 제공할지를 호출자가 알아내야 합니다. 결국 호출자가 복잡해 집니다.

### 절차

1. 변수 추출하기로 질의 코드를 함수 본문의 나머지 코드와 분리합니다.
2. 함수 본문 중 해당 질의를 호출하지 않는 코드들을 별도 함수로 추출합니다.

- 이 함수의 이름은 나중에 수정해야 하니 검색하기 쉬운 이름으로 짓습니다.

3. 방금 만든 변수를 인라인하여 제거합니다.
4. 원래 함수도 인라인합니다.
5. 새 함수의 이름을 원래 함수의 이름으로 고쳐줍니다.

## 11.7 세터 제거하기(Remove Setting Method)

```js
// as-is
class Person {
  get name() {
    // ...
  }
  set name(aString) {
    // ...
  }
}

// to-be
class Person {
  get name() {
    // ...
  }
}
```

- 세터 메서드가 있다고 함은 필드가 수정 될 수 있다는 뜻입니다. 객체 생성 후에는 수정되지 않길 원하는 필드라면 세터를 제공하지 않았을 것입니다. 그러면 해당 필드는 오직 생성자에서만 설정되며, 수정하지 않겟다는 의도가 명명백백해지고, 변경될 가능성이 봉쇄됩니다.
- 세터 제거하기 리팩터링이 필요한 상황은 주로 두 가지 입니다.
  - 첫째, 사람들이 무조건 접근자 메서드를 통해서만 핋드를 다루려고 할 때 입니다. 심지어 생성자 안에서도 말입니다.
  - 둘째, 클라이언트에서 생성 스크립트를 사용해 객체를 생성할 때 입니다.

### 절차

1. 설정해야 할 값을 생성자에서 받지 않는다면 그 값을 받을 매개변수를 생성자에 추가합니다(함수 선언 바꾸기). 그런 다음 생성자 안에서 적절한 세터를 호출합니다.

- 세터 여러 개를 제거하려면 해당 값 모두를 한꺼번에 생성자에 추가합니다. 그러면 이후 과정이 간소해집니다.

2. 생성자 밖에서 세터를 호출하는 곳을 찾아 제거하고, 대신 새로운 생성자를 사용하도록 합니다. 하나 수정할 때마다 테스트합니다.

- (갱신하려는 대상이 공유 참조 객체라서) 새로운 객체를 생성하는 방ㄹ식으로는 세터 호출을 대체할 수 없다면 이 리팩터링을 취소합니다.

3. 세터 메서드를 인라인합니다. 가능하다면 해당 필드를 불변으로 만듭니다.
4. 테스트합니다.

## 11.8 생성자를 팩터링 함수로 바꾸기(Replace Constructor with Factory Function)

- 1판에서의 이름 : 생성자를 팩토링 메서드로 전환

```js
// as-is
leadEngineer = new Employee(document, leadEngineer, 'E');

// to-be
leadEngineer = createEngineer(document.leadEngineer);
```

- 생성자에는 일반 함수에는 없는 이상한 제약이 따라붙기도 합니다. 팩터링 함수에는 이런 제약이 없습니다.

### 절차

1. 팩터리 함수를 만듭니다. 팩터리 함수의 본문에서는 원래의 생성자를 호출합니다.
2. 생성자를 호출하던 코드를 팩터리 함수로 바꿉니다.
3. 하나씩 수정할 때마다 테스트합니다.
4. 생성자의 가시 범위가 최소가 되도록 제한합니다.

## 11.9 함수를 명령으로 바꾸기(Replace Function with Command)

- 반대 리팩터링 : 명령을 함수로 바꾸기
- 1판에서의 이름 : 메서드를 메서드 객체로 전환

```js
// as-is
function score(candidate, medicalExam, scoringGuide) {
  let result = 0;
  let healthLevel = 0;
  // 긴 코드 생략
}

// to-be
class Score {
  constructor(candidate, medicalExam, scoringGuide) {
    this._candidate = candidate;
    this._medicalExam = medicalExam;
    this._scoringGuide = scoringGuide;
  }

  execute() {
    this._result = 0;
    this._healthLevel = 0;
    // 긴 코드 생략
  }
}
```

- 함수(독립된 함수든 객체 소소된 메서드든)는 프로그래밍의 기본적인 빌딩 블록 중 하나입니다. 그런데 함수를 그 함수만을 위한 객체 안으로 캡슐화하면 더 유용해지는 상황이 있습니다. 이런 객체를 가리켜 `명령 객체` 혹은 단순히 `명령`이라 합니다.
- 명령 객체 대부분은 메서드 하나로 구성되며, 이 메서드를 요청해 실행하는 것이 이 객체의 목적입니다.
- 명령은 평범한 함수 메커니즘보다 훨씬 유연하게 함수를 제어하고 표현할 수 있습니다.
- 하지만 유연성은 (언제나 그렇듯) 복잡성을 키우고 얻는 대가임을 잊지 말아야 합니다. 일급 함수와 명령 중 선택해야 한다면, 95%는 일급 함수의 손을 들어줍니다. 명령을 선택할 때는 명령보다 더 간단한 방식으로는 얻을 수 없는 기능이 필요할 때 뿐입니다.

### 절차

1. 대상 함수의 기능을 옮길 빈 클래스를 만듭니다. 클래스 이름은 함수 이름에 기초해 짓습니다.
2. 방금 생성한 빈 클래스로 함수를 옮깁니다

- 리팩터링이 끝날 때까지는 원래 함수를 전달 함수 역할로 남겨둡니다.
- 명령 관련 이름은 사용할는 프로그래밍 언어의 명명규칙을 따릅니다. 규칙이 딱히 없다면 'execute'나 'call' 같이 명령의 실행 함수에 흔히 쓰이는 이름을 택합니다.

3. 함수의 인수들 각각은 명령의 필드로 만들어 생성자를 통해 설정할지 고민해봅니다.

## 11.10 명령을 함수로 바꾸기(Replace Command with Function)

- 반대 리팩터링 : 함수를 명령으로 바꾸기

```js
// as-is
class ChargeCalculator {
  constructor(customer, usage) {
    this._customer = customer;
    this._usage = usage;
  }
  execute() {
    return this._customer.rate * this._usage;
  }
}

// to-be
function charge(customer, usage) {
  return customer.rate * usage;
}
```

- 명령 객체는 복잡한 연산을 다룰 수 있는 강력한 메커니즘을 제공합니다. 명령은 그저 함수를 하나 호출해 정해진 일을 수행하는 용도로 주로 쓰입니다. 이런 상황이고 로직이 크게 복잡하지 않다면 명령 객체는 장점보다 단점이 크디 평범한 함수로 바꿔주는 게 낫습니다.

### 절차

1. 명령을 생성하는 코드와 명령의 실행 메서드를 호출하는 코드를 함께 함수로 추출합니다.

- 이 함수가 바로 명령을 대체할 함수입니다.

2. 명령의 실행 함수가 호출하는 보조 메서드들 각각을 인라인합니다.

- 보조 메서드가 값을 반환한다면 함수 인라인에 앞서 변수 추출하기를 적용합니다.

3. 함수 선언 바꾸기를 적용하여 생성자의 매개변수 모두를 명령의 실행 메서드로 옮깁니다.
4. 명령의 실행 메서드에서 참조하는 필드들 대신 대응하는 매개변수를 사용하게끔 바꿉니다. 하나식 수정할 때마다 테스트합니다.
5. 생성자 호출과 명령의 실행 메서드 호출을 호출자(대체 함수) 안으로 인라인 합니다.
6. 테스트합니다.
7. 죽은 코드 제거하기 로 명령 클래스를 앲앱니다.

## 11.11 수정된 값 반환하기(Return Modified Value)

```js
// as-is
let totalAscent = 0;
calculateAscent();

function calculateAscent() {
  for (let i = 1; i < points.length; i++) {
    const verticalChange = points[i].elevation - points[i - 1].elevation;
    totalAscent += verticalChange > 0 ? vesicalChange : 0;
  }
}

// to-be
let totalAscent = calculateAscent();

function calculateAscent() {
  let result = 0;
  for (let i = 1; i < points.length; i++) {
    const verticalChange = points[i].elevation - points[i - 1].elevation;
    result += verticalChange > 0 ? vesicalChange : 0;
  }
  return result;
}
```

- 데이터가 수정된다면 그 사실을 명확히 알려주어서, 어느 함수가 무슨 일을 하는지 쉽게 앍 수 있게 하는 일이 대단히 중요합니다.
- 데이터가 수정됨을 알려주는 좋은 방법은 변수를 갱신하는 함수라면 수정된 값을 반환하여 호출자가 그 값을 변수에 담아두도록 하는 것입니다.
- 이 리팩터링은 값 하나를 계산한다는 분명한 목적이 있는 함수들에 가장 효과적이고, 반대로 값 여러 개를 갱신하는 함수에는 효과적이지 않습니다. 한편 함수 옮기기의 작업으로 적용하기에 좋은 리팩터링입니다.

### 절차

1. 함수가 수정된 값을 반환하게 하여 호출자가 그 값을 자신의 변수에 저장하게 됩니다.
2. 테스트합니다.
3. 피호출 함수 안에 반환할 값을 가리키는 새로운 변수를 선언합니다.

- 이 작업이 의도대로 이뤄졌는지 검사하고 싶다면 호출자에서 초깃값을 수정해봅니다. 제대로 처리했다면 수정된 값이 무시됩니다.

4. 테스트합니다.
5. 계산이 선언과 동시에 이뤄지도록 통합합니다(즉, 선언 시점에 계산 로직을 바로 실행해 대입합니다).
6. 테스트합니다.
7. 피호출 함수의 변수 이름을 새 역할에 어울리도록 바꿔줍니다.
8. 테스트합니다.

## 11.12 오류 코드를 예외로 바꾸기(Replace Error Code with Exception)

```js
// as-is
if (data) {
  return new ShoppingRules(data);
} else {
  return -23;
}

// to-be
if (data) {
  return new ShoppingRules(data);
} else {
  return new OrderProcessingError(-23);
}
```

- 예외는 프로그래밍 언어에서 제공하는 독립적인 오류 처리 메커니즘입니다. 오류가 발견되면 예외를 던집니다. 그러면 적절한 예외 핸들러를 찾을 때까지 콜스택을 타고 위로 전파됩니다(핸들러를 찾지 못하면 보통은 단순할 정도록 극단적인 기본 동작이 수행됩니다). 예외를 사용하면 오류 코드를 일일이 검사하거나 오류를 식별해 콜스택 위로 던지는 일을 신경 쓰지 않아도 됩니다. 예외에는 독자적인 흐름이 있어서 프로그램의 나머지에서는 오류 발생에 따른 복잡한 상황에 대처하는 코드를 작성하거나 읽을 일이 없게 해줍니다.
- 예외는 정교한 메커니즘이지만 대다수의 다른 정교한 메커니즘과 같이 정확하게 사용할 때만 최고의 효과를 냅니다. 예외는 정확히 예쌍 밖의 동작일 때만 쓰여야 합니다.

### 절차

1. 콜스택 상위에 해당하는 예외를 처리할 예외 핸들러를 작성합니다.

- 이 핸들러는 처음에는 모든 예외를 다시 던지게 해둡니다.
- 적절한 처리를 해주는 핸들러가 이미 있다면 지금 콜스택도 처리할 수 있도록 확장합니다.

2. 테스트합니다.
3. 해당 오류 코드를 대체할 예외와 그 밖의 예외를 구분할 식별 방법을 찾습니다.

- 사용하는 프로그래밍 언어에 맞게 선택하면 됩니다. 대부분 언어에서는 서브클래스를 사용하면 될 것입니다.

4. 정적 검사를 수행합니다.
5. catch절을 수행하여 직접 처리할 수 있는 예외는 적절히 대처하고 그렇지 않은 예외는 다시 던집니다.
6. 테스트합니다.
7. 오류 코드를 반환하는 곳 모두에서 예외를 던지도록 수정합니다. 하니씩 수정할 때마다 테스트합니다.
8. 모두 수정했다면 그 오류 코드를 콜스택 위로 전달하는 코드를 모두 제거합니다. 하니씩 수정할 때마다 테스트 합니다.

- 먼저 오류 코드를 검사하는 부분을 함정으로 바꾼 다음, 함정에 걸려들지 않는지 테스트 한 후 제거하는 전략을 권합니다. 함정에 걸려드는 곳이 있다면 오류 코드를 검사하는 코드가 아직 남아 있다는 듰입니다. 함정을 무사히 피했다면 안심하고 본문을 정리합니다.

## 11.13 예외를 사전확인으로 바꾸기(Replace Exception with Pre check)

- 1판에서의 이름 : 예외 처리를 테스트로 교체

```java
// as-is
double getValueForPeriod(int periodNumber) {
  try {
    return values[periodNumber];
  } catch (ArrayIndexOutOfBoundsException e) {
    return 0;
  }
}

// to-be
double getValueForPeriod(int periodNumber) {
  return periodNumber >= values.length ? 0 : values[periodNumber]
}
```

- 예외는 `뜻박의 오류`라는 말 그대로 예외적으로 동작할 때만 쓰여야 합니다. 함수 수행 시 문제가 될 수 있는 조건을 함수 호출 전에 검사할 수 있다면, 예외를 던지는 대신 호출하는 곳에서 조건을 검사하도록 해야 합니다.

### 절차

1. 예외를 유발하는 상황을 검사할 수 있는 조건물을 추가합니다. catch 블록의 코드를 조건물의 조건절 중 하나로 옮기고 남은 try 블록의 코드를 다른 조건절로 옮깁니다.
2. catch 블록에 어서션을 추가하고 테스트합니다.
3. try 문과 catch 블록을 제거합니다.
4. 테스트합니다.
