---
title: GoF 디자인 패턴 정리
date: 2020-07-06 17:07:01
category: GoF 디자인 패턴
draft: false
---

## 생성패턴

- 싱글턴 : 오직 한 개의 인스턴스 보장, 전역적인 접근 제공합니다.
  - Angular Service
- 팩토리 메서드 : 객체 생성 인터페이스 정의, 서브클래스에서 클래스 생성을 결정합니다.
- 추상 팩토리 : 객체 생성과 표현을 분리합니다.
- 프로토타입 : 원형 복사해서 새로운 객체 생성합니다.
- 빌더 : 복잡한 객체 생성의 동일한 절차 제공합니다.

## 구조패턴

- 프록시 : 다른 객체에 대한 접근 제어합니다.
  - ES6 Proxy
- 퍼사드 : 인터페이스를 집합에 대한 획일화된 하나의 인터페이스 제공합니다.
- 데코레이터 : 객체 동적 새로운 책임 추가합니다.
  - TypeScript Decorator
- 컴포지트 : 하나의 추상 클래스로 부분과 전체의 계층을 표현합니다.
- 브릿지 : 구현에서 추상을 분리하여, 이들이 독립적으로 다양성을 가질 수 있도록 합니다.
- 어뎁터 : 서로 일치하지 않는 인터페이스를 사용자가 기대하는 인터페이스 형태로 적응합니다.
- 플라이웨이트 : 많은 수의 객체를 효율적으로 제공하기 위해 공유개념을 이용합니다.

## 행동패턴

- 이터레이터 : 내부 표현부를 노출하지 않고 어떤 객체 집합에 속한 원소들을 순차적으로 접근할 수 있는 방법을 제공하는 패턴입니다.
  - ES6 Iterator
- 옵져버 : 객체 사이에 일 대 다의 의존 관계를 정의해 두어, 어떤 객체의 상태가 변할 때 그 객체의 의존성을 가진 다른 객체들이 그 변화를 통지받고 자동으로 갱신될 수 있게 만드는 패턴입니다.
  - MutationObserver
  - IntersectionObserver
- 상태 : 객체의 내부 상태에 따라 스스로 행동을 변경할 수 있게 끔 허가하는 패턴입니다.
- 전략 : 동일 계열의 알고리즘군을 정의하고, 각각의 알고리즘을 캡슐화하여, 이 들을 상호교환이 가능하도록 만드는 패턴입니다.
- 책임연쇄 : 하나의 요청에 대한 처리가 반드시 한 객체에거만 되지 않고, 여러 객체에서 그 처리 기회줍니다.
- 커멘드 : 요청 자체 캡슐화, 요청 대기/로깅하여, 되돌릴 수 있는 연산을 지원합니다.
- 탬플릿 메소드 : 알고리즘의 뼈대만을 정의하고 각 단계에서 수행할 구체적 처리는 서브클래스쪽으로 미루는 패턴입니다.
- 방문자 : 객체 구조를 이루는 원소에 대해 수행할 연산을 표현하는 패턴으로, 연산을 적용할 원소의 클래스를 변경하지 않고도 새로운 연산을 정의할 수 있게 합니다.
- 미디에이터 : 한 집합에 속해있는 객체들의 상호작용을 캡슐화하는 중앙객체를 정의하는 패턴입니다.
- 메멘토 : 캡슐화를 위배하지 않는 채 어떤 객체의 내부상태를 잡아내고 신체화시켜, 이후에 해당 객체가 그 상태로 다시 되돌아올 수 있도록 하는 패턴입니다/
- 인터프리터 : 주어진 언어에 대해, 그 언어의 문법을 위한 표현 수단을 정의하고, 이와 어울러 그 표현수단을 사용하여 해당 언어로 작성된 문장을 해석하는 해석기를 정의하는 패턴이다.

## 참고

- [GoF 디자인 패턴 정리](https://peter-cho.gitbook.io/book/12-gof/gof)
