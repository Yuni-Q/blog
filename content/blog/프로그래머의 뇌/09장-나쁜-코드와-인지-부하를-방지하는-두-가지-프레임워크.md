---
title: 09장 나쁜 코드와 인지 부하를 방지하는 두 가지 프레임워크
date: 2023-02-06 01:02:05
category: 프로그래머의 뇌
tags: []
draft: true
---

## 이 장에서는 다음과 같은 내용을 다룬다

- 코드 스멜과 인지 부하의 연관성
- 나쁜 이름과 인지 부하의 연관성

## 9.1 코드 스멜이 인지 부하를 초래하는 이유

- 코드 스멜(code smell)은 작동은 하지만 개선의 여지가 있는 코드를 의미한다.
  - 코드 스멜의 예로는 매우 긴 메서드, 동시에 너무 많은 작업을 시도하는 클래스 및 지나치게 복잡한 스위치 문이 있다.

### 9.1.1 코드 스멜에 대한 간략한 소개

#### 파울러의 코드 스멜에 대한 간략한 설명 및 수준

- 메시지 수준 코드 스멜
- 클래스 수준 코드 스멜
- 코드 베이스 수준 코드 스멜

| 코드 스멜                      | 설명                                                                                                                                                                                          | 수준       |
| ------------------------------ | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ---------- |
| 긴 메서드                      | 메서드는 여러가지 다른 일을 수행하느라 라인이 길어져서느 안 됩니다.                                                                                                                           | 메서드     |
| 많은 인수                      | 메서드는 인수가 많으면 안 됩니다.                                                                                                                                                             | 메서드     |
| 스위치 문                      | 스위치 문이 길면 안 됩니다. `다형성`을 통해 해결할 수 있습니다.                                                                                                                               | 메서드     |
| 다른 것처럼 보이나 같은 클래스 | 처음 보면 다른 것처럼 보이지만 유사한 필드와 메서드를 갖는 클래스가 두 개 있으면 안 됩니다.                                                                                                   | 클래스     |
| 원시 타입 집착                 | 클래스에서 원시 데이터 타입의 과도한 사용은 피해야 합니다.                                                                                                                                    | 클래스     |
| 미완성 라이브러리 클래스       | 메서드를 라이브러리 클래스가 아닌 임의의 클래스에 추가해서는 안 됩니다.                                                                                                                       | 클래스     |
| 너무 큰 클래스                 | 너무 많은 메서드와 필드를 가지고 있어서 클래스가 제공하는 추상화를 불명확하게 만들어서는 안 됩니다.                                                                                           | 클래스     |
| 게으른 클래스                  | 클래스가 하는 일이 너무 적으면 존재할 이유가 없습니다.                                                                                                                                        | 클래스     |
| 데이터 클래스                  | 클래스는 데이터만 가져서는 안되고 메서드도 가져야 합니다.                                                                                                                                     | 클래스     |
| 임시 필드                      | 클래스는 불필요한 임시 필드를 가져서는 안 됩니다.                                                                                                                                             | 클래스     |
| 데이터 그룹                    | 같이 사용되는 데이터는 같은 클래스나 구조체에 저장되어야 합니다.                                                                                                                              | 클래스     |
| 산재한 수정                    | 일반적으로 코드 수정은 한 클래스의 한 부분에서만 이루어져야 합니다. 클래스의 여러 부분을 수정해야 한다면 코드 구조가 잘못된 것을 의미합니다.                                                  | 코드베이스 |
| 기능 이전                      | 클래스 A의 많은 메서드가 클래스 B에 의해 참조되면 그 메서드들은 B로 옮겨야합니다.                                                                                                             | 코드베이스 |
| 부적절한 연관                  | 클래스는 다른 클래스에 광범위하게 연관되지 않아야 합니다.                                                                                                                                     | 코드베이스 |
| 중복 코드 또는 코드 클론       | 같은 혹은 비슷한 코드가 코드베이스 내 여러 군데에서 중복돼서는 안 됩니다.                                                                                                                     | 코드베이스 |
| 주석문                         | 주석문은 그 코득 ㅏ무엇을 하는지가 아니라 왜 거기 있는지를 설명해야 합니다.                                                                                                                   | 코드베이스 |
| 메시지 체인                    | 메시지 호출이 연속해서 꼬리에 꼬리를 무는 방식으로 이루어져서는 안 됩니다.                                                                                                                    | 코드베이스 |
| 미들맨                         | 클래스가 자신이 하는 일은 없이 위임을 많이 사용하면 이 클래스가 굳이 존재해야 할 이유가 있을까요?                                                                                             | 코드베이스 |
| 평행상속                       | 한 클래스의 서브 클래스를 만들 때마다 다른 클래스의 서브 클래스도 만들어야 한다면 두 클래스의 기능은 하나의 클래스로 합쳐야 합니다.                                                           | 코드베이스 |
| 상속 거절                      | 클래스가 자신이 사용하지 않는 것을 상속받는다면 상속은 필요 없는 일일지도 모릅니다.                                                                                                           | 코드베이스 |
| 샷건 수술                      | 일반적으로 코드 수정은 한 클래스에 대해서만 이루어져야 합니다. 하나의 사항에 대해 여러 클래스를 수정해야 한다면 코드 구조에 문제가 있으므로 수정할 여러 부분을 하나의 클래스로 묶어야 합니다. | 코드베이스 |
| 추측에 근거한 일반성           | 만일의 경우에 대비한 코드를 추가하지 말고 플리요한 기능만 추가합니다.                                                                                                                         | 코드베이스 |

#### 코드 스멜의 영향

- 코드 스멜이 있다고 해서 반드시 오류가 있는 것은 아니다. 다만 코드 스멜을 가지고 있는 코드는 오류가 있을 가능성이 높은 것으로 알려져 있다.

### 9.1.2 코드 스멜이 인지 과정에 악영향을 미치는 방식

- 긴 매개변수 목록, 복잡한 스위치 문: 작업 기억 공간의 용량 초과
- 신의 클래스, 긴 메서드: 효율적인 청킹이 불가능
  - 개별 함수, 클래스, 메서드로 기능을 분할할 때의 이점은 이름이 문서 역할을 한다는 것이다.
- 코드 클론: 청킹이 잘못됨

## 9.2 나쁜 이름이 인지 부하에 미치는 영향

- 코드 스멜은 구조적 안티패턴 문제가 있는 코드다. 이것은 코드가 잘 작성되었으나 파악하기 어려운 구조로 만들어졌다는 것을 의미한다. 그러나 코드에는 `개념적` 안티패턴도 있을 수 있다. 코드가 짧은 메서드와 깔끔한 클래스로 올바르게 구성되어 있지만 혼동되는 이름을 갖는 경우다. 이러한 코드 문제는 두 번째 프레임워크인 `언어적 안티패턴`으로 설명할 수 있다. 두 프레임워크는 코드의 서로 다른 측면을 다루기 때문에 서로 잘 보완한다.

### 언어적 안티패턴

- 안티패턴은 언어적 요소가 수행하는 역할과 일치하지 않을 때 발생한다.
  - 코드의 언어적 요소란 메서드 입출력 정의, 설명 문사, 속성 이름, 데이터 타입, 주석문 등을 포함하는 코드의 자연어 부분으로 정의한다.
  - 불리언 변수처럼 보이는 변수가 실제로는 정숫값을 갖는다든지 하는 경우다.

#### 아나우도바의 6사지 언어적 안티패턴

- 이름을 나타내는 것보다 더 많은 일을 하는 메서드
- 이름이 나타내는 것보다 더 적은 일을 하는 메서드
- 이름과 정반대의 일을 하는 메서드
- 개체에 포함된 것보다 더 많은 것을 가지고 있는 것처럼 보이는 식별자 이름
- 개체에 포함된 것을 누락하는 식별자 이름
- 개체에 포함된 거슬 반대되는 식별자 이름

### 9.2.2 인지 부하 측정

#### 인지 부하에 대한 파스 척도

- 생소한 코드를 파악하는 작업을 할 때 파스 척도를 사용하면 코드뿐만 아니라 코드를 읽는 사람과 코드 사이의 관계에 대해서도 돌아보는 데 도움이 된다.
  - 파스 척도는 한 가지 질문으로 구성된 상대적으로 간단한 설문을 사용하기 때문에 지난 몇 년간 비판을 받아 왔다.
  - 참가자들이 매우 높은 부하와 그보다 더 높은 부하를 신뢰성 있게 구별할 수 있는지도 불분명다.
- 익숙하지 않은 코드를 선택하고 파스 척도를 사용하여 그 코드를 이해하기 위해 기울여야 했던 인지적 노력에 대해 점수를 매개보라. 그런 다음, 그 코드가 왜 일정량의 인지 부하를 초래했는지 생각해보라. 이 연습은 자신이 어떤 유형의 코드를 읽기 어려워하는지 이해하는 데 도움이 될 수 있다.
  - 파스 척도에서 참가자들은 인지 부하에 대해 스스로 1점에서 9점 사이에서 점수를 매긴다.

#### 눈 기반 측정

- 시선 추적 장치를 이용하면 사람들이 얼마나 집중하고 있는지 알 수 있다.
  - 작업이 어려울수록 깜박임이 줄어든다.
  - 작업이 더 어려울수록 동공 크기도 크게 측정되고 인지 부하도 더 커진다. 동공이 크면 눈이 더 많은 정보를 흡수할 수 있다. 어려운 작업을 할 때 뇌는 더 많은 정보를 찾는다.

#### 피부 기반 측정

- 피부 온도와 땀 흘리는 정도
- 인지 부하를 측정하기 위한 생체 측정 밥법은 멋지게 들릴 수 있겠지만 파스 척도와 상관관계가 있다.

#### 뇌 기반 측정

- fMRI

#### 뇌전도

- 뇌 활동을 측정하는 다른 방법으로는 뇌전도가 있다.
- 기능적 근적외선 분광기(fNIRS) 사용
  - 언어적 부하와 인지 부하의 관계를 더 깊이 이해하기 위해 사용되어 왔다.

#### 기능적 fNIRS와 프로그래밍

- fNIRS 기기를 사용해 뇌 혈류를 측정하면 프로그래밍 중 발생하는 인지 부하를 정량화할 수 있다.

### 9.2.3 언어적 안티패턴 및 인지 부하

- 언어적 안티 패턴은 안구 추적, fNIRS 결과가 유의미 했다.
- 구조적으로 일관적이지 않은 코드를 읽을 때의 인지 부하가 원래 코드를 읽을 때보다 평균적으로 더 증가한다는 통계적 근거를 발견하지 못했다.

### 9.2.4 언어적 안티패턴이 혼란을 일으키는 이유

- 언어적 안티패턴을 많이 가지고 있는 코드는 인지 부하를 더 많이 유발한다.
  - 충돌하는 이름을 읽게 되면 잘못된 정보가 주어져서 혼란을 일으킨다.
  - 잘못된 청킹으로 혼란을 일으킨다.

## 요약

- 긴 메서드 등 코드 스멜은 코드의 구조적 문제를 일으킨다. 코드 스멜이 인지 부하를 높이는 데에는 여러 인지적 이유가 있다. 예를 들어 중복 코드는 코드를 제대호 청킹하기 어렵게 만들고, 긴 매개변수 목록은 작업 기억 공간을 많이 차지한다.
- 생체 인식 센서 등 인지 부하 측정 방법에는 눈 깜박임 비율, 피부 온도 측정 등 다양한 방법이 있다. 자신의 인지 부하를 측저앟려는 경우 일반저긍로 파스 척도는 신뢰할 수 있는 도구다.
- 언저적 안티패턴이란 코드가 실제 수행하는 작업과 맞지 않는 이름을 의미하며, 높은 인지 부하를 초래한다. 이는 우리가 사고할 때 LTM이 돕는 과정에서 잘못된 사실을 발견하기 때문에 일어날 수 있다. 언어적 안티패턴은 실제로 구현되지 않은 코드의 의미를 가정하기 때문에 잘못된 청킹으로 이어질 수 있다.

## 퀴즈퀴즈

- 코드 스멜의 3가지 수준은 무엇일까요?
- 인지 부하에 대한 척도 이름은 무엇일까요?
- 안티패턴이 가장 영향을 많이 미치는 형태는 구조적인가 언어적인가요?

---

## 참고

- [프로그래머의 뇌](http://www.kyobobook.co.kr/product/detailViewKor.laf?ejkGb=KOR&mallGb=KOR&barcode=9791191600650&orderClick=LAG&Kc=)
