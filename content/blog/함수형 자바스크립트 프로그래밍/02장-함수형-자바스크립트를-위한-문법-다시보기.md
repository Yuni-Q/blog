---
title: 02장 함수형 자바스크립트를 위한 문법 다시보기
date: 2023-01-05 20:01:75
category: 함수형 자바스크립트 프로그래밍
tags: []
draft: true
---

## 2.1 객체와 대괄호 다시 보기

### 2.1.1 난해해 보이는 문법들을 확인하는 목적

1. 더 짧은 코드를 위해
2. 추상화의 다양한 기법
3. if를 없애기 위해
4. 특별한 로직을 위해
5. 캐시를 위해
6. 은닉을 위해
7. 함수를 선언하고 참조하기 위해
8. 컨텍스트를 이어주기 위해

### 2.1.2 객체와 key

#### 코드가 실행되지 않는 key 영역

```ts
var obj = { (true ? "a" : "b"): 1};
// Uncaught SyntaxError: Unexpected token '('
```

#### 코드가 실행되는 key 영역

```ts
var obj = {};
obj[true ? 'a' : 'b'] = 1;
```

- 대괄호 사이에는 코드를 실행할 수 있다.

```ts
var obj = { [true ? 'a' : 'b']: 1 };
// Uncaught SyntaxError: Unexpected token '('
```

### 2.1.3 함수나 배열에 달기

- 자바스크립트는 함수도 객체다. 그러므로 함수도 key/value 쌍으로 구성할 수 있다.
- 함수로 선언할 경우 호이스팅에 의해 정상적으로 동작한다.
- 배열도 객체이며 배열도 숫자가 아닌 key를 사용할 수 있다. 단, 숫자가 아닌 key로 할당할 경우 length는 변하지 않는다.
  - length를 쓰면 배열을 절단할수 있다
- 배열에 숫자로 key를 직접 할당해도 push와 동일하게 동작한다. 자동으로 length도 올라간다.
- Array(length) 혹은 arr\[i] = 1과 같은 변칙적인 기법을 사용하지 않을 것을 권한다.
  - 이 코드 자체는 정상적으로 동작하지만 중간이 비워진 배열을 사용할 경우, 특정 메서드가 일관성 없이 동작하기도 한다.
  - arr.push(1)보다 arr\[i] = 1이 성능이 좋다.
  - 배열의 메서드를 사용하지 않고, key로 할당하는 식으로만 사용한다면 Array(length) 같은 기법을 얼마든지 사용해도 괜찮다.
  - 한번에 크기를 늘리면서 undefined들로 채워진 배열을 안전하게 만들고 싶다면 apply를 활용하면 된다(Array(length)에 비해 필요 없는 객체 생성이 있다는 점과 일반 함수를 실행보다 약간 무겁다는 단점이 있다).
- 자바스크립트는 key의 참조, 수정 등에 대한 제약이 없고 유연하다. 자바스크립트는 전체적으로 유연함과 자유로움이라는 일관성을 가진다.

### 2.1.4 delete

- 자바스크립트에서는 기본 객체의 메서드나 프로퍼티도 지울 수 있다.

### 2.1.5 코드가 실행될 수 있는 영역

- 객체의 키를 대괄호로 참조하면, 대괄호 사이에서 코드를 실행할 수 있다.
- 함수를 실행 할 수도 함수를 정의한 후 즉시 실행할 수도 있다.
- 코드의 특정 부분에서 함수를 정의하거나 실행할 수 있다는 이야기는 그 부분을 높은 수준으로 추상화 할 수 있다는 이야기다.

## 2.2 함수 정의 다시 보기

### 2.2.1. 기본 정의

- 함수 선언식
- 함수 표현식

### 2.2.2 호이스팅

- 변수는 선언 단계와 초기화 단계가 구분되어 있다.
- 함수는 선언과 초기화가 동시에 이루어져 실행도 가능하다.

### 2.2.3 호이스팅 활용하기

- return문 아래에 정의한 함수도 실행이 가능하다.
- 호이스팅을 이용해 가독성을 높일 수 있다.

### 2.2.4 괄호 없이 즉시 실행하기

```ts
!(function (a) {
  console.log(a);
})(1);

true &&
  (function (a) {
    console.log(a);
  })(1);

1
  ? (function (a) {
      console.log(a);
    })(1)
  : 5;

0,
  (function (a) {
    console.log(a);
  })(1);

var b = (function (a) {
  console.log(a);
})(1);

function f2() {}
f2(
  (function (a) {
    console.log(a);
  })(1),
);

var f3 = (function c(a) {
  console.log(a);
})(1);

new (function () {
  console.log(1);
})();
```

- 익명 함수는 연산자의 피연산자가 되거나 return 등과 함게 사용해야 선언할 수 있다. 즉시 실행을 실패한 이유는 실행을 잘못한 것이 아니라 선언 자체를 하지 못해서다.
- 함수를 정의할 수 있는 곳이라면 그곳이 어디든 실행도 할 수 있다.
- 코드를 실행할 수 있는 모든 곳에서 모든 종류의 함수를 선언할 수는 없지만, 함수를 선언할 수 있는 모든 영역에서는 익명 함수든 유명 함수든 일반 함수든 메서드든 모두 실행 할 수 있다.

### 2.2.5 new Function이나 eval을 써도 될까요?

- 해당 기법을 대체할 기능이 없다면 그 기법이 느리든 빠르든 써야만 한다.
- 특정 기법이 느리다고 할지라도 개발 생상선이나 로직에 있어 매우 안정적이고 효율적이라면 다른 부분을 보완하는 것으로 해결할 수 있을지 검토해 볼 필요가 있다.
- 어떤 기법이든 좋은 로직이 뒷받침되어야 , 알맞고 효율적으로 사용할 수 있다.

### 2.2.6 간단 버전 문자열 화살표와 new Function 성능

- ES6의 화살표 함수를 직접 만들어 써도 괜찮다.

### 2.2.7 유명(named) 함수

- 재귀를 이용할 때 편하다.
- 유명 함수는 함수가 값으로 사용되는 상황에서 자신을 참조하기 매우 편하다.
- 유명 함수식에서의 함수 이름은 내부 스코프에서만 참조가 가능하고 외부에서는 그 이름을 참조할 수 없고 없애지도 못해서 매우 안전하다.

### 2.2.8 유명 함수를 이용한 재귀

- 함수 실행을 나열함으로써 if나 for 등의 로직을 대체할 수 있다.

### 2.2.9 자바스크립트에서 재귀의 아쉬움

- 아직 자바스크립의 실제 동작 환경에서는 꼬리 재귀 최적화가 되지 않았다.
  - ES6 스펙상에는 꼬리 재귀 최적화가 명시되어 있다.

## 2.3 함수 실행과 인자 그리고 점 다시보기

### 2.3.1 () 다시 보기

- 함수를 실행하는 방법에는 (), call, apply가 있고, 함수 안에서는 arguments 객체와 this 키워드를 사용할 수 있다.

### 2.3.2 인자 다시 보기

- 인자는 일반 변수 혹은 객체와 약간 다르게 동작하는 부분이 있다.

```ts
function test(a, b) {
  b = 10;
  console.log(arguments);
}

test(1); // [1]
test(1, 2); // [1, 10]

function test2(a, b) {
  arguments[1] = 10;
  console.log(arguments);
}

test2(1, 2); // [1, 10]
```

### 2.3.3 this 다시 보기

- this는 어떻게 실행했는지가 중요하다.
- 자바스크립트에서의 함수는 ‘어떻게 선언했느냐’와 ‘어떻게 실행했느냐’가 모두 중요하다.
  - ‘어떻게 정의했느냐’는 클로저와 스코프와 관련된 부분들을 결정하고
  - ‘어떻게 실행했느냐’는 this와 arguments를 결정한다.

### 2.3.4 call, apply 다시 보기

- call과 apply는 동일하게 동작하지만 인자 전달 방식이 다르다.
  - apply의 경우 배열이 아니라 배열 형식으로 치환 될 수 있는 객체나 arguments도 가능하다.

### 2.3.5 call의 실용적 사례

- apply, arguments는 좋은 도구들이며 실제로 매우 실용적이다.

## 2.4 if else || && 삼항 연산자 다시 보기

- 함수를 실행하는 괄호

### 2.4.1 if의 괄호

- 자바스크립트의 모든 괄호에는 표현식만 사용할 수 있다.
- if를 비동기 코드와 사용하기 어렵다.
- 일반 괄호보다 함수 실행의 괄호가 더 많은 일을 할 수 있다.

### 2.4.2 || &&

- if else로 작성된 많은 코드를 ||나 && 등으로 대체할 수 있다.

### 2.4.3 삼항 연산자

- 삼항 연산자를 이용해도 여러 줄 을 코딩할 수 있다.

## 2.5 함수 실행의 괄호

### 2.5.1 함수 실행을 통해 생기는 새로운 공간

- 2.1절에서는 코드가 실행되는 대괄호를, 2.2절에서는 함수를 정의하는 괄호를, 2.3절에서는 함수를 실행하는 괄호를, 2.4절에서는 코드가 실행되는 괄호를 봤다.
- 함수를 실행하는 괄호는 새로운 실행 컨텍스트가 열립니다.
- 개발자가 시작과 끝을 제어할 수 있다는 점들이 함수를 실행하는 괄호가 가진 가장 특별한 차이다.
- 자바스크립트에서 함수가 실행되는 지점과 함수가 끝나는 지점이 갖는 특별한 의미를 알고, 각각의 지점에서 엔진이 하는 특별한 일들에 대해 구체적으로 알고 있으면 아무래도 자바스크립트를 더욱 잘 다룰 수 있을 것이다.
  - 스코프, 실행 컨텍스트, 테스크 큐, 이벤트 루프, 마이크로 테스크에 대해 이해가 필요하다.

### 2.5.2 기본적인 비동기 상황

- 함수를 연속적으로 실행하는 것이 비동기 제어의 핵심이다.

### 2.5.3 함수 실행 괄호의 마법과 비동기

### 2.5.4 비동기와 재귀

- 특정 지점에 함수를 정의하거나 함수로 감싸고, 함수를 즉시 실행하거나 재귀를 하는 식으로 기존 로직 사이에 선행 로직이나 후행 로직을 만들면서 프로그램의 순서를 제어할 수 있음을 보여준다.
- 함수를 실행하는 괄호에서는 이처럼 무언가를 계속 진행 중인 상태로 만들 수 있고, 점진적으로 결과를 만들어 갈 수 있다.
- 재귀는 로직들을 함수라는 단위로 일자로 나열하는 것이다. 비동기 제어의 핵심 역시 함수 실행의 나열이다. 비동기가 발생되면 스택이 초기화되므로 재귀에 대한 부담도 없다.

## 2.6 화살표 함수

### 2.6.1 익명 함수와의 문법 비교

### 2.6.2 익명 함수와의 기능 비교

- 화살표 함수의 최대 매력은 간결함이다.
- 화살표 함수는 부모의 this와 arguments를 가진다.

### 2.6.3 화살표 함수의 실용 사례

### 2.6.4 화살표 함수 재귀

## 2.7 정리

---

## 출처

- [함수형 자바스크립트 프로그래밍](https://product.kyobobook.co.kr/detail/S000001033053)
