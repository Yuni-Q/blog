---
title: 5장 유사한 코드 융합하기
date: 2023-08-06 23:08:56
category: five lines of code
tags: []
draft: true
---

## 이번 장에서 다룰 내용

- 유사 클래스 통합하기
- 조건부 산술로 구조 노출하기
- 간단한 UML 클래스 다이어그램 이해하기
- 전략 패턴의 도입(P5.4.2)으로 유사 코드 통합하기
- 구현체가 하나뿐인 인터페이스 만들지 말 것(R5.4.3)으로 어지러움 정리하기

## 5.1 유사 클래스 통합하기

### 5.1.1 리팩터링 패턴: 유사 클래스 통합

- 일련의 상수 메서드를 공통으로 가진 두 개 이상의 클래스에서 이 일련의 상수 메서드가 클래스에 따라 다른 값을 반환할 때마다 이 리팩터링 패턴을 사용해서 클래스를 통합할 수 있습니다.

#### 절차

1. 첫 번째 단계는 모든 비기준 메서드를 동일하게 만드는 것입니다. 이런 메서드에 각각 다음을 수행합니다.
   1. 각 메서드 버전 본문의 기준 코드 주위에 if(true) {}를 추가합니다.
   2. true를 모든 기본 메서드를 호출하여 그 결과를 상수 값과 비교하는 표현식으로 바꿉니다.
   3. 각 버전의 본문을 복사하고 else와 함께 다른 모든 버전에 붙여 넣습니다.
2. 이제 기준 메서드만 다르므로 두 번째 단계는 기준 메서드에 각 메서드에 대한 필드를 도입하고 생성자에서 상수를 할당하는 것으로 시작합니다.
3. 상수 대신 도입한 필드를 반환하도록 메서드를 변경합니다.
4. 문제가 없는지를 확인하기 위해 컴파일합니다.
5. 각 클래스 대해 한 번에 하나의 필드씩 다음을 수행합니다.
   1. 필드의 기본값을 매개변수로 지정하게 합니다.
   2. 컴파일러 오류를 살펴보고 기본값을 인자로 전달합니다.
6. 모든 클래스가 동일하면 통합한 클래스 중 하나를 제외한 모두를 삭제하고, 삭제하지 않은 클래스로 바꾸어 모든 컴파일러 오류를 수정합니다.

## 5.2 단순한 조건 통합하기

### 4.2.1. 리팩터링 패턴: if 문 결합하기

#### 절차

1. 본문이 실제로 동일한지 확인합니다.
2. 첫 번째 if 문의 닫는 괄호와 else if 문의 여는 괄호 사이의 코드를 선택하고 삭제한 후 ||을 삽입합니다. if 뒤에 여는 괄호를 삽입하고 { 앞에 닫는 괄호를 삽입합니다. 동작을 변경하지 않도록 항상 표현식을 괄호로 묶습니다.
3. 표현식이 단순하면 불필요한 괄호를 제거하거나 편집기에서 이를 수행하도록 설정할 수 있습니다.

## 5.3 복잡한 조건 통합하기

### 5.3.1 조건을 위한 산술 규칙 사용

### 5.3.2 규칙: 순수 조건 사용

- 순수라는 말은 조건에 부수적인 동작이 없음을 의미합니다. 부수적인 동작이란 조건이 변수에 값을 할당하거나 예외를 발생시키거나 출력, 파일 쓰기 등과 같이 I/O와 상호작용하는 것을 의미합니다.
- 명령에서 질의 분리(Separate queries from commands)
  - 명령은 부작용이 있는 모든 것을 의미합니다.
  - 질의는 순수한 것을 의미합니다.
- 데이터를 가저오는 것과 변경하는 것을 분리하여 더 깔끔하고 예측 가능하게 만듭니다. 메서드가 더 간단하기 때문에 일반적으로 더 나은 이름을 지정할 수 있습니다.

### 5.3.3 조건 산술 적용

## 5.4 클래스 간의 코드 통합

### 5.4.1 클래스 관계를 묘사하기 위한 UML 클래스 다이어그램 소개

- UML(Unified Modeling Language)은 코드에 대한 속성을 전달하기 위해 다양한 유형의 표준 다이어그램으로 구성됩니다.
  - 시퀀스 다이어그램, 클래스 다이어그램, 활동 다이어그램
- 클래스 다이어그램은 인터페이스와 클래스의 구조가 서로 어떤 관계가 있는지 보여줍니다. 가장 중요한 부분은 클래스와 인터페이스 간의 관계입니다.
  - X가 Y를 사용한다. X는 Y다. X가 하나 또는 여러 개의 Y를 가진다.
- 전체 프로그램에 대한 클래스 다이어그램을 만든느 것은 순식간에 거대해져서 도움이 되지 않습니다. 주로 디자인 패턴이나 소프트웨어 아키텍터의 작은 부분을 설명하는 데 사용하기 떄문에 중요한 메서드만 포함합니다.

### 5.4.2 리팩터링 패턴: 전략 패턴의 도입

- 전략이 필드를 가지고 있는 경우: 상태 패턴
- 전략 패턴의 변형(variance)은 늦은 바인딩의 궁극적인 형태입니다.
- 두 가지 상황에서 전략 패턴을 도입합니다.
  - 첫째, 코드에 변형을 도입하고 싶어서 리팩터링을 수행하는 경우
  - 둘째, 떨어지는 성질을 코드화했던 상황에서 바로 벼녛ㅇ의 추가가 필요하독 예상하지 않았을 때. 단지 클래스 간의 동작을 통합하려는 경우.

#### 절차

1. 분리하려는 코드에 대해 메서드 추출을 수행합니다. 다른 것과 통합하려면 메서드가 동일한지 확인합니다.
2. 새로운 클래스를 만듭니다.
3. 생성자에서 새로운 클래스를 인스턴스화합니다.
4. 메서드를 새로운 클래스로 옮깁니다.
5. 필드에 종속성이 있을 경우 다음을 수행합니다.
   1. 필드를 새로운 클래스로 옮기고 옮긴 필드에 대한 접근자를 만듭니다.
   2. 새로운 접근자를 사용해서 원래 클래스에서 발생하는 오류를 바로잡습니다.
6. 새로운 클래스의 나머지 오류에 대해 해당 값을 대체할 매개변수를 추가합니다.
7. 메서드의 인라인화(P4.1.7)를 사용해서 1단계의 추출을 반대로 합니다.

### 5.4.3 규칙: 구현체가 하나뿐인 인터페이스를 만들지 말 것

- 구현 클래스가 하나밖에 없는 인터페이스는 가독성에 도움이 되지 않는다는 것입니다. 더 나쁜 것은 인터페이스는 변형을 전제로 하는데, 아무것도 없다면 오히려 가독성을 방해할 수 있다는 점입니다. 또한 구현 클래스를 수정하려는 경우 인터페이스를 수정해야 해서 오버헤드를 발생시킵니다. 이 규칙은 `메서드 전문화(P4.2.2)`와 유사한데, 구현 클래스가 하나만 있는 인터페이스는 도움이 되지 않는 일반화의 한 형태이기 때문입니다.
- 아무런 구현체가 없는 인터페이스를 갖는 것이 합리적인 경우가 있습니다. 가장 일반적으로 비교(comparator)와 같은 항목에 대해 익명 클래슬르 사용하거나 익명의 내부 클래스를 통해 더 염격한 캡슐화를 수행하려는 경우 유용합니다.
- 컴퓨터 과학의 모든 문제는 간접 레이어를 도입함으로써 해결할 수 있습니다. 이것은 인터페이스를 말합니다. 하지만 추상화는 인지된 복잡성의 감소를 위해 실제의 복잡성의 증가를 허용하는 것이기 때문에 추상화에 신중해야 합니다.

### 5.4.4 리팩터링 패턴: 구현에서 인터페이스 추출

#### 절차

1. 추출할 클래스와 동일한 이름으로 새로운 인터페이스를 만듭니다.
2. 인터페이스를 추출할 클래스의 이름을 변경하고 새로운 인터페이스를 구현하게 합니다.
3. 컴파일하고 오류를 검토합니다.
   1. new 때문에 오류가 발생하면 인스턴스화하는 부분을 새로운 클래스의 이름으로 변경합니다.
   2. 그렇지 않으면 오휴를 일으키는 메서드를 인터페이스에 추가합니다.

## 5.5 유사 함수 통합하기

## 5.6 유사한 코드 통합하기
