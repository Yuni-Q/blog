---
title: 6장 데이터 보호
date: 2023-08-15 20:08:21
category: five lines of code
tags: ['01부 컴퓨터 게임 리팩터링에서 배우기']
draft: true
---

## 이번 장에서 다룰 내용

- getter와 setter를 사용하지 말것(R6.1.1)으로 캡슐화 강제하기
- getter와 setter 제거하기(P6.1.3)로 getter 제거
- 공통 접사를 사용하지 말 것(R6.2.1)을 위한 데이터 캡슐화(P6.2.3) 사용
- 순서 강제화(P6.4.1)로 불변속성 제거

## 6.1 getter 없이 캡슐화하기

### 6.1.1 규칙: getter와 setter를 사용하지 말 것

- Boolean이 아닌 필드에 getter와 setter를 사용하지 마십시오.
- getter가 존재하는 순간 캡슐화를 해제하고 불변속성을 전역적으로 만들게 됩니다. 이는 우리가 제어할 수 없게 되고 예상하지 못한 방시긍로 객체를 수정할 수 있습니다.
- 피해야하는 밀 결합(tight coupling)의 형태가 생깁니다.
  - setter를 통한 새로운 뎅터 구조를 반환하도록 getter를 수정하고 수신자 측에서 이 새로운 데이터 구조를 받을 수 있도록 수정해야합니다.
- 필드를 비공개로 하는 것의 가장 큰 장점은 그렇게 하는 것이 푸시 기반(push-based)의 아키텍처를 장려하기 때문입니다.

#### 풀 기반 아키텍처

- 풀 기반(pull based)의 아키텍처에서는 데이터를 가져와 중앙에서 연산을 수행합니다.
- 이 접근 방식은 데이터와 관리자 사이, 그리고 암묵적인 데이터 클래스 간에도 밀 결합을 가져옵니다.

#### 푸시 기반 아키텍처

- 푸시 기반 아키텍처에서는 가능한 한 데이터에 가깝게 연산을 이관합니다.
- 푸시 기반 아키텍처에서는 데이터를 가져오는 대신 인자로 데이터를 전달합니다. 결과저긍로 모든 클래스가 자신의 기능을 가지고 있으며 코드는 그 효용에 따라 분산됩니다.
- 디미터의 법칙을 지킬 수 있습니다.
  - 디미터의 법칙: 낯선 사람에게 말하지 말라.
- 푸시 기반의 아키텍처에서는 내부 구조에 대해 신경 쓰지 않아도 됩니다.

### 6.1.2 규칙 적용하기

### 6.1.3 리팩터링 패턴: getter와 setter 제거하기

- 기능을 데이터에 더 가깝게 이동하여 getter와 setter 제거할 수 있습니다.
- 일반적으로 getter 대신 유사한 함수들을 많이 도입하게 됩니다. 메서드가 ㅁ낳단느 것은 데이터 컨텍스트 대신 특정 호출 컨텍스트를 기준으로 이름을 지정할 수 있다는 의미입니다.

#### 절차

1. getter 또는 setter가 사용되는 모든 곳에서 오류가 발생하도록 비공개로 설정합니다.
2. `클래스로의 코드 이관`으로 오류를 수정합니다.
3. getter 또는 setter는 `클래스로 코드 이관`의 일부로 인라인화합니다. 따라서 사용하지 않으므로 삭제해서 다른 사람이 사용하지 않게 합니다.

### 6.1.4 마지막 getter 제거

## 6.2 간단한 데이터 캡슐화하기

### 6.2.1 규칙: 공통 접사를 사용하지 말 것

- 코드에는 공통 접두사나 접미사가 있는 메서드나 변수가 없어야 합니다.
- 클래스를 사용해서 메서드와 변수를 그룹화하면 외부 인터페이스를 완전하게 제어할 수 있습니다. 도우미 메서드를 숨겨 전역 범위를 오염시키지 않을 수 있습니다.
- 단일 책임 원칙을 준수하게 됩니다.
  - 단일 책임 원칙: 메섣는 한 가지 작업만 해야 한다.

### 6.2.2 규칙 적용하기

- 변수와 메서드를 클래스로 옮기는 이 과정을 `데이터 캡슐화`라고 합니다.

### 6.2.3 리팩터링 패턴: 데이터 캡슐화

- 변수와 메서들르 캡슐화해서 접근할 수 있는 지점을 제한하고 구조를 명확하게 만들 수 있습니다.
- 메서드를 캡슐화하면 이름을 단순하게 만들고 응집력을 명확하게 하는 데 도움이 됩니다.
- 범위를 제한하면 클래스 내의 메서드만 데이터를 수정할 수 있으므로 이런 메서드들만 그 속성에 영향을 줄 수 있게 됩니다. 불변속성을 검증해야 할 경우 클래스 내부의 코드만 확인하면 됩니다.

#### 절차

1. 클래스를 만듭니다.
2. 변수를 새로운 클래스로 이동하고 let을 private으로 바꿉니다. 변수의 이름을 단순한 것으로 정하고 변수에 대한 getter와 setter를 만듭니다.
3. 변수가 더 이상 전역 범위에 없기 때문에 컴파일러가 오류를 발생시켜 모든 참조를 찾을 수 있게 해줍니다. 다음은 다섯절차를 통해 오류들을 수정합니다.
   1. 새 클래스이 인스턴스에 적합한 변수 이름을 선택합니다.
   2. 접근을 가상의 변수에 대한 getter 또는 setter로 바꿉니다.
   3. 2개 이상의 다른 메서드에서 오류가 발생한 경우 이전의 변수명을 가진 매개변수를 첫 번째 매개변수로 추가하고 동일한 변수를 첫 번째 인자로 호출하는 쪽에 넣습니다.
   4. 한 메서드에서만 오류가 발생할 때까지 반복합니다.
   5. 변수를 캡슐화했다면 변수가 선언된 지점에서 새로운 클래스를 인스턴스화합니다. 그렇지 않으면 오류가 발생한 메서드에 인스턴스화하는 부분을 만듭니다.

## 6.3 복잡한 데이터 캡슐화

## 6.4 순서에 존재하는 불변속성 제거하기

- 무언가가 다른 것ㅂ돠 먼저 호출되어야 할 때, 그것을 `순서 불변속성(sequence invariant)`이라고 합니다.

### 6.4.1 리팩터링 패턴: 순서 강제화

- 객체지향 언어에서는 생성자가 항상 객체의 메서드보다 먼저 호출되어야 합니다. 우리는 이 속성을 활용해서 작업이 특정 순서로 발생하게 할 수 있습니다.

#### 절차

1. 마지막으로 실행되어야 하는 메서드에 데이터 캡슐화를 적용합니다.
2. 생성자가 첫 번째 메서드를 호출하도록 합니다.
3. 두 메서드의 인자가 연결되어 있으면 이러한 인자를 필드로 만들고 메서드에서 제거합니다.

## 6.5 열거형을 제거하는 또 다른 방법

### 6.5.1 비공개 생성자를 통한 열거

### 6.5.2 수자를 클래스에 다시 매핑하기

## 요약

- 캡슐화를 시행하려면 데이터의 노출을 피해야 합니다. getter와 setter를 사용하지 말 것(R6.1.1) 규칙은 getter와 setter를 통해 간접적으로 비공개 필드를 노출해서는 안 된다는 의미입니다. getter와 setter 제거하기(P6.1.3) 리팩터링 패턴을 사용해서 getter와 setter를 제거할 수 있습니다.
- 공통 접사를 사용하지 말 것(R6.2.1) 규칙에 따르면 공통 접두사 또는 접미사가 있는 메서드와 변수가 있을 경우 한 클래스에 함께 있어야 합니다. 이를 위해 데이터 캡슐화(P6.2.3) 리팩터링 패턴을 사용할 수 있습니다.
- 클래스를 이용한 순서 강제화(P6.4.1) 리팩터링 패턴을 사용하면 컴파일러가 실행 순서를 강제할 수 있도록 해서 순서 불변성을 제거할 수 있습니다. 열거형을 처리하는 또 다른 방법은 비공개 생성자가 있는 클래스를 사용하는 것입니다. 그러면 열거형과 스위치 문을 추가적으로 제거할 수 있습니다.

## 1부를 마치며 좋은 아키텍처가 된 이유

1. 확장하는 것이 훨씬 빠르고 안전합니다.
2. 관련 변수와 기능이 가독성이 좋은 이름을 가진 클래스와 메서드로 그룹화되어 있기 때문에 코드의 의미를 훨씬 쉽게 파악할 수 있습니다.
3. 이제 데이터 범위를 훨씬 더 세분화해서 제어할 수 있습니다. 따라서 2장에서 논의한 것처럼 대부분 버그 원인인, 로컬이 아닌 불변속성을 깨드리는 프로그램을 작성하기가 어려워졌습니다.

---

- [파이브 라인스 오브 코드](https://product.kyobobook.co.kr/detail/S000200661796)
