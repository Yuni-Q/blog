---
title: 프로토타입 기반의 객체지향
date: 2020-01-17 09:01:35
category: javascript
draft: false
---

- 프로토타입 기반 프로그래밍은 객체지향 프로그래밍의 한 형태의 갈래로 클래스가 없고, 클래스 기반 언어에서 상속을 사용하는 것과는 다르게, 객체를 원형(프로토타입)으로 하여 복제의 과정을 통하여 객체의 동작 방식을 다시 사용할 수 있습니다.
- 프로토 타입 역할을 하는 delegation을 통해 기존 객체를 재사용하는 프로세스를 통해 동작 재사용(상속)을 수행 하는 객체 지향 프로그래밍 스타일입니다. 프로토 타입 기반 프로그래밍은 일반화 된 객체를 사용하여 복제 및 확장 할 수 있습니다.
- 프로토타입기반 프로그래밍은 클래스리스(class-less), 프로토타입 지향(prototype-oriented) 혹은 인스턴스 기반(instance-based) 프로그래밍이라고도 한다. delegation은 프로토 타입 기반 프로그래밍을 지원하는 언어 기능입니다.
- 프로토 타입 객체를 만든 다음 새로운 인스턴스를 만듭니다. 객체는 JavaScript로 변경할 수 있으므로 새로운 인스턴스를 확장하여 새로운 필드와 메소드를 제공 할 수 있습니다. 그러면 더 새로운 0 - 객체의 프로토 타입 역할을 할 수 있습니다. 비슷한 객체를 많이 만들기 위해 클래스가 필요하지 않습니다.
- 많은 프로토 타입 기반 시스템은 런타임 동안 프로토 타입의 변경을 권장하는 반면, 클래스 기반 객체 지향 시스템은 매우 적습니다.
- 거의 모든 프로토 타입 기반 시스템은 해석되고 동적으로 유형이 지정된 언어를 기반 으로 합니다. 그러나 정적으로 형식화 된 언어를 기반으로하는 시스템은 기술적으로 가능합니다.
- 프로토타입 기반 언어의 가장 원조격인 프로그래밍 언어인 셀프는 데이비드 엉거와 랜덜 스미스가 개발했습니다.

## 객체의 구성

- 프로토 타입 기반 언어에는 명시적 클래스가 없습니다. 객체는 프로토 타입 속성을 통해 다른 객체로부터 직접 상속됩니다.
- 새로운 객체를 구성하는 방법은 객체 생성 또는 기존 객체 복제를 통한 방법 2가지 입니다.

> 객체 생성은 기존의 프로토 타입에서 복제하지 않고 처음부터 생성 할 수 있습니다. 이러한 시스템은 기존 객체를 참조하지 않고 새 객체의 속성과 동작을 지정하기 위한 특수 구문을 제공합니다. 많은 프로토 타입 언어에는 종종 Object 라고하는 루트 객체가 있습니다. 루트 객체는 런타임에 생성 된 다른 모든 객체의 기본 프로토 타입으로 설정되며 객체에 대한 설명을 반환하는 toString()함수와 같이 일반적으로 필요한 메소드를 전달 합니다. 객체 생성의 유용한 측면 중 하나는 새 객체의 슬롯 (속성 및 메서드) 이름에 네임 스페이스가 없는 것입니다.

> 복제는 기존 객체 (시제품)의 동작을 복사하여 새 객체를 구성하는 프로세스를 말합니다. 그런 다음 새 객체는 원본의 모든 자질을 전달합니다. 이제부터 새 개체를 수정할 수 있습니다. 일부 시스템에서 결과로 생성 된 자식 개체 는 프로토 타입에 대한 명시적 링크 ( 위임 또는 유사성을 통해 )를 유지하며 프로토 타입의 변경으로 인해 해당 변경 사항이 복제본에 나타납니다.

> 클래스기반 언어에서, 클래스의 생성자를 통하거나 필요하다면 생성자와 생성자의 매개변수를 통하여 인스턴스를 새로 만든다. 결과로 만들어진 인스턴스는 선택된 클래스의 설계와 행동을 따르게 된다.

## Delegation

- 실행시간에 ‘위임’하는 프로토타입기반의 언어들은 올바른 메서드로 동적 디스패치를 할 수 있거나, 맞는 자료 조각에 이를 때까지 객체에서 프로토타입으로 간단히 위임 포인터를 연속적으로 따라가서 찾을 수 있습니다.
- 객체들 사이에서 동작을 공유하는 것을 확립하기 위해 필요한 것들은 위임 포인터뿐입니다. 클래스기반 객체지향 언어에서 클래스와 인스턴스의 관계와 달리 프로토타입과 파생된 객체는 이 연결을 통하여 프로토타입과 자식 객체가 메모리나 구조적인 유사성을 가질 필요가 없습니다.
- 마찬가지로, 자식 객체는 클래스 기반의 연관된 클래스의 구조를 재배치하지 않고 계속해서 수정할 수 있습니다.
- 또 중요한 점은, 자료뿐만 아니라 메서드도 추가되거나 변경될 수 있다는 것입니다. 이런 이유로 대부분의 프로토타입기반 언어들은 자료와 메서드 두가지 모두 슬롯으로 관리합니다.

## Concatenation

- Kevo 프로그래밍 언어로 구현 된 접근 방식 인 연결 프로토 타입 에서는 개체가 복제 된 원본 프로토 타입에 대한 포인터나 링크가 보이지 않습니다. 프로토 타입 (부모) 개체는 연결되지 않고 복사 되며 위임이 없습니다. 결과적으로 프로토 타입의 변경 사항은 복제 된 객체에 반영되지 않습니다.
- 이 배열의 주요 개념 차이는 프로토 타입 객체의 변경 사항이 복제본에 자동으로 전파되지 않는다는 것입니다. 이것은 장단점으로 볼 수 있습니다. 그러나 Kevo는 유사성 (소위 패밀리 셈 블랑 또는 복제 패밀리 메커니즘 )을 기반으로 객체 세트간에 변경 사항을 게시하기위한 추가 기본 요소를 제공합니다. 위임 모델에서 일반적인 것처럼 분류 학적 기원을 통하지 않고.) 또한 위임 기반 프로토 타이핑은 하위 개체의 변경이 나중에 부모의 작업에 영향을 줄 수 있다는 추가적인 단점이 있다고 주장합니다. 그러나이 문제는 위임 기반 모델에 내재 된 것이 아니며 JavaScript와 같은 위임 기반 언어에는 존재하지 않으므로 자식 개체에 대한 변경 내용이 항상 자식 개체 자체에 기록되고 부모 개체에는 절대로 기록되지 않습니다. 값은 부모 값을 변경하지 않고 부모 값을 어둡게합니다.
- 간단한 구현에서 연결 프로토 타입은 위임 기반 프로토 타입보다 빠른 멤버 조회를 갖지만 (부모 오브젝트 체인을 따를 필요가 없기 때문에) 더 많은 메모리를 사용합니다 (단일 슬롯이 아닌 모든 슬롯이 복사되기 때문에) 부모 객체를 가리키는 슬롯). 그러나 속도와 메모리 간의 절충이 필요하지만보다 복잡한 구현은 이러한 문제를 피할 수 있습니다. 예를 들어, 연결 프로토 타이핑이있는 시스템은 COW ( Copy-On-Write) 구현을 사용하여 무대 뒤에서 데이터를 공유 할 수 있습니다. 이러한 접근 방식에는 Kevo가 뒤 따릅니다.

## 클래스 기반과의 비교

- 클래스기반 언어에서 객체는 일반적으로 두 가지 형태가 있다. ‘클래스’는 객체의 기본적인 만듦새와 기능을 정의하고, ‘인스턴스’는 “사용할 수 있는” 객체로 특정 클래스의 양식을 기반으로 합니다. 클래스기반 언어에서 ‘클래스’는 동작 방식인 메소드의 모임으로 동작하고, 모든 인스턴스의 구조는 동일하고, 인스턴스는 객체의 자료를 가지고 있습니다. 한쪽에는 구조와 동작 방식, 다른 한쪽에는 상태로 구분됩니다.
- 프로토타입 기반 프로그래밍을 지지하는 사람들은 클래스기반 언어에서는 개발자가 클래스들 사이의 분류와 관계에 먼저 초점을 맞추기 쉽다고 합니다. 이와는 달리, 프로토타입기반 프로그래밍은 프로그래머가 여러 가지 표본의 동작 방식에 초점을 맞추고, 이 객체들을 나중에 클래스와 비슷한 방식의 “객체의 원형”으로 분류하는 것은 나중에 걱정해도 됩니다. 많은 프로토타입기반 체계가 실행시간에 프로토타입을 대체하기 쉬우나, 클래스기반 객체지향 체계에서는 최초의 동적 객체지향 체계인 스몰토크와 같이 프로그램의 실행 중에 클래스를 바꿀 수 있는 것은 몇 가지 되지 않습니다.
- 프로토타입 기반 프로그래밍은, 학습의 과정의 주요한 특징으로 프로토타입이나 이그젬플러를 강조하는, 인지 심리학과 같은 특정 학문과 관련되어 있는 경우가 많습니다.
- 프로토타입 기반 체계의 대부분은 인터프리터이고 동적 타입 프로그래밍 언어입니다. 하지만 프로토타입기반의 정적 타입의 체계가 기술적으로 가능합니다.

## 참조

- [Prototype-based programming](https://en.wikipedia.org/wiki/Prototype-based_programming)
- [프로토타입 기반 프로그래밍](https://ko.wikipedia.org/wiki/%ED%94%84%EB%A1%9C%ED%86%A0%ED%83%80%EC%9E%85_%EA%B8%B0%EB%B0%98_%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D)
- [객체 지향 언어의 두 가지 줄기](http://mohwa.github.io/blog/javascript/2015/10/16/prototype/http://mohwa.github.io/blog/javascript/2015/10/16/prototype/)
