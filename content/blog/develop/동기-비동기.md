---
title: 동기 비동기
date: 2020-02-24 12:02:21
category: develop
draft: false
---

## SYNC / ASYNC

- - 중요한 포인트는 `순서와 결과(처리)ㅡ이 관점 `입니다.
- return 한다면 SYNC, callback으로 응답한다면 ASYNC 입니다.
- Synchronous / Asynchronous는 호출되는 함수의 작업 완료 여부를 누가 신경쓰냐가 관심사 입니다.
- SYNC : 서브루틴이 즉시 값을 반환 합니다.
  - 이벤트를 자신이 직접 처리 합니다.(확인의 주체가 유저 프로세스이며, 다 될때까지 기다리거나 스스로 확인 합니다.)
  - Synchronous I/O : 작업을 요청한 후 작업의 결과가 나올 때까지 기다린 후 처리 합니다.(프로세스는 커널에 지속적으로 I/O 준비사항을 체크 합니다.)
- ASYNC : 서브루틴이 콜백을 통해 값을 반환 합니다.
  - 이벤트 핸들러 (callback)에 의해 처리 합니다.(callback 함수가 호출되기까지 다른 작업 가능 합니다.)
  - Asynchronous I/O : 직전 시스템 호출의 종료가 발생하면 그에 따른 처리를 진행 합니다.

## BLOCK / NON BLOCK

- 중요한 포인트는 `제어권 `입니다.
- 주도권을 넘기면 BLOCK, 주도권을 넘지지 않으면 NON BLOCK 입니다.
- Blocking/NonBlocking은 호출되는 함수가 바로 리턴하느냐 마느냐가 관심사 입니다.
- block : 완료까지 대기(리턴되기 전까지 멈춤) 합니다.
  - Blocking I/O : 유저 프로세스가 시스템 호출을 하고나서 결과가 반환되기까지 다음 처리로 넘어가지 않습니다.
- non-block : 미완료라도 즉시 리턴 합니다.
  - Non-Blocking I/O : 호출한 직후에 프로그램으로 제어가 돌아와서 시스템 호출의 종료를 기다리지 않고 다음 처리로 넘어갈 수 있습니다.

## SYNC BLOCK

- 즉시 플로우제어권을 반환하지 않습니다.
- normalAPI, legacyAPI
- 일반적인 생각하는 프로그램 동작입니다.

## SYNC NON BLOCK

- 즉시 플로우 제어권을 반화합니다.
- oldAPI, IOCP, Future, complete, 정보 로딩 정도를 보여줄 때 사용합니다.
- event loop처럼 쓰레드가 묶여 있지 않고 그 동안 다른 작업을 하다가 callback이 오면 다시 플로우를 진행합니다.

## ASYNC BLOCK

- 즉시 플로우 제어권을 반환하지 않습니다.
- TRAP

## ASYNC NON BLOCK

- 즉시 플로우 제어권을 반환 합니다.
- modernAPI
- ASYNC 함수를 부르고 다른 일을 하지 않고 작업을 계속 진행합니다.

## 카페에서 커피를 주문할 경우

- 1-1. 커피를 타달라는 요청이 왔다.
- 2-1. 이 때 커피가 있으면 타준다(블로킹/넌블로킹 모두)
- 2-2. 커피가 없는 경우 블로킹 : '잠깐만요'하고 사러 간다. / 넌블로킹 : 커피가 없다고 말하고 사러 간다.
- 3-1. 동기 : 커피가 타졌는지 안타졌는지 내가 확인한다.
- 3-2. 비동기 : 벨이 울리면 받으러 간다.

## 직렬(Serial) 처리 / 동시(cocurrent) 처리

- 직렬 처리 : 다른 한개의 쓰레드에서. (보통 메인에서) 분산처리 시킨 작업을 다른 한개의 쓰레드에서 처리 합니다.
- 동시 처리 : 다른 여러개의 쓰레드에서. (보통 메인에서) 분산처리 시킨 작업을 다른 여러개의 쓰레드에서 처리 합니다.
- 분선처리 하려는 것이라면 무조건 동시처리가 좋아보이는데 직렬 처리하는 이유는 작업의 순서가 필요할 수도 있기 때문입니다.
- 직렬 처리는 순서가 중요한 작업을 처리할때 사용합니다.
- 동시 처리는 각자 독립적이지만 중요도나 작업의 성격등 유사한 여러개의 작업을 처리할 때 사용합니다.
