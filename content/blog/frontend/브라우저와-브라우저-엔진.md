---
title: 브라우저와 브라우저 엔진
date: 2021-01-05 00:01:91
category: frontend
tags: []
draft: true
---

## 웹 브라우저

- HTML, CSS, Javascript, WASM에 이르는 다양한 언어를 해석
- 해석한 결과를 바탕으로 렌더링
- 쉽게 사용하지만 생각보다 많은 영역을 수행해주는 애플리케이션

## 웹 브라우저 종류

- Chrome(Google)
- Safari(Apple)
- Edge(MS)
- Firefox(Mozilla)
- Opera(Opera software)
- Internet Explorer(MS)

- Whale browser(NAVER)
- Brave browser(Brave)
- Samsung Internet(Sansung)

## 웹 브라우저 구성

- 사용자 인터페이스(UI) 레이어 : 브라우저에서 볼 수 있는 거의 모든 것으로, 요청한 페이지를 보여주는 창 외의 모든 UI를 의미합니다. 주소창, 뒤로가기, 앞으로 가기, 새로고침, 북마크, 환경설정과 같은 UI가 있습니다.
- 브라우저 엔진 : 사용자 인터페이스와 렌더링 엔진 사이에서 중재자 역할을 합니다. 만약 여러분들이 사용자 인터페이스 레이어에 있는 새로고침 버튼을 눌렀다면, 브라우저 엔진은 이를 이해하고 새로고침 명령을 수행합니다.
- 렌더링 엔진 : HTML과 CSS, JavaScript를 파싱하고 그 결과물을 바탕으로 페이지를 그려내는 역할을 합니다.
  - 각 브라우저는 다양한 엔진을 사용하는데, Chrome과 Opera, Edge는 Blink를, Firefox는 Gecko를, Internet Explorer는 Trident를, Safari는 WebKit을 사용합니다.
- 네트워크 레이어 : HTTP나 HTTPS 같은 프로토콜을 이용해 외부의 리소스를 얻어오고, 서버에 요청을 보낼 때 사용되는 레이어입니다.
- JavaScript 인터프리터 : JavaScript를 해석하고 실행하는 역할을 합니다. 가장 유명한 엔진으로 Chrome에 탑재된 구글의 V8이 있습니다.
- UI 백엔드 : 브라우저가 동작하고 있는 운영체제의 인터페이스를 따르는 UI들을 처리합니다. 얼럿(alert)이나 셀렉트 박스(select)가 운영체제 별로 다르게 동작하는 것을 쉽게 확인할 수 있죠.
- 자료 저장소 : 브라우저 자체에서 하드디스크와 같이 데이터를 로컬에 저장하기 위한 레이어로, 쿠키나 로컬 스토리지, 세션 스토리지, indexedDB, 웹 SQL, 파일시스템 등에 접근하고 데이터를 저장하는데 사용됩니다.

## 브라우저 엔진

- 브라우저가 동작하는 데 필요한 기반 기술을 모두 포함하는 엔진
- 브라우저 엔진에 따라서 동작 방식이 거의 유사하다.

### 브라우저 엔진의 종류

- Blink Engine(Chrome, Opera, Samsung Internet, MS Edge, Whale, Brave)
- Webkit Engine(Safari)
- Servo Engine(Firefox), Fecko Engine(Firefox)

### iOS

- 모든 브라우저가 Webkit 기반
- Safari 브라우저에 스킨 씌우는 정도

## 렌더링 엔진의 동작 과정

### 중요 렌더링 경로(Critical Rendering Path)

- 각 단계에서 리소스를 로드하는 순서나 작성한 스크립트의 내용에 따라 웹 페이지의 반응 속도가 달라질 수 있습니다.

1. 파싱(Parsing)
2. 렌더 트리(Render Tree) 구축
3. 레이아웃(Layout) 또는 리플로우(Reflow)
4. 페인트(Paint)

## 파싱

- 파싱(Parsing)은 토큰화(tokenize)된 코드를 구조화하는 과정을 말합니다. 이러한 파싱 과정을 전문적으로 해주는 부분을 파서(Parser)라고 부릅니다.
- 파싱 과정은 입력받은 문자열이 정해진 문법(grammar)들을 모두 따르는지를 확인하는 과정입니다.
- 브라우저는 HTML, CSS, JavaScript 세 종류의 언어를 해석할 수 있습니다. 그 중에서 JavaScript는 렌더링 엔진 레이어가 아니라 JavaScript 해석기라는 별도의 레이어에서 언어를 해석합니다. 따라서 렌더링 엔진에서는 HTML과 CSS를 파싱합니다.

### HTML 파싱

- 브라우저는 토큰화된 HTML의 문자열들을 이용해 파스 트리(Parse Tree)를 생성합니다. 파스 트리는 브라우저가 읽어야 할 HTML 코드를 트리 모양으로 구조화하여 나타낸 것입니다.
- 브라우저는 파스 트리를 이용해 DOM(Document Object Model) 트리를 새로 만듭니다.
- 파스 트리는 토큰화된 문자열을 단순하게 구조화한 트리에 불과했지만, `DOM 트리는 우리가 실제로 상호작용할 수 있는 HTML 엘리먼트로 이루어진 트리`입니다. 따라서 우리가 실제로 JavaScript로 상호작용할 수 있는 부분은 DOM 트리입니다.

#### HTML 파서의 특징

- HTML 파서는 다른 파서와 비교했을 때 조금 독특한 특징을 갖고 있습니다. HTML 파서의 첫 번째 특징은 `오류에 너그러운(forgiving nature) 속성`입니다.
  - HTML을 파싱하는 도중 어떠한 에러가 발생한다면, 브라우저는 자체적으로 에러를 복구하려 합니다.
  - 대부분의 프로그래밍 언어가 촘스키 계층의 문맥 자유 문법(Context-free grammar)에 속하는 것에 반해, HTML은 자체의 특징 때문에 위 계층에 속하지 않습니다.
- HTML 파서의 두 번째 특징는 `파싱 과정이 중단`될 수 있다는 것입니다. HTML은 파싱 도중 \<script>, \<link> 같은 외부 태그를 만나게 되면 HTML 파싱을 즉시 중단합니다. 그리고 해당 태그의 해석을 실행합니다. 만약 해당 태그가 외부 파일을 참조하고 있다면 다운로드를 한 후 해석을 시작합니다. 이는 네트워크를 통해 먼저 받아온 코드부터 해석을 실행할 수 있는 HTML과는 달리 외부 컨텐츠들은 증분적(Incrementally)으로 해석을 할 수 없기 때문입니다. 또 다른 이유는 \<script>에 DOM을 직접 수정할 수 있는 내용이 있을 수도 있기 때문입니다. 가령 document.write() 같은 API를 사용하면 HTML을 파싱하고 있는 도중에도 DOM 엘리먼트를 동적으로 삽입할 수 있습니다. 이로 인해 외부 컨텐츠를 해석하고 실행하기까지 HTML의 파싱은 중단됩니다.
  - 이러한 문제점을 해결하기 위해서 스크립트 같은 경우에는 별도의 옵션을 제공합니다. 스크립트의 실행 시점을 조절하는 Async와 Defer 속성이 있습니다.
- HTML 파서의 세 번째 특징은 `재시작(Reentrant)`입니다. HTML의 파싱 과정은 어떠한 외부의 요인으로 인해 방해받을 수 있습니다. 파싱 중간에 외부의 요인으로 인해 DOM이 추가, 변경, 삭제 될 수 있습니다. 이러한 경우에 HTML은 처음부터 다시 파싱 과정을 거칩니다. 즉, 바이트를 문자로 변환하고, 토큰을 식별한 후 노드로 변환하고 DOM 트리를 빌드합니다. 이 때문에 처리해야 할 HTML이 많을 때에는 파싱 시간이 오래 걸릴 수 있습니다.

### CSS 파싱

- CSS 파싱은 공식적인 명세가 있기 때문에, 파싱 과정이 HTML에 비해 그렇게 복잡하지는 않습니다.
- 일반적으로 CSS을 링크하는 코드가 HTML 코드 내에 삽입되어 있기 때문에, HTML을 파싱하는 도중에 CSS 파싱이 시작됩니다. 네트워크를 통해 먼저 받아온 코드부터 해석을 실행할 수 있는 HTML 파서와는 달리, CSS 파서는 `전체 파일을 모두 다운로드할 때까지 파싱을 시작할 수 없습니다`.
- 전체 CSS 파일을 다운로드 한 후 CSS 파싱 과정이 끝나게 되면, 코드에서 명세한 내용과 순서를 바탕으로 DOM과 같은 트리를 구성하는데 이를 `CSSOM(CSS Object Model) 트리`라 부릅니다. 이 트리에는 스타일, 규칙, 선택자 등의 정보가 노드에 들어가게 됩니다.

### 렌더 트리

- DOM 트리가 구성되는 동안 브라우저는 렌더 트리(Render Tree)를 구성하기 시작합니다. 동의어로는 `프레임 트리(Frame Tree)`라고도 합니다.
- 렌더 트리는 기본적으로 `화면에 나타나는 요소들을 결정하는 트리`입니다. 즉, 어떠한 요소들이 보여야 하는지, 어떤 스타일이 적용되어야 하는지, 그리고 어떤 순서로 나타낼 것인지를 명세하는 트리입니다
- 렌더 트리는 DOM 트리와 CSSOM 트리를 조합하여 만들어지고, 이 때 화면에 그려지지 않는 요소들은 트리에 나타나지 않습니다. 가령 \<head>, \<script> 같은 태그나 display: none 스타일이 적용된 엘리먼트가 있겠죠. 이러한 태그는 시각적으로 나타낼 것이 없기 때문에 렌더 트리에 그려지지 않습니다. 즉 `렌더 트리는 DOM 트리와 정확하게 1:1로 매칭이 되지는 않습니다`.

### 레이아웃 또는 리플로우

- 렌더 트리 구성이 끝나면 레이아웃 단계가 이어집니다. 모질라에서는 이 과정을 리플로우(reflow)라고 부르기도 합니다.
- 레이아웃 단계에서는 렌더 트리에서 계산되지 않았던 노드들의 크기와 위치, 레이어 간 순서와 같은 정보를 계산하여 좌표에 나타냅니다. 이 과정은 HTML의 루트 오브젝트로부터 재귀적으로 실행이 됩니다.
- 레이아웃은 계산의 범위에 따라 `전역적 레이아웃(Global Layout)`과 `증분적 레이아웃(Incremental Layout)`으로 구분할 수 있습니다.
  - 전역적 레이아웃은 말 그대로 화면 전체의 레이아웃을 계산하는 것입니다. 가령 새로운 폰트를 적용하거나, 폰트 사이즈가 바뀌거나, 뷰포트의 사이즈 변경 같은 경우가 있을 때 전체 레이아웃을 다시 계산합니다. offsetHeight 같은 일부 DOM 관련 JavaScript API에 접근을 하는 경우에도 전역적 레이아웃이 다시 계산되기도 합니다. 이러한 전역적 레이아웃 단계는 모든 렌더 트리 노드에 대해 기하학적인 계산을 수행하기 때문에, 노드가 많아지게 된다면 그 속도가 느려지게 됩니다. 따라서 브라우저에서는 자체적인 최적화 로직을 탑재하고 있습니다. 그 중 하나가 바로 `더티 비트 시스템(Dirty bit system)`입니다. 더티 비트 시스템은 특정 엘리먼트의 레이아웃이 변경이 되었을 때, 렌더 트리를 처음부터 탐색하면서 레이아웃을 계산하지 않고 특정한 부분만 다시 계산하여 리소스의 낭비를 줄이는 최적화 방법입니다.
  - 증분적 레이아웃은 이러한 더티 비트 시스템을 활용합니다. 레이아웃 과정에서 렌더 트리를 재귀적으로 탐색을 하다가 더티한 엘리먼트들, 즉 레이아웃의 변경이 발생해야 하는 엘리먼트들을 만나게 되면, 그 `계산을 즉시 수행하는 것이 아니라 스케쥴러를 통해 비동기로 일괄 작업(batch)을 진행`합니다. 이를 통해 연산의 횟수와 범위를 줄일 수 있습니다.
  - 아주 복잡한 레이아웃의 경우에는 브라우저 단에서의 최적화만으로는 충분하지 않기 때문에, 프론트엔드 개발자 역시 레이아웃 과정의 연산을 최소화하도록 신경을 써야 합니다. 때문에 브라우저처럼 행동하는 것이 필요합니다. DOM의 레이아웃과 관련된 값을 직접 읽어오거나 변화를 주는 JavaScript 코드를 작성해야 한다면, 그러한 구문들을 최대한 묶어야 합니다.

### 페인트

- 페인트 단계는 말 그대로 레이아웃 단계를 통해 화면에 배치된 엘리먼트들에게 색을 입히고 레이어의 위치를 결정하는 단계입니다. 이 단계 역시 루트 오브젝트로부터 재귀적으로 실행이 됩니다. 또한 레이아웃과 마찬가지로 페인팅에도 `전역적 페인팅`과 `증분적 페인팅`이 있습니다.
- 페인팅에는 그 순서가 있는데, 이는 z-index 축을 이용한 `쌓임 맥락(Stacking context)`과도 일맥상통합니다. 때문에 z-index가 낮은 순서대로 먼저 페인팅이 됩니다.
- 블록 단위에서의 페인팅 순서는 CSS 페인팅 명세에 따르면 다음과 같습니다.
  - background-color
  - background-image
  - border
  - children
  - outline

### 가상 DOM

- 일반적으로 중요 렌더링 경로는 `초당 60회 정도의 주기로 계산을 수행`합니다. 이때 가장 비용이 많이 드는 단계가 바로 `레이아웃 단계와 페인트 단계`입니다. 때문에 성능 최적화를 위해서는 두 단계에서의 연산을 최소화하는 것이 중요합니다.
- JavaScript를 이용해 DOM을 직접 조작하면, 변경 사항이 있을 때마다 잠재적인 레이아웃 단계와 페인트 단계를 초래하게 됩니다. 가상 DOM은 실제로 렌더링되지는 않았지만, 실제 DOM 구조를 반영한 상태로 메모리에 있는 가상의 DOM입니다. 메모리 상에 있고, 실제 화면에 그려야할 필요는 없기 때문에 실제 DOM보다는 `연산 비용이 적습니다`. 가상 DOM은 이러한 특징을 바탕으로 위에서 말한 변경 사항들을 한 번에 묶어서 실제 DOM에 반영을 합니다. 물론 레이아웃 단계와 페인트 단계에서 `한 번에 변경되어야 하는 사항은 많아집니다`. 대신 단 한 번의 계산만으로도 바뀐 DOM을 적용할 수 있기 때문에 `연산의 횟수는 최소한`이 됩니다. 사실 이 과정은 DOM에 변경사항을 유발하는 스크립트를 묶어서 실행하는 방법으로도 가능합니다. 하지만 가상 DOM을 사용함으로서 이 과정을 모두 자동화할 수 있고, 개발자는 관리할 포인트를 줄일 수 있습니다.

---

## 참조

- [[HTML 강의] 브라우저와 브라우저 엔진 소개](https://www.youtube.com/watch?v=kc3KRK-evec)
- [프론트엔드 개발자라면 알고 있어야 할 브라우저의 동작 과정](https://wormwlrm.github.io/2021/03/27/How-browsers-work.html)
