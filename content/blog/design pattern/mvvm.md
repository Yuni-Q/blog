---
title: MVVM
date: 2020-07-23 09:07:99
category: design pattern
draft: true
---

## MVVM 패턴

- MVVM(Model/View/ViewModel) 패턴은 UI를 가지는 응용프로그램을 위한 아키텍처 패턴(architectural pattern)입니다. MVVM 패턴은 MVC(Model/View/Controller) 패턴의 변형으로 뷰의 추상화를 만드는 것이 핵심입니다. 뷰의 추상화는 재사용할 수 있고(reusable) 테스트하기 쉽습니다(testable). 뷰의 추상화를 통해 응용프로그램 구조는 단순해지고, 이상적으로, 시각 디자인과 표현 논리를 독립적으로 구현할 수 있습니다.
- 모델(Model)과 뷰(View)는 MVC 패턴의 그것들과 동일합니다. 모델은 데이터, 비즈니스 논리, 서비스 클라이언트 등으로 구성됩니다. 뷰는 선언적으로 구성된 UI 요소들을 의미합니다. MVVM 패턴을 학습하며 가장 집중해야할 부분은 뷰모델(ViewModel)입니다.
- 추상화(abstraction)는 MVVM 패턴의 뷰모델을 설명하며 빠뜨릴 수 없는 용어입니다. 뷰모델이란 이름은 ‘뷰의 모형’을 뜻합니다. 즉, 추상화된 뷰라는 의미입니다. 구동되는 응용프로그램에서 뷰는 UI 플랫폼이 제공하는 컨트롤들을 조합해 사용자에게 시각적으로 접근하지만 뷰모델은 이러한 뷰를 플랫폼 독립적인 공간에서 추상화합니다. 뷰모델은 뷰를 추상화하기 위해 추상화된 뷰 상태(ViewState)를 유지합니다. 예를 들어 뷰모델은 읽기와 쓰기가 가능한 문자열 속성을 통해 텍스트 입력기 컨트롤을 추상화합니다. 데이터 목록을 보여주는 컨트롤에 대해서는 각 요소의 뷰 상태가 들어있는 컬렉션이 사용됩니다.
- 모델이 제공하는 정보가 사용자에게 전달될 때, 혹은 그 반대의 경우 원본값이 그대로 사용되기도 하지만 그렇지 않은 경우도 있습니다. 모델이 표준시 기준 날짜 정보를 제공할 때 이것을 그대로 노출하는 것은 사용자에게 달갑지 않은 일입니다. 지역 시간대 및 현지 언어가 적용되거나 ‘어제’와 같은 상대적 표현으로 변환된다면 사용자는 더 나은 경험을 하게됩니다. 이런 변환 작업을 위해 뷰모델은 값 변환기(ValueConverters)를 가집니다.
- 뷰는 자신이 가진 상태를 사용자에게 표현할 뿐 아니라 사용자가 응용프로그램에 명령을 내릴 수단을 제공합니다. 뷰모델은 이런 기능을 추상화하기 위해 명령(Commands)을 가집니다. 명령을 통해 사용자는 모델의 행위를 실행할 수 있습니다.
- 뷰 상태, 값 변환기, 명령을 통해 뷰모델은 추상화된 뷰가 됩니다. 따라서 뷰모델은 개념적으로 사용자와 소통합니다. 개념적 공간에서 사용자는 뷰모델의 속성을 통해 정보를 입력하고 뷰모델의 명령을 실행시키며 뷰모델은 자신의 속성을 갱신해 명령 실행 결과와 응용프로그램 상태 변화를 사용자에게 표현합니다. 이메일과 암호를 이용한 로그인 화면을 떠올려봅시다. 이 화면을 추상화하는 뷰모델은 이메일 입력기와 암호 입력기에 대응하는 쓰기 가능한 문자열 속성 두 개와 로그인 버튼에 대응하는 명령을 가질 것입니다. 만약 서비스(모델)가 로그인 실패 코드를 반환한다면 이 코드는 값 변환기에 의해 사용자 친화적인 메시지로 변환되어 읽기 전용 문자열 속성을 통해 출력됩니다.
- 이제 추상화된 뷰와 물리적인 뷰를 연결해 줄 수단이 필요합니다. MVC 패턴에 익숙한 프로그래머라면 컨트롤러(Controller)가 뷰와 모델 사이의 작업흐름을 제어하는 모습을 떠올릴 것입니다. MVVM 패턴에서는 작업흐름 제어보다는 뷰와 뷰모델의 상태를 동기화해 줄 구성요소가 필요한데 데이터 바인딩(data binding)이 그것입니다. MVVM 패턴은 완성도 높은 데이터 바인딩 기반구조에 의존합니다. 데이터 바인딩으로 인해 뷰모델의 상태가 변경되면 뷰의 상태가 함께 변경됩니다. 그리고 그 역이 보장됩니다. 데이터 바인딩은 MVVM 패턴 외에도 유용하게 사용됩니다. 하지만 MVVM 패턴은 데이터 바인딩에 의존하므로 데이터 바인딩이나 그 대체자가 없다면 구현될 수 없습니다.
- 추상화는 구체화에 대한 지식을 가지지 않기 때문에 뷰모델은 뷰에 대해 알지 못합니다. 이것은 뷰모델이 플랫폼 독립적이고 다양한 플랫폼에서 재사용될 수 있음을 의미합니다. 응용프로그램 플랫폼에 종속된 코드는 생명주기 제약이 많지만 뷰모델 인스턴스는 언제든지 즉시 생성될 수 있습니다. 프로그래머는 단위 테스트 케이스를 통해 뷰모델에 구현된 응용프로그램 요구사항을 이른 시점에 검증할 수 있고 테스트 주도 개발(test-driven development) 도입도 쉽습니다.
- 재사용성과 테스트 용이성 외에 뷰모델이 추상화된 뷰로서 가지는 커다란 장점은 응용프로그램의 많은 부분이 뷰 독립적으로 설명되고 구현된다는 것입니다. 응용프로그램은 복잡한 컨트롤러 논리 없이 단순한 구조를 유지할 수 있습니다.
- 일반적으로 다른 패턴에 비해 아키텍처 패턴은 이론 그 이상으로 구현법이 장황하고 어렵습니다. MVVM 패턴은 Microsoft UI 기술의 풍부한 지원이 있었기에 만들어질 수 있었습니다. 반대로 생각해보면 비 Microsoft 기술에서 MVVM 패턴을 구현하기 위해서는 프로그래머들이 직접 준비해야할 것들이 많다는 뜻이 됩니다. 하지만 구현법에만 몰입해 패턴 본질의 가치를 등한시한다면 구현하는 과정이 아무리 멋지더라도 그 수확물은 충분하지 않을 것입니다.
- MVC에서 파생되는 패턴들은 모델과 뷰 사이에 무언가를 넣는 것입니다.
- 뷰를 가상화하는 프록시를 가짐으로서 뷰와 모델간의 관계를 끊습니다.
- 모델의 데이터 형태가 뷰에게 의존이 생기기 때문에 모델의 변경이 필요할 때는 뷰까지 변경이 이뤄짐으로 변경을 할 때 비용이 많이 듭니다. 그래서 모델의 데이터 형태와 뷰 렌더링을 위한 데이터 형태를 분리하기 위해 객체를 만들어서 의존성을 해결합니다. 뷰를 위한 데이터이기 때문에 뷰모델이라고 부릅니다.
- 뷰와 뷰모델은 양방향 바인딩이 이뤄집니다. 뷰와 뷰모델은 변경이 되었을 때 서로 변경이 됬음을 알려줍니다.
- Model과 View는 MVC에서 정의된 역할과 동일합니다. Model은 상태 저장, 비즈니스 로직, 순수한 데이터입니다. View는 시각적인 요소를 담당합니다.
- ViewModel는 View가 데이터 바인딩에 사용할 수 있는 Model을 전문화합니다.
  - Model Type을 View Type으로 변환하는 데이터 변환기 역할
  - View가 Model과 상호작용 할 수 있게 하는 역할
  - UI의 재사용 가능한 부분에 대한 추상적 표현
  - Selection과 Commands를 포함

### 제작목적

- 현대 UI 개발 플랫폼에 맞게 제작합니다.
- HTML 또는 XAML과 같은 선언적 형태로 항상 수행합니다.

### 특징

- Model과 View는 MVC에서 정의된 역할과 동일합니다.
  - Model은 상태저장, 비즈니스 로직, 순수한 데이터입니다.
  - View는 시각적인 요소를 담당합니다.
- ViewModel는 View가 데이터 바인딩에 사용할 수 있는 Model을 전문화합니다.
  - Model Type을 View Type으로 변환하는 데이터 변환기 역할합니다.
  - View가 Model과 상호작용 할 수 있게 하는 역할입니다.
  - UI의 재사용 가능한 부분에 대한 추상적 표현합니다.
  - Selection과 Commands를 포함합니다.

### VM(ViewModel)

- 뷰에 필요한 데이터를 준비하고 모델에 필요한 이벤트르 전달합니다. 그러면서도 뷰에 종속되지 않는 뷰만을 위한 모델이라고 할 수 있습니다.
- Command 패턴과 Data Binding을 활용해 의존성을 없앱니다.
  - Command 패턴은 요청을 객체의 형태로 캡슐화하여 저장, 로깅, 최소를 할수 있는 패턴입니다.
  - Data Binding은 XML에서 만든 View들을 자동으로 알아서 만들어주는 안드로이드 라이브러리 입니다.
- MVP 패턴처럼 View를 통해 사용자의 입력이 들어오면 되면 Command 패턴으로 ViewModel에 요청합니다.
- ViewModel은 Model에게 필요한 데이터를 요청하고 Model에 응답한 뒤 ViewModel에게 다시 가공해서 저장합니다.
- 여기서 View로 다시 안돌려주냐고 할 수 있는데, View는 Data Binding을 통해 자동으로 갱신하게 됩니다.

### MVVM 패턴의 장점

- Command 패턴과 Data Binding을 사용하여 View와 Model, 심지어 View와 ViewModel 사이의 의존성 또한 없습니다.
- 테스트와 모듈화가 쉽습니다.
- 뷰와 모델을 연결하기 위해 사용해야 하는 연결 코드를 줄일 수 있습니다.

### MVVM 패턴의 단점

- ViewModel의 설계가 쉽지 않습니다.
- 뷰가 변수와 표현식 모두에 바인딩될 수 있어서 시간이 지남에 따라 관계 없는 프리젠테이션 로직이 늘어나 유지 관리하기 번거롭습니다.

## 참조

- [MVC? 싱글톤? 여러가지 디자인 패턴들](https://blog.metafor.kr/146)
- [MV\*/Flux 정리](https://chodragon9.github.io/blog/mv_flux/#mvc)
- [MVVM 아키텍처 패턴](https://gyuwon.github.io/blog/2017/03/05/mvvm-architectural-pattern.html?fbclid=IwAR1v3aovkHqfo0fP7d52Ex8BfFS9AFAs36vB6ToplGmA0bEa_odC1rNQniM)
