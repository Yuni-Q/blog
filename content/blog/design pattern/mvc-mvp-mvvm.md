---
title: MVC MVP MVVM
date: 2020-03-18 17:03:41
category: design pattern
draft: true
---

## Model

- 데이터를 처리하는 역할 입니다.
- 애플리케이션의 정보(데이터)를 처리하는 컴포넌트를 말합니다.
- 데이터베이스에 연결하고 데이터를 추출하거나 저장, 삭제, 업데이트, 변환 등의 작업을 수행하는 역할을 합니다.

## View

- 사용자가 보는 화면입니다.
- 화면에 표시되는 부분입니다.
- 추출한 데이터나 일반적인 텍스트 데이터를 표시하거나 input, button 등의 사용자 인터페이스 요소, 데이터 및 객체의 입력, 출력 또는 사용자와의 상호작용을 위한 인터페이스를 표시하는 영역입니다.

## Controller

- 데이터와 뷰를 연결, 제어하는 역할 입니다.
- 어플리케이션에서 각 요소들의 연결관계를 설정하고 데이터와 시각적 부분의 연결 등을 관리합니다.
- url로부터 입력되는 정보로부터 어떤 데이터와 뷰를 연결할 지 등을 제어핣니다.
- 사용자가 Controller에 작업을 요청하면 Controller는 Model을 호출하여 데이터를 처리하고 Model이 데이터를 처리한 결과를 View에 보내고 이 결과를 사용자가 보게 됩니다.
- Model과 View를 이어주는 다리 역할, 모든 '이벤트'를 처리하는 부분, 메인 조직을 담당합니다.
- Model과 View 내의 클래스들 간 정보 교환하는데 사용합니다.

## MVC

- MVC는 역사상으로 두가지가 있습니다.
  - 첫번째는 초기에 XEROX PARC에서 발표된 것으로 사용자가 도메인 정보를 직접 보고 조작하는 것을 목표로 하는 MVC 입니다. View가 Model에 직접 데이터를 요청했으며 Controller는 사용자 상호작용을 담당합니다.
  - 두번째는 현대의 MVC입니다. 현대의 MVC는 View는 Model과 간접적인 관계입니다. View는 Controller를 통해 Model의 데이터를 전달 받게 됩니다. 그리고 Controller는 사용자 상호작용을 View에게 위임받습니다.

### 초기의 MVC

- MVC의 기본 목적은 사용자의 멘탈모델과 컴퓨터에 존재하는 디지털 모델 간의 차이를 연결하는 것입니다.
- 이상적인 MVC 솔루션은 사용자가 도메인 정보를 직접 보고 조작하는 착각을 지원합니다.
- Model은 도메인 데이터를 의미하며 순수한 데이터의 역할을 합니다.
- Controller는 사용자의 상호작용 담당을 합니다.
- View는 프레젠테이션을 담당합니다.
- Controller는 View를 생성하는 책임이 있으며 Controller는 View와 1:N의 관계입니다. View와 Model 관계는 N:M의 관계입니다.

### 현대의 MVC

- 컨트롤러는 모델과 직접적인 관계입니다. 모델은 컨트롤러를 모르고 컨트롤러는 모델을 생성하는 책임이 있습니다. 모델은 순수한 데이터 원형을 이야기합니다. 모델은 변화가 일어났을 때 컨트롤러에게 알려줍니다. 결합도를 줄이기 위해 옵져버 패턴으로 모델과 컨트롤러가 연결되어 있습니다.
- 컨트롤러는 뷰도 생성합니다. 컨트롤러는 뷰에게 모델에게 받은 데이터를 전달합니다. 뷰는 모델에 기반하여 렌더링 처리합니다. 뷰에게 사용자 입력의 처리를 컨트롤러에게 위임을 합니다. 컨트롤러는 뷰에게 위임받은 액션을 대신 처리하게 되고 모델에게 데이터 요청을 하게 됩니다.
- 컨트롤러의 생성은 라우터에서 하게 됩니다. 상황에 따라 컨트롤러를 생성합니다. 라우터에 따라 동작해야 하는 역할을 결정하여 컨트롤러를 생성하게 됩니다.
- 모델과 뷰가 분리된 이유는 변화율이 다르기 때문에 두가지를 분리합니다.
- 뷰를 만들 때는 굉장히 광활합니다. 컨트롤러가 순수한 데이터를 뷰에게 전달하기 때문입니다. 프런트 엔드 개발할 때는 순수한 데이터를 뷰에게 표시하는 역할에 비중이 크고, 백엔드 개발할 때는 모델의 비중이 큽니다.
- 컨트롤러는 라우터를 알고 있습니다. 그 이유는 컨트롤러가 다른 컨트롤러에게 일을 시킬 때 필요하기 때문입니다.
- 컨트롤러를 다른 컨트롤러를 모릅니다. 그렇기 때문에 라우터를 통해서 컨트롤러를 찾아달라고 요청하게 됩니다. 라우터는 역할에 맞는 컨트롤러를 상태로 가지고 있습니다. 필요할 때 해당 컨트롤러를 실행해줍니다.
- 컨트롤러는 모델을 생성하고 청취합니다. 그리고 뷰를 생성합니다. 컨트롤러에서 모델의 변경을 감지하면 뷰에게 새로 렌더링하도록 요청합니다. 컨트롤러는 본인의 역할이 아닌 것은 라우터를 통해 컨트롤러를 요청합니다.
- 현대의 컨트롤러와 뷰는 1:1 관계 입니다.
- 객체지향 프로그래밍에서 MVC란 사용자 인터페이스를 성공적이며 효과적으로 데이터 모형에 관련 시키기 위한 방법론 또는 설계 방식중 하나로써, 목적 코드의 재사용에 유용한 것은 물론, 사용자 인터페이스와 응용프로그램 개발에 소요되는 시간을 현저하게 줄여주는 방식입니다.
- Model, View, Controller의 약자로 User - View - Controller - Model - Controller - View - User의 구조를 가지고 있습니다.
- 응용프로그램의 시각적 부분과 이면의 동작을 제어를 처리하는 부분(비즈니스 로직)을 분리하여 서로에 미치는 영향 없이도 응용 프로글램을 변경할 수 있습니다.
  - 데이터베이스나 제어프로그램의 변경 없이 시각적인 부분만 수정하려면 View에 해당하는 부분만 수정하면 됩니다.
  - 시각적인 부분과 관계 없이 데이터 처리 부분만 수정하려면 Model 부분만 수정하면 됩니다.
  - 프로그램간 연결과 제어를 수정하려면 controller 부분만 수정하면 됩니다.

### MVC 패턴의 장점

- 전형적인 어플리케이션 OOP 구조로써 가장 단순하며 보편적으로 많이 사용하는 디자인 패턴입니다.
- 맡은 일에만 집중할 수 있게 되기 때문에 효율성을 높이고 유지보수가 편리해지고, 애플리케이션의 확장성과 유연성이 늘어나고, 중복코딩의 문제점이 사라집니다.
- 유저 인터페이스와 비지니스 로직을 분리할수 있습니다.

### MVC 패턴의 단점

- View와 Model 사이의 의존성이 높습니다. 따라서 애플리케이션이 커질수록 복잡하고 유지보수가 어려워질 수 있습니다.
- 현대의 MVC패턴의 컨트롤러는 책임이 많기 때문에 컨트롤러 볼륨이 커집니다. 이 부분을 해결하기 위해서는 컴포넌트로 분리합니다. 컨트롤러를 컴포넌트로 분리하여 볼륨을 작게 만듭니다.

## MVP 패턴

- MVC패턴은 View와 Model 사이의 의존성이 높고, 이 의존성이 높기 때문에 어플리케이션이 커지면 커질수록 더 복잡해지고 유지보수가 힘들어진다는 단점을 가지고 있습니다.
- MVP는 Model-View-Presenter의 약자로 Model과 View는 MVC와 동일하지만 Controller 대신에 Presenter가 존재합니다.
- Model과 View는 서로를 알 필요가 없이 Presenter만 가리킵니다. 따라서 Model과 View의 의존성은 사라지게 됩니다.
- 사용자들의 입력들은 View를 통해서 데이터를 Presenter에 요청하고 Presenter는 Model에게 데이터를 요청합니다. Model은 Presenter에게 응답하여 다시 View로 전송해서 화면에 나타내게 되는 동작 순서를 가지고 있습니다.
- View는 기본적으로는 MVC와 같이 화면에 보여지는 요소를 맡는 것은 동일하나 `Controller가 사라짐에 따라서 이제 사용자의 입력을 받는 역할`을 겸하게 됩니다.
- Presenter는 View에서 요청한 정보로 Model을 가공하여 View에 전달해주는 부분입니다. 본질적으로는 MVC의 컨트롤러와 같지만 `뷰에 연결되는 것이 아니라 그냥 인터페이스`라는 점이 다릅니다.

### MVP 패턴의 장점

- MVC와 달리 View와 Model의 의존성이 사라졌습니다.

### MVP 패턴의 단점

- View와 Model 사이의 의존성은 해결되었지만 대신에 View와 Presenter 사이의 높은 의존성을 가지게 되었습니다. 이는 MVC와 마찬가지로 애플리케이션이 복잡해질수록 View와 Presenter 사이의 의존성이 더욱 강해지고 복잡해집니다.

## MVVM 패턴

- MVC에서 파생되는 패턴들은 모델과 뷰 사이에 무언가를 넣는 것입니다.
- 뷰를 가상화하는 프록시를 가짐으로서 뷰와 모델간의 관계를 끊습니다.
- 모델의 데이터 형태가 뷰에게 의존이 생기기 때문에 모델의 변경이 필요할 때는 뷰까지 변경이 이뤄짐으로 변경을 할 때 비용이 많이 듭니다. 그래서 모델의 데이터 형태와 뷰 렌더링을 위한 데이터 형태를 분리하기 위해 객체를 만들어서 의존성을 해결합니다. 뷰를 위한 데이터이기 때문에 뷰모델이라고 부릅니다.
- 뷰와 뷰모델은 양방향 바인딩이 이뤄집니다. 뷰와 뷰모델은 변경이 되었을 때 서로 변경이 됬음을 알려줍니다.
- Model과 View는 MVC에서 정의된 역할과 동일합니다. Model은 상태 저장, 비즈니스 로직, 순수한 데이터입니다. View는 시각적인 요소를 담당합니다.
- ViewModel는 View가 데이터 바인딩에 사용할 수 있는 Model을 전문화합니다.
  - Model Type을 View Type으로 변환하는 데이터 변환기 역할
  - View가 Model과 상호작용 할 수 있게 하는 역할
  - UI의 재사용 가능한 부분에 대한 추상적 표현
  - Selection과 Commands를 포함

### VM(ViewModel)

- 뷰에 필요한 데이터를 준비하고 모델에 필요한 이벤트르 전달합니다. 그러면서도 뷰에 종속되지 않는 뷰만을 위한 모델이라고 할 수 있습니다.
- Command 패턴과 Data Binding을 활용해 의존성을 없앱니다.
  - Command 패턴은 요청을 객체의 형태로 캡슐화하여 저장, 로깅, 최소를 할수 있는 패턴입니다.
  - Data Binding은 XML에서 만든 View들을 자동으로 알아서 만들어주는 안드로이드 라이브러리 입니다.
- MVP 패턴처럼 View를 통해 사용자의 입력이 들어오면 되면 Command 패턴으로 ViewModel에 요청합니다.
- ViewModel은 Model에게 필요한 데이터를 요청하고 Model에 응답한 뒤 ViewModel에게 다시 가공해서 저장합니다.
- 여기서 View로 다시 안돌려주냐고 할 수 있는데, View는 Data Binding을 통해 자동으로 갱신하게 됩니다.

### MVVM 패턴의 장점

- Command 패턴과 Data Binding을 사용하여 View와 Model, 심지어 View와 ViewModel 사이의 의존성 또한 없습니다.
- 테스트와 모듈화가 쉽습니다.
- 뷰와 모델을 연결하기 위해 사용해야 하는 연결 코드를 줄일 수 있습니다.

### MVVM 패턴의 단점

- ViewModel의 설계가 쉽지 않습니다.
- 뷰가 변수와 표현식 모두에 바인딩될 수 있어서 시간이 지남에 따라 관계 없는 프리젠테이션 로직이 늘어나 유지 관리하기 번거롭습니다.

## 참조

- [MVC? 싱글톤? 여러가지 디자인 패턴들](https://blog.metafor.kr/146)
