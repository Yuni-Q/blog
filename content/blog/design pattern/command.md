---
title: command
date: 2021-01-26 01:01:10
category: design pattern
tags: []
draft: true
marp: true
theme: gaia
---

## 객체의 행위를 클래스로 만들어 캡슐화 하는 패턴

## 커맨드 패턴은 행위에 대한 패턴입니다.

- 행위 패턴은 객체나 클래스 사이의 알고리즘이나 책임 분배에 관련된 패턴입니다.
- 한 객체가 혼자 수행할 수 없는 작업을 여러 개의 객체로 어떻게 분배하는지, 또 그렇게 하면서도 객체 사이의 결합도를 최소화하는 것에 중점을 둡니다.

## 커맨드 패턴을 부르는 다양한 명칭

- 커맨드 패턴
- 명령 패턴
- 작동(Action) 패턴
- 트랜잭션(Transaction) 패턴

## 커맨드 패턴이란?

- 실행될 기능을 캡슐화함으로써 주어진 여러 기능을 실행할 수 있는 재사용성이 높은 클래스를 설계하는 패턴을 말합니다. 즉, 이벤트가 발생했을 때 실행될 기능이 다양하면서도 변경이 필요한 경우에 이벤트를 발생시키는 클래스를 변경하지 않고 재사용하고자 할 때 유용합니다.
- 커맨드 패턴(Command pattern)이란 `요청을 객체의 형태로 캡슐화`하여 사용자가 보낸 요청을 나중에 이용할 수 있도록 매서드 이름, 매개변수 등 요청에 필요한 정보를 저장 또는 로깅, 취소할 수 있게 하는 패턴입니다.
  - 가장 주의 깊게 볼 사항은 커맨드 자체를 객체화한다는 점입니다.
- 실행될 기능을 캡슐화함으로써 `기능의 실행을 요구하는 호출자(Invoker)` 클래스와 `실제 기능을 실행하는 수신자(Receiver)` 클래스 사이의 `의존성을 제거`합니다. 따라서 실행될 기능의 변경에도 호출자 클래스를 수정 없이 그대로 사용 할 수 있습니다.
  - 커맨드 객체는 일련의 행동을 특정 리시버하고 연결시킴으로써 요구사항을 캡슐화한다. 이렇게 하기 위해 행동과 리시버를 한 객체에 집어넣고 메소드 하나만 외부에 공개하는 방법을 사용한다.
  - 어떤 객체(A)에서 다른 객체(B)의 메서드를 실행하려면 그 객체(B)를 참조하고 있어야 하는 의존성이 발생합니다. 그러나 커맨드 패턴을 적용하면 의존성을 제거할 수 있습니다. 또한 기능이 수정되거나 변경이 일어날 때 A 클래스 코드를 수정없이 기능에 대한 클래스를 정의하면 되므로 시스템이 확장성이 있으면서 유연해집니다. 클래스를 추가하면 되므로, `OCP`에 위배되지 않으면서 기능을 추가할 수 있습니다.
  - 보통 OOP 에서는 주체 객체와 대상 객체가 존재하고, 대상 객체에 대한 액션은 주체 객체에서의 메쏘드로 처리하는데, 이 액션까지 객체로 만든 뒤에 처리하는 것입니다.
- 이 패턴의 핵심은 `Command 인터페이스`입니다.
- 요구 사항을 객체로 캡슐화할 수 있으며, 매개변수를 써서 여러 가지 다른 요구 사항을 집어넣을 수도 있습니다. 또한 요청 내역을 큐에 저장하거나 로그로 기록할 수도 있으며, 작업취소 기능도 지원 가능합니다.
- 캡슐화를 더 여러 수준으로 진행해서 요청 실행자와 실제 요청 구현체를 다시 분리할 수도 있다.
- 커맨드 패턴은 자바스크립트와 같은 함수가 일급 객체인 언어에서의 콜백과 같은 역할을 한다고 볼 수 있습니다.
- 명령어를 인보커에 언제든지 등록할 수 있고, 원하는 언제든지 인보커로 간단하게 실행시킬 수 있습니다. 또한, 추후 명령이나 리시버가 더 추가될 경우 기존 코드에 수정 없이, 두 객체를 만들고 setCommand() 로 추가해주면 됩니다. 즉, `OCP 원칙`을 잘 지켜냅니다.
- 메타 커맨드 패턴을 이용하게되면 명령으로 이루어진 메크로를 만들어서 여러 명령을 실행 가능합니다.

## 장점

- 실행될 기능을 캡슐화함으로써 주어진 여러 기능을 실행할 수 있는 재사용성이 높은 클래스를 설계하는 패턴입니다.
- 작업을 수행하는 객체(리시버)와 작업을 요청하는 객체를 분리하기 때문에 SRP 원칙(단일 책임 원칙)을 잘 지킵니다.
- 기존 코드 수정 없이 새로운 리시버, 명령어 추가가 가능하기 때문에 OCP 원칙(개방 폐쇄 원칙)을 잘 지킵니다.
- 커맨드 단위의 별도의 액션(undo, redo) 등이 가능하고, 커맨드 상속 및 조합을 통해 더 정교한 커맨드를 구현할 수 있습니다.

## 단점

- 전체적으로 이해가 필요하고 복잡한 설계구조를 가집니다.

## Command 패턴 사용 방법

- 커맨드 패턴에는 명령(command), 수신자(receiver), 발동자(invoker), 클라이언트(client)의 네개의 용어가 있습니다.
  - 커맨드 객체는 수신자 객체를 가지고 있으며, 수신자의 메서드를 호출하고, 이에 수신자는 자신에게 정의된 메서드를 수행합니다.
  - 커맨드 객체는 별도로 발동자 객체에 전달되어 명령을 발동하게 합니다.
  - 발동자 객체는 필요에 따라 명령 발동에 대한 기록을 남길 수 있습니다.
  - 한 발동자 객체에 다수의 커맨드 객체가 전달될 수 있습니다.
  - 클라이언트 객체는 발동자 객체와 하나 이상의 커맨드 객체를 보유합니다.
  - 클라이언트 객체는 어느 시점에서 어떤 명령을 수행할지를 결정합니다.
  - 명령을 수행하려면, 클라이언트 객체는 발동자 객체로 커맨드 객체를 전달합니다.
- Command 인터페이스와 ConcreteCommand 구현체만 있어도 커맨드 패턴을 사용했다고 볼 수 있습니다. 다만 Receiver를 이용해 실제 명령의 실행 코드와 개념적인 명령을 분리하고, Invoker를 이용해 명령의 실제 실행을 Client와 분리하는 것이 좋습니다.
- 행동과 리시버를 한 객체에 집어넣고, execute()라는 메소드 하나만 외부에 공개합니다. 이 메소드 호출에 의해서 리시버에서 일련의 작업이 처리됩니다. 외부에서 볼 때는 어떤 객체가 리시버 역할을 하는지, 그 리시버에서 실제로 어떤 일을 하는지 알 수 없습니다. 단지 execute() 메소드를 호출하면 요구 사항이 처리된다는 것만 알 수 있습니다.
- 코드를 실행시키면, 장군이(client)이 전략(invoker)을 통하여 명령(command)를 내려 명령을 수행(Receiver)하게 됩니다.

## 활용 상황

- 이벤트가 발생했을 때 실행될 기능이 다양하면서도 변경이 필요한 경우에 이벤트를 발생시키는 클래스를 변경하지 않고 재사용하고자 할 때 사용합니다.
  - 커맨드 발생 시점을 사용자가 커스터마이징 해야 하는 경우
  - 여러 커맨드를 조합하여 하나의 커맨드처럼 사용할 필요가 있는 경우
  - 커맨드 실행 취소, 재 실행 등의 기능을 구현해야 하는 경우

## 식당 주문 시스템에 비유해서 알아보겠습니다.

- 어떤 식당에는 주방장과 웨이터가 있습니다. 이 식당에 어떤 손님이 들어와, 주문서에 스파게티를 작성하고 이를 웨이터에게 전달했습니다. 웨이터는 이 주문서를 읽고 주방장에게 스파게티 요리를 요청합니다.
- 손님 : 클라이언트
- 웨이터 : 인보커 객체
- 주문을 받는 것 : setCommand()
- 주문서 : 커맨드객체
- 주문을 주방장에게 전달하여 요리를 요청 하는 것 : execute()
- 주방장: 리시버 객체

### Client

- 말 그대로 명령을 내릴 `사용자`입니다.
- 사용자는 Receiver와 ConcreteCommand 만 알고 있습니다.
  - 즉, 누가 무엇을 할지에 대해서만 알고 있습니다.
  - 이때 '누가'는 Receiver, '무엇을 할지'는 Command 입니다.

## Receiver

- 실제로 Client 의 원하는 요청을 수행하는 객체입니다.
- 누가 언제 요청해왔는지 모릅니다. 액션에 대해서만 관심(구현)을 가집니다.
- Client 에서 '누가'에 해당하는 객체다.

## Invoker

- Client의 요청을 받아 실제로 Receiver의 액션을 호출하는 객체입니다.
- 흐름 상 Client의 요청을 Receiver에게 전달해줍니다.
- Client 는 Invoker를 거쳐 Receiver에게 요청하기 때문에, Invoker에서 Receiver에 도달하기 전, 요청에 대한 이런저런 설정들을 할 수가 있습니다.

## Command

- ConcreteCommand의 추상 클래스입니다.
- execute()를 공통 인터페이스로 가집니다.

## ConcreteCommand

- 실제 구체적인 요청 내용을 담는 클래스입니다.
- 누가(Receiver)가 무엇을 해야하는지(execute() 내 로직)를 구현합니다.

## 스트레티지 패턴

- 추상화 수준이 더 많아진 스트레티지 패턴이라는 느낌도 받았다. 차이가 있다면, 스트레티지 패턴은 전략을 실행하는 객체와 전략 객체의 관계가 중요하다면, 커맨드 패턴은 명령이 객체화되어 다루어지는 것이 중요하다는 점이다.

## 참고

- [[Design Pattern] 커맨드 패턴이란](https://gmlwjd9405.github.io/2018/07/07/command-pattern.html)
- [커맨드 패턴 (Command Pattern)](https://johngrib.github.io/wiki/command-pattern/)
- [커맨드 패턴](https://ko.wikipedia.org/wiki/%EC%BB%A4%EB%A7%A8%EB%93%9C_%ED%8C%A8%ED%84%B4)
- [🙈[디자인패턴] 커맨드 패턴 ( Command Pattern )🐵](https://victorydntmd.tistory.com/295)
- [정리정리정리](https://jusungpark.tistory.com/18)
- [[디자인 패턴] 커맨드 패턴 (Command Pattern)](https://gdtbgl93.tistory.com/23)
- [[디자인 패턴 16편] 행동 패턴, 커맨드 (Command)](https://dailyheumsi.tistory.com/217)
- [코더가 아닌 개발자!! Why를 가지자!](https://jeongupark-study-house.tistory.com/65)
