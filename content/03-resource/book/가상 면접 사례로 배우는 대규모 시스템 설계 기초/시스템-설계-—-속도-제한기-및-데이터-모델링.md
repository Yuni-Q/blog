---
title: 시스템 설계 — 속도 제한기 및 데이터 모델링
date: 2022-11-14 23:11:18
category: 가상 면접 사례로 배우는 대규모 시스템 설계 기초
tags: []
draft: true
---

## 속도 제한기(Rate limiter)

- 속도 제한기는 서비스에서 허용하는 데 동의한 윈도우 시간당 요청 수를 모니터링하는 도구입니다. 요청 횟수가 서비스 소유자와 사용자가 합의한 수를 초과하면 속도 제한기는 모든 초과 호출을 차단합니다
- 이러한 사용 사례에서 mysql과 같은 영구 메모리 저장소를 사용하는 것은 좋지 않은 생각입니다. 디스크 탐색에 걸리는 시간이 속도 제한기 세분성을 방해할 만큼 충분히 높기 때문입니다.

### 다양한 수준

- 단일 시스템, 단일 스레드 시나리오의 속도 제한기
- 단일 시스템의 속도 제한기, 다중 스레드 시나리오 — `경쟁 조건 처리`
- 분산 시나리오의 속도 제한기 — `redis와 같은 분산 캐시 사용`
- 클라이언트 측의 속도 제한기 - `모든 초과 요청에 대해 클라이언트에서 서버로의 네트워크 호출을 방지합니다`

### 고정 창 카운터

- 이것은 속도 제한 문제를 해결하는 매우 기본적인 방법입니다.
- 각 단위 시간 창에 대해 하나의 버킷이 있습니다.
- 각 버킷은 해당 특정 기간의 요청 수를 유지합니다.
- 공간 복잡도: O(1) — 현재 창 수 저장
- 시간 복잡도: O(1) — 가져오기 및 단순 원자 증가 연산

#### 장점

- 구현하기 쉬움
- 메모리 사용량이 적습니다. 수행되는 모든 작업은 카운트를 저장하는 것이기 때문입니다.
- 기술과 같은 redis와 함께 내장된 동시성을 사용할 수 있습니다.

### 단점

- 이것은 잘못된 것입니다. 시간을 정시단위로 나눌 때와 아닐 때 윈도우에 최대 요청 수가 달라질 수 있습니다.

### 슬라이딩 윈도우 로그

- 모든 사용자에 대해 가장 최근 창의 시간 범위 내에서 모든 기록 호출이 발생한 시간을 나타내는 타임스탬프 대기열이 유지됩니다.
- 새 요청이 발생할 때마다 창 시간보다 오래된 타임스탬프가 있는지 확인하고 더 이상 관련이 없으므로 삭제됩니다(
  - 요청할 때마다 이 작업을 수행하는 대신 이 단계를 'n'마다 주기적으로 수행할 수도 있습니다. 분 또는 대기열의 특정 길이에 도달했을 때
- 새 타임스탬프가 사용자 대기열에 추가됩니다.
- 대기열의 요소 수가 허용된 수보다 많지 않으면 요청이 통과되고, 그렇지 않으면 예외가 발생합니다.
- 공간 복잡도: O(윈도우 시간에 표시되는 최대 요청) — 시간 창에 있는 요청의 모든 타임스탬프를 저장합니다.
- 시간 복잡도: O(윈도우 시간에 표시되는 최대 요청 수) - 타임스탬프의 하위 집합 삭제

#### 장점

- 완벽하게 작동

#### 단점

- 높은 메모리 풋프린트. 모든 요청 타임스탬프는 창 시간 동안 유지되어야 하므로 여러 사용자 또는 큰 창 시간을 처리하기 위해 많은 메모리가 필요합니다.
- 오래된 타임스탬프를 제거하기 위한 높은 시간 복잡도

### 슬라이딩 윈도우 카운터

- 이것은 고정 창 카운터와 슬라이딩 창 로그의 하이브리드입니다.
- 전체 창 시간은 더 작은 버킷으로 나뉩니다. 각 버킷의 크기는 비율 제한기에 허용되는 탄력성의 정도에 따라 다릅니다.
- 각 버킷은 버킷 범위에 해당하는 요청 수를 저장합니다.
- 공간 복잡도: O(버킷 수)
- 시간 복잡도: O(1) — 최근 버킷을 가져오고 버킷의 총 합계에 대해 증가 및 확인합니다(totalCount 변수에 저장할 수 있음).

#### 장점

- 카운트만 저장되므로 큰 메모리 공간 없음

#### 단점

- 그다지 엄격하지 않은 룩백 윈도우 시간, 특히 더 작은 단위 시간에만 작동합니다.

---

## 참고

- [System Design — Rate limiter and Data modelling](https://medium.com/@saisandeepmopuri/system-design-rate-limiter-and-data-modelling-9304b0d18250)
