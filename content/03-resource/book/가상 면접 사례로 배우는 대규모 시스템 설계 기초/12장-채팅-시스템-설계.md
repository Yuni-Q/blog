---
title: 12장 채팅 시스템 설계
date: 2022-09-19 11:09:12
category: 가상 면접 사례로 배우는 대규모 시스템 설계 기초
tags: []
draft: true
---

## 채팅 앱

- 페이스북처럼 1:1 채팅에 집중하는 앱
- 슬랙 같은 그룹 채팅에 중점을 둔 업무용 앱
- 게임 채팅에 쓰이는 디스코드 같이 대규모 그룹의 소통과 응다지연(latency)이 낮은 음성 채팅에 집중하는 앱

## 요구 조건

- 응답지연이 낮은 일대일 채팅 기능
- 최대 100명까지 참여할 수 있는 그루 채팅 기능
- 사용자의 접속 상태 표시 기능
- 다양한 단말 지원. 하나의 계정으로 여러 단말에 동시 접속 지원
- 푸시 알림

## 개략적 설계안

- 채팅 시스템의 경우 클라이언트는 모바일 앱이거나 웹 어플리케이션입니다. 클라이언트는 서로 직접 통신하지 않습니다.
  - 클라이언트들로부터 메시지 수신
  - 메시지 수신자(recipient) 결정 및 전달
  - 수신자가 접속(online) 상태가 아닌 경우에는 접속할 때까지 해당 메시지 보관

### 통신 프로토콜

- 채팅을 시작하려는 클라이언트는 네트워크 통신 프로토콜을 사용하여 서비스에 접속합니다. 따라서 채팅 서비스의 경우 어떤 통신 프로토콜을 사용할 것인가도 중요한 문제입니다.

#### HTTP

- 현재 웹에서 가장 널리 사용되는 프로토콜입니다.
- 채팅 서비스와의 접속에는 keep-alive 헤더를 사용하면 효율적인데, 클라이언트와 서버 사이의 연결을 끊지 않고 계속 유지할 수 있습니다.
  - TCP 접속 과정에서 발생하는 핸드셰이크(hand-shake) 횟수를 줄일 수 있습니다.

#### 폴링

- 클라이언트가 주기적으로 서버에게 새 메시지가 있는지 물어봅닌다.
- 답해줄 메시지가 없는 경우에는 서버 자원이 불필요하게 낭비됩니다.

#### 롱 폴링(long polling)

- 폴링의 비효율을 해결하기 위해 나온 기법입니다.
- 클라이언트는 새 메시지가 반환되거나 타임아웃이 될 때까지 연결을 유지합니다.
- 클라이언트는 새 메시지를 받으면 기존 연결을 종료하고 서버에 새로운 요청을 보내어 모든 절차를 다시 시작합니다.

##### 약점

- 메시지를 보내는 클라이언트와 수신하는 클라이언트가 같은 채팅 서버에 접속하게 되지 않을 수도 있습니다.
- 서버 입장에서는 클라이언트가 연결을 해제했는지 알 수 없습니다.
- 여전히 비효율적입니다. 메시지를 많이 받지 않는 클라이언트도 타임아웃이 일어날 때마다 주기적으로 서버에 다시 접속할 것입니다.

#### 웹소켓(WebSocket)

- 서버가 클라이언트에게 비동기(async) 메시지를 보낼 때 가장 널리 사용하는 기술입니다.
- 웹소켓 연결은 클라이언트가 시작합니다. 한번 맷어진 연결은 항구적이며 양방향입니다. 서버는 클라이언트에게 비동기적으로 메시지를 전송할 수 있습니다. 웹소켓 연결을 항구적으로 유지되어야 하기 때문에 서버 측에서 연결 관리를 효율적으로 해야 합니다.
- 처음에는 HTTP 연결이지만 특정 핸드셰이크 절차를 거쳐 웹소켓 연결로 업그데이드됩니다.
- 웹소켓은 읿나적으로 방화벼이 이쓴 환경에서도 잘 동작합니다. HTTP 혹은 HTTPS 프로토콜이 사용하는 기본 포트번호를 그대로 쓰기 때문입니다.
- 웹소켓을 이용하면 메시지를 보낼 때나 받을 때나 받을 때 동일한 프로토콜을 사용할 수 있으므로 설계뿐 아니라 구현도 단순하고 직관적입니다.

## 개략적 설계안

- 채팅 서버: 클라이언트 사이에 메시지를ㄹ 중계하는 역할을 담당합니다.
- 접속상태 서버(presence server): 사용자의 접속 여부를 관리합니다.
- API 서버: 로그인, 회원가입, 프로파일 변경 등 그 외 반머지 전부를 처리합니다.
- 알림 서버: 푸시 알림을 보냅니다.
- 키-값 저장소(key-value store): 채팅 이력을 보관합니다.

### 저장소

- 사용자 프로파일, 설정, 친구 목록처럼 일반적인 데이터는 안정성을 보장하는 관계형 데이터베이스에 보관합니다.
- 채팅 이력은 데이터 양이 많고 주로 최근 주고받은 메시지를 빈번하게 사용합니다. 무작위적인 데이터에 접근을 하고 읽기 쓰기 비율이 대략 1:1입니다. 이 모두를 지원하기 위해 키-값 저장소를 추천합니다.
  - 키-값 저장소는 수평적 규모확장(horizontal scaling)이 쉽습니다.
  - 키-값 저장쇼ㅗ는 데이터 접근 지연시간(latency)이 낮습니다.
  - 관계형 데이터베이스는 데이터 가운데 롱 테일(long tail)에 해당하는 부분을 잘 처리하지 못하는 경향이 있습니다. 인덱스가 커지면 데이터에 대한 무작위적 접근(random access)을 처리하는 비용이 늘어납니다.

### 메시지 ID

- message_id의 값은 고유해야 합니다(uniqueness)
- ID 값은 정렬 가능해야 하며 시간 순서와 일치해야 합니다. 즉, 새로운 ID는 이전 ID보다 큰 값이어야 합니다.

#### 대안

- RDBMS라면 auto_increment
- NoSQL
  - 스노플레이크 같은 전역적 64-bit 순서 번호(sequence number) 생성기 이용
  - 지역적 순서 번호 생성기(local sequence number generator) 이용

## 상세 설계

### 서비스 탐색

- 사용되는 기준으로는 클라이언트의 위치(geographical location), 서버의 용량(capacity) 등이 있습니다.
- 서비스 탐색 기능을 구현하는 데 널리 쓰이는 오픈 소스 솔루션으로는 아파치 주키퍼(Apache Zookeeper) 같은 것이 있습니다.

### 접속 장애

- 온라인 상태의 클라이언트로 하여금 주기적으로 방동 이번트를 접속상태 서버로 보내도록 하고, 마지막 이벤트를 받은 지 x초 이내에 또 다른 박동 이벤트 메시지를 받으면 해당 사용자의 접속상태를 계속 온라인으로 유지합니다.

### 상태 정보의 전송

- 사용자가 그룹 채팅에 입장하는 순간에만 상태 정보를 읽어가게 하거나, 친구 리스트에 있는 사용자의 접속상태를 갱신하고 싶으면 수도응로 하도록 유도합니다.

## 마무리

- 클라이언트와 서버 사이의 실시간 통신을 가능하도록 하기 위해 우베소켓을 사용하였으며, 실시간 메시징을 지원하는 채팅 서버, 접속 사애 서버, 푸시 알림 서버, 채팅 이력을 보관할 키-값 저장소, 그리고 이를 제외한 나머지 기능을 구현하는데 쓰일 API 서버 등이 주요 컴포넌트입니다.

### 더 고민해 볼 점들

- 채팅 앱을 확장하여 사진이나 비디오 등의 미디어를 지원하는 방법
- 종단 간 암호화
- 캐시
- 로딩 속도 개선
- 오류 처리

---

## 참고

- [가상 면접 사례로 배우는 대규모 시스템 설계 기초](http://www.kyobobook.co.kr/product/detailViewKor.laf?mallGb=KOR&ejkGb=KOR&barcode=9788966263158)
