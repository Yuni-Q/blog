---
title: 4장 두다형성의 만남
date: 2024-08-02 11:08:32
category: 타입으로 견고하게 다형성으로 유연하게
tags: []
draft: true
---

## 4.1 제네릭 클래스와 상속

```ts
abstract class List<T> {
  abstract get(idx: number): T;
}
class ArrayList<T> {
  get(idx: number): T {
    // ...
  }
}
class BitVector {
  get(idx: number): boolean {
    // ...
  }
}
let l1: List<string> = new ArrayList<string>();
let l2: List<boolean> = new ArrayList<boolean>();
let l3: List<boolean> = new BitVector();
```

- 구조에 의한 서브타입을 사용하므로 각 타입이 가지고 있는 필드와 메서드를 고려해 서브타입 여부를 판단한다.
- List<string>이 가지고 있는 get 메서드와 동일한 시그니처의 메서드를 ArrayList<string>도 가지고 있으므로 ArrayList<string>은 List<string>의 서브타업이다. 같은 원리로, ArrayList<boo1ean>과 BitVector는 List<boo1ean>의 서브타입이다.

## 4.2 타입 매개변수 제한

- 타입 매개변수 제한을 사용한 제네릭 함수를 사용할 때는 정의된 상한을 타입 인자가 따라야 한다.
- 일부 언어에서는 타입 매개변수 제한 시에 상한뿐 아니라 하한(Lower bound)을 지정하는 것도 허용한다.
- 상한이 많은 경우에 유용한 것과 달리 하한이 필요한 경우는 드물다. 그렇기에 상한만 지정할 수 있고 하한은 지정할 수 없는 언어도 있다.

### 재귀적 타입 매개변수 제한

- 타입 매개변수가 자기 자신을 제한하는 데 사용될 수 있다.

```ts
abstract class Comparable<T> {
  abstract gt(that: T): boolean;
}

function sort<T extends Comparable<T>>(list: Array<T>): void {
  if (list[0].gt(list.get[1])) {
    //
  }
}

class Person extends Comparable<Person> {
  age: number;
  gt(that: Person): boolean {
    return this.age > that.age;
  }
}

const people: Array<Person> = [];
sort<Person>(people);
```

## 4.3 가변성

- 가변성은 하나의 제네릭 타입에서 타입 인자만 다르게 하여 얻은 타입들 사이의 서브 타입 관계를 만든다.

### 가변성에는 공변, 불변, 반변 세 종류가 있다

1. 가변성은 제네릭 타입이 타입 인자의 서브타입 관계를 보존하는 것이다.

- 제네릭 타입이 타입 인자와 `함께 변한다`는 뜻을 담아, 이런 가변성을 `공변(covariance)`이라고 부른다.

2. 가변성은 제네릭 타입이 타입 인자의 서브타입 관계를 무시하는 것이다.

- 타입 인자가 서브타입으로 변해도 제네릭 타입은 서브타입으로 `안 변한다`는 뜻으로서, 이런 가변성을 `불변(invariance)`이라 부른다.

3. 가변성은 제네릭 타입이 타입 인자의 서브타입 관계를 뒤집는 것이다

- 함수타입의 매개변수 타입이 이렇다.
- 제네릭 타입이 타입 인자와 `반대로 변한다`는 의미를 담아 이런 가변성을 `반변(contravariance)`이라고 부른다
- 함수 타입은 `매개변수 타입에 대해서는 반변`이고 `결과 타입에 대해서는 공변`이다.

4.  가변성의 네 번째 종류로서 양변 (bivariance)을 이야기하는 사람도 있다.

- 양변은 `양쪽으로 변한다`는 뜻으로, 타입 인자가 서브타업으로 바뀔 때 제네릭 타입이 서브타입으로 바뀌는 동시에 슈퍼타입으로 바뀜을 의미한다. 다시 말해 G가 양변인 제네릭 타업이라면, B가 A의 서브타입얼 때 G<B>는 G<A>의 서브타입이면서 슈퍼타엽이다. 양변이 유용한 경우는 드물기 때문에 이 책에서는 자세히 다루지 않는다.

### 제네릭 타입의 이름은 G, 타입 매개변수의 이름은 T라고 하자.

- G가 T를 출력에만 사용하면 공변, 입력에만 사용하면 반변, 출력과 입력 모두에 사용하면 불변이다.
  - 객체가 값을 출력하려면 메서드에서 그 값을 반환해야 한다. T를 출력에 사용한다는 말은 `메서드의 결과 타입이 T`라는 뜻이다.
  - 객체가 값을 입력받으려면 그 값을 메서드의 인자로 받아야 한다. T를 입력에 사용한다는 말은 `메서드의 매개변수 타입이 T`임을 의미한다.

| 출력 | 입력 | 가변성 |
| ---- | ---- | ------ |
| O    | X    | 공변   |
| O    | O    | 불변   |
| X    | O    | 반변   |

### 타입 검사기의 서브타입 판단 방법이 두 가지인 것처럼 가변성 판단 방법 역시 두 가지다.

- 하나는 개발자가 `제네릭 타입을 정의할 때 가변성을 지정(declaration-site variance)`하도록 한 뒤 그에 따르는 것이고, 다른 하나는 `사용할 때 가변성을 지정(use-site variance)`하도록 한 뒤 그에 따르 는 것이다

### 정의할 때 가변성 지정하기

- 가변성은 각 제네릭 타업의 고유한 속성이다. 따라서 제네릭 타입을 정의할 때 가변성을 지정하는 게 가장 직관적이다. 개발자는 제네릭 타입의 각 타입 매개변수에 가변성을 표시함으로써 공변, 반변, 불변 중 하나를 고를 수 있다.
  - 아무런 표시도 붙이지 않을 경우 기본으로 불변이 선택된다.
  - 특정 타입 매개변수를 공변으로 만들려면 그 타입 매개변수 앞에 out을 붙여야 한다.
  - 타입 매개변수를 반변으로 만들고 싶을 때는 out 대신 in을 붙인다.
- 정의할 때 가변성을 지정하는 방법은 이해하기 쉬운 대신 클래스를 정의할 때 큰 제약이 생긴다는 문제가 있다.
  - 서브타입 관계를 추가하는 대신 기능이 빠진 타입을 만들거나, 기능을 다 갖춘 타입을 만드는 대신 서브타입 관계를 포기하거나. 개발지는 반드시 이 둘 중 하나를 골라야 한다.
  - immutable한 경우에는 타입 매개변수의 하한을 지정하면 해결할 수도 있지만 만족스럽지 않다.

```ts
class Person {}
class Student {
  grade: number;
}
class ReadOnlyList<T> {
  list = [];
  get: (index: number) => T = (idx) => {
    return list[index];
  };
}
class Map<T, S> {
  get: (t: T) => S;
  add: (t: T, s: S) => void;
}

let l: ReadOnlyList<Person> = new ReadOnlyList<Student>();
let m: Map<Student, number> = new Map<Person, number>();
```

- 구조에 의한 서브타입을 사용하므로 가변성을 명시적으로 지정할 필요가 없다. 타입 검사기가 매번 타입에 정의된 필드와 메서드를 고려해 서브타입 여부를 결정함으로써 자연스럽게 가변성을 알아낸다.

### 사용할 때 가번성 지정하기

- 제네릭 타입을 사용할 때 가변성을 지정하는 경우, 제네릭 타입을 정의 할때는 가변성을 지정할 수 없다. 모든 제네릭 타입은 불변으로 정의 되며 타입 매개변수를 아무 데서나 사용할 수 있다. 따라서 제약 없이 리스트를 만드는 것이 가능하다.
- List<A>는 List<out A>의 서브타입 이다.
  - 이런 타입들은 제네릭 타입을 공변이나 반변으로 만드는 대신 기존 제네릭 타입보다 적은 기능을 제공한다.
  - 더 나아가 서브타입 관계에는 일종의 연쇄 작용이 발생한다 C가 B의 서브타입이고 B가 A의 서브타입이 면 C는 A의 서브타입이기도 하다.
- 제네릭 타입을 사용할 때 가변성을 지정하면 제네릭 타입을 자유롭게 정의할 수 있다. 제네릭 타입을 정의할 때 가변성을 지정하면 생기는 문제점을 말끔히 해결한 것이다. 또한 공변이나 반변이 필요한 경우에는 타입 인자에 out이나 in을 붙이기만 하면 되니 원하는 가변성을 여전히 쉽게 선택해 사용할 수 있다.
