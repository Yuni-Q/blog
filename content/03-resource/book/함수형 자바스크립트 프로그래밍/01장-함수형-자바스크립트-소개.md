---
title: 01장 함수형 자바스크립트 소개
date: 2022-12-06 23:12:59
category: 함수형 자바스크립트 프로그래밍
tags: []
draft: true
---

- 함수형 프로그래밍은 성공적인 프로그래밍을 위해 부수 효과를 최대한 멀리하고 조합성을 강조하는 프로그래밍 패러다임이다.
  - 좋은 프로그램의 척도에는 사용성, 성능, 확장성, 기획 변경에 대한 대응력 등이 있으며, 이것들을 효율적이고 생산적으로 이루는 일이 성공적인 프로그래밍이다.
  - 부수효과를 줄이는 이유는 오류를 줄이기 위해서고, 또 하나는 조합성 혹은 모듈화 수준을 높이기 위해서이다.

## 1.1 함수형 프로그래밍 그거 먹는 건가요?

### 1.1.1 함수형 자바스크립트를 검색하면 나오는 예제

```ts
const addMaker = (a: number) => {
  return (b: number) => {
    return a + b;
  };
};
addMaker(10)(5);
```

- 함수를 값으로써 다룬다.

### 1.1.2 값으로써의 함수와 클로저

- 함수는 값을 리턴할 수 있고 함수는 값이 될 수 있다.

## 1.2 함수형 자바스크립트의 실용성

### 1.2.1 회원 목록 중 여러명 찾기

### 1.2.2 for에서 filter로 if에서 predicate로

```ts
const filter = <T>(list: T[], predicate: (item: T) => boolean): T[] => {
  const newList = [] as T[];
  for (let i = 0; i < list.length; i++) {
    if (predicate(list[i])) newList.push(list[i]);
  }
  return newList;
};
```

- filter 함수는 predicate 함수 내부에서 어떤 일을 하는지 모른다.
- 이전 값의 상태를 변경하지 않고(조건에 맞지 않는 값을 지운다거나 하지 않고) 새로운 값을 만드는 식으로 값을 다루는 것은 함수형 프로그래밍의 매우 중요한 콘셉트 중 하나다.

### 1.2.3 함수형 프로그래밍 관점에서 filter 보기

- filter 함수는 동일한 인자가 들어오면 항상 동일하게 동작한다. 외부나 내부의 어떤 상태 변화에도 의존하지 않는다.
- 함수형 프로그래밍에서는 `항상 동일하게 동작하는 함수`를 만들고 보조 함수를 조합하는 식으로 로직을 완성한다. 내부에서 관리하고 있는 상태를 따로 두지 않고 넘겨진 인자에만 의존한다.
  - 절차지향 프로그래밍에서는 위에서 아래로 내려가면서 특정 변수에 값을 변경해 나가는 식으로 로직을 만든다.
  - 객체지향 프로그래밍에서는 객체들을 만들어 놓고 객체들 간의 협업을 통해 로직을 만든다. 이벤트 등으로 서로를 연결한 후 상태의 변화를 감지하여 스스로 자신이 가진 값을 변경하거나, 상대의 메서드를 직접 실행하여 상태를 변경하는 식으로 프로그래밍 한다.
- 객체지향적으로 작성된 코드에서도 이전 객체와 같은 상태를 지닌 새 객체를 만드는 식으로 부수 효과를 줄일 수 있다. 그러나 무수히 많고 각기 다른 종류로 나누어진 객체들을 복사하는 식으로 다루는 것은 운용도 어렵고 객체지향과 어울리지 않는다. 자신의 상태를 메서드를 통해 변경하는 것은 객체지향의 단점이 아니라 객체지향의 방법론 그 자체이다. 반면에 함수형 프로그래밍은 부수 효과를 최소화하는 것이 목표에 가깝다.
- 함수형 프로그래밍은 객체지향과 함꼐 동작해야 한다. 현대 프로그래밍에서 다루는 값은 대부분 객체이므로 함수형 프로그래밍에서도 결국 객체를 다뤄야 한다.

### 1.2.4 map 함수

```ts
const map = <T, R>(list: T[], iteratee: (item: T) => R): R[] => {
  const newList = [] as R[];
  for (let i = 0; i < list.length; i++) {
    newList.push(iteratee(list[i]));
  }
  return newList;
};
```

### 1.2.5 실행 결과로 바로 실행하기

- 함수의 리턴값을 바로 다른 함수의 인자로 사용하면 변수 할당을 줄일 수 있다.

### 1.2.6 함수를 값으로 다룬 예제의 실용성

- 코드가 간결해 진다.

## 1.3 함수형 자바스크립트의 실용성 2

### 1.3.1 회원 목록 중 한명 찾기

```ts
const findBy = <T>(key: string, list: T[], val: unknown): T | undefined => {
  for (let i = 0; i < list.length; i++) {
    if (list[i][key] === val) return list[i];
  }
  return undefined;
};
```

- findBy 함수는 key로 value를 얻을 수 있는 객체들을 가진 배열이라면 무엇이든 받을 수 있다.

#### 문제점

- key가 아닌 메서드를 통해 값을 얻어야 할 때
- 두 가지 이상의 조건이 필요할 때
- `===`이 아닌 다른 조건으로 찾고자 할 때

### 1.3.2 값에서 함수로

- 인자로 키와 값 대신 함수를 사용해 보자.

```ts
const find = <T>(list: T[], predicate: (item: T) => boolean): T | undefined => {
  for (let i = 0; i < list.length; i++) {
    if (predicate(list[i])) return list[i];
  }
};
```

- 함수형 자바스크립트는 `다형성`이 높은 기법을 많이 사용하며 이러한 기법은 정말 실용적이다.
- filter, map, find 함수들은 들어온 데이터가 무엇이든지 루프를 돌리거나 분기를 만들거나 push를 하거나 predicate를 실행하거나 등의 자기 할 일을 한다. 들어온 데이터의 특성은 보조 함수가 대응해 주기 때문에 find 함수는 데이터의 특성에서 완전히 분리될 수 있다. 이러한 방식은 다형성을 높이며 동시에 안정성도 높인다.
- 객체지향 프로그래밍이 약속된 이름이ㅡ 메서드를 대신 실행해 주는 식으로 외부 객체에게 위임한다면, 함수형 프로그래밍은 보조 함수를 통해 완전히 위임하는 방식을 취한다. 이는 더 높은 다형성과 안정성을 보장한다.

### 1.3.3 함수를 만드는 함수와 find, filter 조합하기

- 작은 기능을 하는 함수로 쪼개거나 재조합하는 식으로 코드를 발전시키는 것도 좋은 방법이다.

> 함수형 프로그래밍에서는 함수를 쪼개고 재조합하는 것이 메인인 듯 하다.

### 1.3.4 고차 함수

- 고차 함수란, 함수를 인자로 받거나 함수를 리턴하는 함수를 말한다. 보통 고차 함수는 함수를 인자로 받아 필ㅇㅅ한 때에 실행하거나 클로저를 만들어 리턴한다.

> 고차 함수를 쓰는 것이 함수형 프로그래밍인가에 대해 고민해 보면 좋을거 같다.

### 1.3.5 function identity(v) { return v; }, 이건 어디다 쓰는 거자?

- _.filter를 _.identity와 함께 사용했더나 Truthy Value(Boolean)으로 평가했을 때 true로 평가되는 값들)만 남는다.

> 함수형 프로그래밍은 이러한 함수들의 조합으로 유의미한 구조를 만들어 가는거 같다.

### 1.3.6 연산자 대신 함수로

```ts
const not = <T>(v: T): boolean => {
  return !v;
};
const beq = <T>(a: T) => {
  return function (b: T): boolean {
    return a === b;
  };
};

_.some = <T>(list: T[]): boolean => {
  return !!(_.find(list, _.identity) as T | undefined);
};
__.every = <T>(list: T[]): boolean => {
  return beq(-1)(_.findIndex(list, not) as number);
};
```

- not과 beq를 만듦으로 인해서 루프를 끝까지 돌지 않는다.
- not은 연자가 !가 아닌 함수이기 때문에 \_.indexIndex와 함께 사용할 수 있다.
- \_.every는 쓸모 없어 보이는 정말 작은 함수 not 덕분에 로직이 개선 되었다.

> 루프를 끝까지 돌지 않는 것은 유의미해 보인다.

### 1.3.7 함수 합성

- 함수를 쪼갤수록 합성은 쉬워진다.
- \_.compose는 오른쪽의 함수의 결과를 바로 왼쪽의 함수로 전달한다. 그리고 해당 함수 결과를 다시 자신의 왼쪽의 함수에게 전달하는 고차 함수다.

> compose 또한 함수형 프로그래밍을 하는데 있어서 루프를 끝까지 돌지 않는 것과 더불어 중요한 포인트라고 생각한다.

- 짧고 읽기 좋은 코드도 중요한 가치이지만 좀 더 고상한 이점이 있다. 인자 선언이나 변수 선언이 적어진다. 새로운 상황이 생기지 않는다는 것은 개발자가 예측하지 못할 상황이 없다.
- 작게 쪼개다 보면 정말 쓸모 없어 보이는 함수가 많이 나오기도 한다. 그래도 더 작은 단위로 쪼개 보라. 재사용성이 높고 재밌는 코드들이 나올 것이다.

> 작게 쪼개는 것이 포인트 인 듯 하다.

## 1.4 함수형 자바스크립트를 위한 기초

- 일급 함수, 클로저, 고차 함수, 콜백 패턴, 부분 적용, arguments 다루기, 함수 객체의 메서드(bind, call, apply)등의 개념을 알아야 한다.

### 1.4.1 일급 함수

- 자바스크립트에서 함수는 일급 객체이자 일급 함수다.
  - 변수에 담을 수 있다.
  - 함수나 메서드의 인자로 넘길 수 있다.
  - 함수나 메서드에서 리턴할 수 있다.
- 자바스크립트에서 모든 값은 일급이다. 자바스크립트에서 모든 객체는 일급 객체이며 함수도 객체이자 일급 객체다.
  - 아무 대나(런타임에서도) 선언이 가능하다.
  - 익명으로 선언할 수 있다.
  - 익명으로 선언한 함수도 함수나 메서드의 인자로 넘길 수 있다.
- 함수로 기능을 동작시키는 것은 만들어 둔 클래스의 인스턴스를 생성하고 다루면서 기능을 동작시키는 것보다 간단하고 쉽다.

### 1.4.2 클로저

- 스코프란 변수를 어디에서 어떻게 찾을지를 정한 규칙으로, 여기서 다루는 스코프는 함수 단위의 변수 참조에 대한 것이다.
  - 클로저는 자신이 생성될 때의 환경을 기억하는 함수다.
  - 클로저는 자신이 생성될 때의 스코프에서 알 수 있었던 변수를 기억하는 함수다.
  - 클로저가 기억할 환경이라는 것은 외부의 변수들밖에 없다.
  - 클로저는 자신이 생성될 때의 스코프에서 알 수 있었던 변수 중 언젠가 자신이 실행될 때 사용할 변수들만 기억하여 유지시키는 함수다.
  - 클로저는 자신이 생성되는 스코프의 실행 컨턱스트에서 만들어졌거나 알 수 있었던 변수 중 언젠가 자신이 실행될 때 사용할 변수들만 기억하는 함수다. 클로저가 기억하는 변수의 값은 언제든지 남이나 자신에 의해 변경될 수 있다.

### 1.4.3 클로저의 실용 사례

- 이전 상황을 나중에 일어날 상황과 이어 나갈 때
- 함수로 함수를 만들거나 부분 적용을 할 때
- 함수형 프로그래밍은 서로 다른 실행 컨텍스트에 영향을 줄 수 있을 만한 상태 공유나 상태 변화를 만들지 안흔ㄴ 것이 목표에 가깝고, 이런 함수형 프로그래밍의 특성은 `흔한 클로저 실수`와 같은 문제들을 애초에 차단한다.

### 1.4.4 클로저를 많이 사용하라!

- 서로 분리된 컨텍스트나 객체를 클로저를 통해 쉬운 개념으로 이어줄 수 있다는 것은 너무나도 강력하고 아름답다.

### 1.4.5 고차 함수

- 함수를 인자로 받아 대신 실행하는 함수
- 함수를 리턴하는 함수
- 함수를 인자로 받아서 또 다른 함수를 리턴하는 함수

#### 참고

- 함수형 프로그래밍은 함수에 인자를 언제 어떻게 적용할 것인가, 함수를 인자로 언제 어떻게 적용할 것인가, 인자로 받은 함수를 언제 어디서 평가할 것인가 대한 이야기이기도 하다.
- 응용형 함수, 부분 적용(partial application), 커링, 고차함수 등은 모두 인지와 관련한 함수형 프로그래밍의 특징들이다.
- 많은 함수를 만들고 조합하고 연속적으로 실행하고 응용(applicative)하면서, 점진적으로 사람이 이해하기 좋은 함수들로 발전시켜 나간다.

#### 추가 내용

- 변수를 선언하는 대신 , 함수의 요소인 인자를 활요하여 더 많은 가능성을 연다.
- 함수로 함수를 실행하는 기법과 함수로 만드는 기법이 있다는 것을 잘 익혀 두고, 함수를 실행 하는 것 외에도 다루는 기법이 있음을 기억하자.

### 1.4.6 콜백 함수라 잘못 불리는 보조 함수

- 컨텍스트를 다시 돌려주는 역할을 가졌기 때문에 callback이라고 함수 이름을 지은 것이다.
- 콜백은 종료 되었을 때 단 한번 실행 되지만 listener, iteratee, predicate 등은 종료 될 대 실행되지 않으며 상황에 따라 여러 번 실행되기도 하고 각각 다른 역할을 한다.

### 1.4.7 함수를 리턴하는 함수와 부분 적용

- `기억하는 인자 혹은 변수가 있는 클로저`를 리턴한다.

## 1.5 정리

- 함수를 아무 때나 아무 데서나 정의하고 사용해 보라. 자연스럽게 값으로서의 함수가 가진 가능성을 발견하게 될 것이다.
- 클로저를 마음껏 사용해 보라. 켄텍스트를 내 맘대로 제어할 수 있게 될 것이다.
- 특정 방법론이나 프레임워크의 제약에서 벗어나 언어 자체의 기능을 다양하게 사용해 보라. 언어에 대한 기초를 단단하게 해주고 응용력을 길러줄 것이다.
- 이렇게 쌓은 기본들은 큰 규모의 소프트웨어를 만들고 지탱할 기반이 된다.
