---
title: CHAPTER14. 중첩된 데이터에 함수형 도구 사용하기
date: 2023-03-15 15:03:40
category: 쏙쏙 들어오는 함수형 코딩
tags: ['PART II 일급 추상']
draft: true
---

## 이번 장에서 살펴볼 내용

- 해시 맵에 저장된 값을 다루기 위한 고차 함수를 만듭니다.
- 중첩된 데이터를 고차 함수로 수비게 다루는 방법을 배웁니다.
- 재귀를 이해하고 안전하기 재귀를 사용하는 방법을 살펴봅니다.
- 깊이 중첩된 엔티티에 추상화 벽을 적용해서 얻을 수 있는 장점을 이해합니다.

## 필드명을 명시적으로 만들기

- 함수 이름에 있는 암묵적 인자를 암묵적 인자를 드러내기 리팩터링으로 앲앱니다. 리팩터링 후에도 increment, decrement, double, halve처럼 비슷한 동작이 있으 수 있스빈다. 목적은 다르지만 비슷한 동작을 합니다. 여기에도 암묵적 인자를 드러내기 리팩터링을 적용합니다.

## 리팩터링: 조회하고 변경하고 설정하는 것을 update로 교체하기

### nestedUpdate

```js
function nestedUpdate(object, keys, modify) {
  if (keys.length === 0) modify(object);
  const [key1, nestOfKeys] = keys;
  return update(object, key1, function (value1) {
    return nestedUpdate(object, nestOfKeys, modify);
  });
}
```

## 안전한 재귀 사용법

- 1. 종료 조건
- 2. 재귀 호출
- 3. 종료 조건에 다가가기
  - 재귀 호출에 같은 인자를 그대로 전달하는 것은 좋지 않습니다. 이렇게 하면 무한 반복에 빠질 가능성이 높아집니다.

## 요점 정리

- update()는 일반적인 패턴을 구현한 함수형 도구입니다. update()를 사용하면 객체 안에서 값을 꺼내 변경하고 다시 설정하는 일을 수동으로 하지 않아도 됩니다.
- nestedUpdate()는 깊이 중첩된 데이터를 다루는 함수형 도구입니다. 바꾸려고 하는 값이 어디 있는지 가리키는 키 경로만 알면 중첩된 데이터를 쉽게 바꿀 수 있습니다.
- 보통 일반적인 반복문은 재귀보다 명확합니다. 하지만 중첩된 데이터를 다룰 때는 재귀가 더 쉽고 명확합니다.
- 재귀는 스스로 불렀던 곳이 어디인지 유지하기 위해 스택을 사용합니다. 재귀 함수에서 스택은 중첩된 데이터 구조를 그대로 반영합니다.
- 깊이 중첩된 데이터는 이해하기 어렵습니다. 깊이 중첩된 데이터를 다룰 때 모든 데이터 구조와 어떤 경로에 어떤 키가 있는지 기억해야 합니다.
- 많은 키를 가지고 있는 깊이 중첩된 구조에 추상화 벽을 사용하면 알아야 할 것이 줄어듭니다. 추상화 벽으로 깊이 중첩된 데이터 구조를 쉽게 다룰 수 있습니다.

---

## 참고

- [쏙쏙 들어오는 함수형 코딩](https://product.kyobobook.co.kr/detail/S000001952246)
