---
title: CHAPTER1 소프트웨어 엔지니어링이란?
date: 2023-08-13 14:08:59
category: 구글 엔지니어는 이렇게 일한다
tags: ['PART1 전제']
draft: true
---

- 프로그래밍과 소프트웨어 엔지니어링의 가장 큰 차이는 시간, (규모) 확장, 실전에서의 트레이드오프, 이렇게 세 가지라고 생각합니다.
  - 시간의 흐름과 언젠가 변경될 가능성에 더 신셩 써야 합니다.
  - 프로그래밍(개발)
  - 소프트웨어 엔지니어링(개발 + 수정 + 유지보수)
- `지속 가능성`: 기술적인 이유든 사업적인 이유든, 소프트웨어의 기대 생애 동안 요구되는 모든 가치 있는 변경에 대응할 수 있다면 '그 프로젝트는 지속 가능하다'라고 말합니다.
- 소프트웨어 엔지니어링과 프로그래밍은 시간과 참여 인원 면에서 차이가 납니다. 협업은 그 자체로 새로운 문제를 유발하지만, 한 명이 개발하는 것보다 가치 있는 시스템을 만들어낼 잠재력 또한 지닙니다.

## 1.1 시간과 변경

### 1.1.1 하이럼의 법칙

- 하이럼의 법칙: API 사용자가 충분히 많다면 API 명세에 적힌 내용은 중요하지 않습니다. 시스템에서 눈에 보이는 모든 행위(동작)를 누군가는 이용하게 될 것이기 떄문입니다.
  - 소프트웨어 유지보수에 하이럼의 법칙이 적용된다고 해서 계획 세우기를 등한시하거나 소프트웨어를 더 잘 이해하려는 노력을 포기해서는 안 됩니다. 문제를 완벽히 제거할 수는 없더라도 완화할 수 있기 때문입니다.
  - 노출 시간이 길어지고 사용자가 늘어나면 갖아 무해할 듯한 변경도 일부 사용자의 소프트웨어를 망가뜨릴 수 있습니다. 따라서 변경이 얼마나 유용할지 분석할 때는 이러한 충돌을 조사, 식별, 해결하는 데 따르는 비용도 고려해야 합니다.

### 1.1.2 사례: 해시 순서

#### 프로그래밍 스타일

1. 이용하는 API의 명세에 명시되지 않은, 즉 언제든 변할 수 있는 기능을 사용하는 코드는 '임시방편적인' 혹은 '기발한' 코드입니다.
2. 반대로 모범 사례를 딸고 미래에 대비한 '클린'하고 '유지보수 가능한' 코드입니다.

- 우리는 '기발한'이 칭찬으로 느껴진다면 프로그래밍이라 하고, 질책으로 느껴진다면 소트트웨어 엔지니어링이라 말합니다.

### 1.1.3 '변하지 않기'를 목표로 하지 않는 이유

- 시간과 변경에 대처해야 하는 이유에 관한 이 모든 논의의 밑바탕에는 '변경은 피할 수 없다'라는 가정이 깔려 있습니다.
- 이전 시스템에 문제가 없더라도 시간이 흐르면 변경을 진행할 이유가 자연스럽게 만들어지기도 합니다.
- 변경은 본질적으로 좋지 않으므로 변경을 위한 변경은 삼가야 하지만 변화에 대응할 수는 있어야 합니다.
- 시스템 관리자는 백업 테이프가 있다는 사실뿐 아니라, 실제로 상황이 닥쳤을 때 복구를 정확히 어떻게 수행하는지와 그 비용까지 알고 있어야 합니다. 연습하여 숙달시켜야만 효율과 안정성을 높일 수 있음을 명심해야 합니다.

## 1.2 규모 확장과 효율성

- 코드베이스의 수명이 다할 때까지 직면하는 변화가 몰고 오는 모든 변경을 안전하게 처리할 수 있다면 그 코드베이스는 지속 가능할까요? 이 풀이에는 비용이라는 요소가 숨어 있습니다. 변경 비용이 시간 흐름보다 가파르게 상승하는 시스템은 분명 확장 가능하지 않습니다. 시간이 흐르다 보면 결국은 예상치 못한 일이 발생하여 변경이 불가피한 시점이 올 것 입니다.
- 조직에서 코드를 작성하고 관리하는 데 활용되는 모든 것이 총비용과 자원 소비 측면에서 확장 가능해야 합니다. 특히 반복적으로 수행하는 일이라면 모두 인적 비용 측면에서 확장 가능해야 합니다.

### 1.2.1 확장하기 어려운 정책들

- 마이그레이션 작업을 사용자에게 떠넘기는 대신 시스템 담당 팀 내부에서 스스로 처리 할 수 있도록 하는 것입니다. 그러면 사용자가 많아져도 노하우를 축적한 하나의 팀이 모두 처리하므로 규모의 경제 효과도 누릴 수 있습니다.
- 갈아타기 규칙(Churn Rule): 인프라팀은 사내 사용자들이 새 버전을 옮기도록 돕거나 직접 업데이트하되, 하위 호환성을 유지해야 합니다.

### 1.2.2 확장 가능한 정책들

- 비욘세 규칙: '인프라를 변경하여 서비스가 중단되는 등의 문제가 발생하더라도, 같은 문제가 지속적인 통합(CI) 시스템의 자동 테스트에서 발견되지 않는다면 인프라팀의 책임이 아니다'라는 정책

### 1.2.3 사례: 컴파일러 업그레이드

- 문제를 극복할 기술을 찾고 조직을 변화 시켜서 큰 규모가 장점이 되기 위한 노력
  - 자동화(한 사람이 더 많은 일을 수행)
  - 통합과 일관성(저수준 변경이 영향을 미치는 범위 제한)
  - 전문성(적은 인원으로 더 많은 일을 수행)
- 인프라는 더 자주 변경할수록 변경하기가 오히려 쉬워집니다.

#### 코드 베이스의 유연성에 영향을 주는 요인

- 전문성: 여러 방법에 대한 충분한 지식이 있었습니다. 몇 가지 언어에 대해 구글은 이미 수많은 플랫폼에서 숩개 번의 컴파일러 업그레이드를 성공적으로 마쳤습니다.
- 안정성: 더 규칙적으로 릴리스하여 릴리스 사이의 변경량을 줄였습니다. 몇 가지 언어에 대해서는, 구글은 한두 주 간격으로 새로운 컴파일러를 배포합니다.
- 순응: 업그레이드를 겪지 않은 코드가 많지 않습니다. 규칙적인 업그레이드가 도움이 되었습니다.
- 익숙함: 업드레이드를 정기적으로 수행하기 때문에 그 과정에서 중복되는 작업을 찾고 자동화하려고 노력합니다. 많은 면에서 사이트 신뢰성 엔지니어(SRE)가 삽질을 줄이는 관점과 일맥상통합니다.
- 정책: 비욘세 규칙과 같은 유용한 정책과 절차를 갖춥니다. 이러한 정책들 덕분에 인프라팀은 미지의 사용 방법까지 걱정할 필요 없이 업그레이드를 진행할 수 있습니다. CI 시스템에 반영된 사용법만 고민하면 됩니다.

### 1.2.4 원점 회귀(왼쪽으로 옮기기)

- 문제를 일찍 발견할수록 비용이 적게 듭니다.
- 원점 회귀: 보안성 점검을 개발 프로세스 마지막으로 연기하면 안 된다고 호소하며 '보안을 고려하는 시점을 왼쪽으로 이동시켜라'라고 한 말에서 유래한 듯합니다.

## 1.3 트레이드오프와 비용

- 비용: 금액만을 지칭하는 게 아니라 투입된 노력과 다음의 요소들까지 모두 포괄합니다.
  - 금융 비용(ex. 돈)
  - 리소스 비용(ex. CPU 시간)
  - 인적 비용(ex. 엔지니어링 노력)
  - 거래 비용(ex. 조치를 취하는 비용)
  - 기회 비용(ex. 조치를 취하지 않는 비용)
  - 사회적 비용(ex. 선택이 사회 전체에 미치는 영향)

### 1.3.1 사례: 화이트보드 마커

- 좋은 엔지니어링적 결정이란 결국 가용한 모든 근거 자료에 적절한 가중치를 부여하고, 이러한 풍부한 지식을 바탕으로 균형점을 잡는 일입니다. 때로는 본능과 잘 알려진 모범 사례에 의지해 결정하기도 하지만, 보통은 실제 비용을 추정하고 예측해보려 시도해본 뒤에 그렇게 합니다.
- 엔지니어링 조직의 선택을 결정짓는 요인
  - 반드시 해야 하는 일(법적 요구사항, 고객 요구사항)
  - 근거에 기반하여 당시 내릴 수 있는 최선의 선택(적절한 결정권자가 확정)

### 1.3.2 의사결정을 위한 근거 자료

- 근거 자료를 가중치로 정하는 시나리오
  - 관련한 정략적 데이터를 모두 '측정'할 수 있거나 최소한 '추정'이라고 할 수 있는 경우
  - 측정하기 어렵거나 측정 방법을 모르는 정략적 데이터도 있습니다. 떄로는 '엔지니어 시간이 얼마나 들지 모르겠다'라는 표현으로, 때로는 더 모호하게 표현되곤 합니다.

### 1.3.3 사례 분산 빌드

- '효율이 좋아지면 자원 소비가 늘어난다'는 말처럼 분산 빌드 시스템을 도입하여 절약한 비용이 시스템을 구축하고 유지보수하는 데 드는 부정적인 비용보다 훨씬 컸으나 자원 소비가 많아지는 걸 눈으로 보면서도 어느 정도 까지 치솟을지 예측하지 못했습니다.

### 1.3.4 사례: 시간과 규모 확장 사이에서 결정하기

- 프로젝트의 수명이 짧다면 포크해도 위험이 적습니다. 포크한 코드의 영향 범위가 제한적인 게 확실 할 때도 포크하는게 유리할 것입니다.
- 데이터 구조, 직렬화 포맷, 네트워크 프로토콜처럼 프로젝트의 수명에 종속되지 않는 인터페이스라면 포크를 피하는게 좋습니다.
- 일관성이 주는 가치는 아주 크지만, 범용적이게 만든느 비용도 만만치 않습니다.

### 1.3.5 결정 재고하기와 잘못 인정하기

- 잘 드러나지 않지만 잘못했음을 인정할 수 있게 해주는 능력 역시 데이터 중심 문화가 주는 커다란 장점입니다.
- 시간은 기술 의존성과 소프트웨어 시스템뿐 아니라 의사결정에 활용되는 데이터도 달라지게 하기 합니다.
  - 당시에는 옳았지만 지금은 아닐 수도 있습니다.
- `잘못을 인정할 줄 아는 리더가 더 존경받습니다`.

## 1.4 소프트웨어 엔지니어링 vs 프로그래밍

- 소프트웨어 엔지니어링, 프로그래밍의 차이는 대부분은 시간 흐름에 따른 코드 관리, 시간 흐름에 따른 규모 확장의 영향, 이런 관점에서 의사결정 방식에 있습니다.
  - 프로그래밍은 코드를 생산하는 즉각적인 행위입니다.
  - 소프트웨어 엔지니어링은 활용 가치가 남아 있는 한 오랫동안 코드를 유용하게 관리하고 팀 간 협업을 가능케 하는 정책, 관례, 도구 모두를 아우르는 종합적인 개념입니다.

## 1.5 마치며

- 이 책은 조직 혹은 개별 프로그래머를 위한 정책, 모범 사례를 평가하고 정의하는 방법, 관리 가능한 소프트웨어로 만들어주는 도구와 기술 관련 모든 주제를 다룹니다.
- 이 책이 '나의 코드가 마지막 필요한 순간까지 제대로 작동하게 하려면 어떻게 유지 관리해야 하는가?'라는 보편적인 질문의 답을 찾는 데 유용한 틀이 되기를 바랍니다.

## 1.6 핵심 정리

- 차원(고려해야 하는 주제의 큰 축)의 개수라는 점에서 '소프트웨어 엔지나어링'은 '프로그래밍'과 다릅니다.
  - 프로그래밍은 코드 생산에 관한 것입니다.
  - 반면 소프트웨어 엔지니어링은 프로그래밍을 확장하여 소프트웨어의 수명이 다할 때까지 코드를 유지보수히는 문제까지 고려합니다.
- 단명하는 코드와 장수하는 코드의 수명은 적어도 10만 배는 될 것입니다. 동일한 모범 사례를 수명 축의 양 끝단에 위치하는 두 프로젝트에 똑같이 적용하려는 건 너무 안일한 생각입니다.
- 코드의 기대 수명 동안 의존성, 기술 제품 요구사항 변경에 대응할 역량이 갖춰져야 지속 가능한 소프트웨어입니다. 여러 이유로 변경을 받아들이지 않기로 선택하더라도 변경할 수 있는 역량 자체는 펼요합니다.
- 하이럼의 법칙: API 사용자가 충분히 많다면 API 명세서에 적어놓은 내용은 중요하지 않게 됩니다. 시스템에서 눈에 보이는 모든 행위 (동작)를 누군가는 이용하게 됩니다.
- 조직에서 반복적으로 수행하는 모든 작업은 필요 인력 측면에서 확장 가능(선형 증가 혹은 그 이하)해야 합니다. 정책은 개발 프로세스를 확장 가능하게 해주는 아주 멋진 도구 입니다.
- 개발 프로세스를 포함한 소프트웨어 개발 업무의 많은 것의 효율은 눈치 채기 어렵게 천천히 나빠지는 경향이 있습니다. '끓는 물속의 개구리'가되지 않도록 주의합시다.
- 전문성은 규모의 경제와 결합될 때, 즉 조직이 커질수록 효과가 커집니다.
- '내가 시켰으니까'는 어떤 일을 수행하는 이유로는 아주 끔찍합니다.
- 의사결정을 데이터 주도로 하겠다는 생각은 좋은 출발입니다. 하지만 현실에서의 의사결정 대부분은 데이터, 가정, 선례, 논의를 종합하여 이루어집니다. 고려 요소의 대부분에 객관적인 데이터가 주어지면 가장 좋겠지만 순전히 데이터만으로 결정되는 경우는 드몹 니다.
- 데이터 주도 방식은 시간이 흘러 데이터가 변하면(혹은 가정이 무너지면) 프로젝트의 방향도 바뀔 수 있음을 뜻합니다. 잘못을 인정하고 계획을 수정하는 것은 당연한 일입니다.
