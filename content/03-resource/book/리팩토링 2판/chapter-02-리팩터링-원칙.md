---
title: CHAPTER 02 - 리팩터링 원칙
date: 2021-06-20 16:06:09
category: 리팩토링 2판
tags: []
draft: true
---

## 리팩터링 정의

- [명사] 소프트웨어의 겉보기 동작은 그대로 유지한 채, 코드를 이해하고 수정하기 쉽도록 내부 구조를 변경하는 기법입니다.
  - 함수 추출하기, 조건부 로직을 다형성으로 바꾸기
- [동사] 소프트웨어의 겉보기 동작은 그대로 유지한 채, 여러 가지 리팩터링 기법을 적용해서 소프트웨어를 재구성합니다.
- 동작을 보존하는 작은 단계들을 거쳐 코드를 수정하고, 이러한 단계들을 순차적으로 연결하여 큰 변화를 만들어내는 일입니다.
- 누군가 ‘리팩터링하다가 코드가 깨져서 며칠이나 고생했다’라고 한다면, 십중팔구 리팩터링한 것이 아닙니다.
- 리팩터링은 성능 최적화와 비슷합니다. 둘 다 코드를 변경하지만 프로그램의 전반적인 기능은 그대로 유지합니다. 하지만 리팩터링의 목적은 코드를 이해하고 수정하기 쉽게 만드는 것입니다. 프로그램 성능이 좋아질 수도, 나빠질 수도 있습니다.

## 리팩토링의 이점

- 리팩터링하면 소프트웨어 설계가 좋아집니다.
- 리팩터링하면 소프트웨어를 이해하기 쉬워집니다.
- 리팩터링하면 버그를 쉽게 찾을 수 있습니다.
- 리팩터링하면 프로그래밍 속도를 높일 수 있습니다.

## 언제 리팩터링해야 할까?

1. 처음에는 그냥 합니다.
2. 비슷한 일을 두 번째로 하게 되면(중복이 생겼다는 사실에 당황스럽겠지만) 일단 계속 진행합니다.
3. 비슷한 일을 세 번째 하게 되면 리팩터링합니다.

### 준비를 위한 리팩터링 : 기능을 쉽게 추가하게 만들기

- 리팩터링하기 가장 좋은 시점은 코드베이스에 기능을 새로 추가하기 직전입니다.
- 구조를 살짝 바꾸면 다른 작업을 하기 훨씬 쉬워질 만한 부분을 찾습니다.
- 준비를 위한 리팩터링으로 상황을 개선해놓으면 버그가 수정된 상태가 오래 지속될 가능성을 높이는 동시에, 같은 곳에서 다른 버그가 발생할 가능성을 줄일 수도 있습니다.

### 이해를 위한 리팩터링 : 코드를 이해하기 쉽게 만들기

- 코드를 수정하려면 먼저 그 코드가 하는 일을 파악해야 합니다. 코드를 파악할 때마다 그 코드의 의도가 더 명확하게 드러나도록 리팩터링 할 여지는 없는지 찾아봅니다.
- 조건부 로직의 구조가 이상하지 않은지 살펴보기도 하고, 함수 이름을 잘못 정해서 실제로 하는 일을 파악하는 데 시간이 오래 걸리지는 않는지도 살펴봅니다.
- 코드를 분석할 때 리팩터링을 해보면, 그렇지 않았더라면 도달하지 못했을 더 깊은 수준까지 이해하게 됩니다.

### 쓰레기 줍기 리팩터링

- 코드를 파악하던 중에 일의 비효율적으로 처리하는 모습을 발견할 때가 있습니다. 로직이 쓸데없이 복잡하거나, 매개변수화한 함수 하나면 될 일을 거의 똑같은 함수 여러 개로 작성해놨을 수 있습니다.
- 간단히 수정할 수 있는 것은 즉시 고치고, 시간이 좀 걸리는 일은 짧은 메모만 남긴 다음, 하던 일을 끝내고 나서 처리합니다.
- 조금이나마 개선해두는 것이 좋습니다.
- 캠핑 규칙이 제안하듯, 항상 처음 봤을 때보다 깔금하게 정리하고 떠나야합니다.
- 코드를 훑어볼 때마다 조금씩 개선하다 보면 결국 문제가 해결될 것입니다.
- 리팩터링의 멋진 점은 작은 단계가 코드를 깨드리지 않는다는 사실입니다. 작업을 잘게 나누면 몇 달에 걸쳐 진행하더라도 그 사이 한 순간도 코디가 깨지지 않기도 합니다.

### 계획된 리팩터링과 수시로 하는 리팩터링

- 보기 싫은 코드를 발견하면 리팩터링합니다. 그런데 잘 작성된 코드 역시 수많은 리팩터링을 거쳐야 합니다.
- 무언가 수정하려 할 때는 먼저 수정하기 쉽게 정돈하고(단, 만만치 않을 수 있습니다) 그런 다음 쉽게 수정합니다.
- 뛰어난 개발자는 새 기능을 추가하기 쉽도록 코드를 ‘수정’하는 것이 그 기능을 빠르게 추가하는 길일 수 있음을 압니다.
- 계획된 리팩터링을 하게 되는 일은 최소한으로 줄여야 합니다. 리팩터링 작업 대부분은 드러나지 않게, 기회가 될 때마다 해야 합니다.

### 오래 걸리는 리팩터링

- 팀 전체가 리팩터링에 매달리는 데는 회의적입니다. 그보다는 주어진 문제를 몇 주에 걸쳐 조금씩 해결해가는 편이 효과적일 때가 많습니다.
- 누구든지 래퍽터링해야 할 코드와 관련된 작업을 하게 될 때마다 원하는 방향으로 조금씩 개선하는 식입니다.
- 라이브러리를 교체할 때는 기존 것과 새 것 모두를 포용하는 추상 인터페이스부터 마련합니다. 기존 코드가 이 추상 인터페이스를 호출하도록 만들고 나면 라이브러리를 훨씬 쉽게 교체 할 수 있습니다(이 전략을 추상화 갈아타기라 합니다)

### 코드 리뷰에 리팩터링 활용하기

- 코드 리뷰를 정기적으로 수행하면 좋습니다.
- 리팩터링은 다른 이의 코드를 리뷰하는 데도 도움됩니다.
- 리팩터링은 코드 리뷰의 결과를 더 구체적으로 도출하는 데에도 도움됩니다. 개선안들을 제시하는 데서 그치지 않고, 그중 상당수를 즉시 구현해볼 수 있기 때문입니다.
- (프로그래밍 과정 안에 지속적인 코드 리뷰가 녹아 있는) 짝 프로그래밍을 권장합니다.

### 관리자에게 뭐라고 말해야 할까?

- 프로 개발자에게 주어진 임무는 새로운 기능을 빠르게 구현하는 것이고, 가장 빠른 방법은 리팩터링입니다. 그래서 리팩터링부터 합니다.

### 리팩터링하지 말아야 할 때

- 외부 API 다루듯 호출해서 쓰는 코드라면 지저분해도 그냥 둡니다. 내부 동작을 이해해야 할 시점에 리팩터링해야 효과를 제대로 볼 수 있습니다.
- 리팩터링하는 것보다 처음부터 새로 작성하는 게 쉬울 때도 리팩터링하지 않습니다.
- 직접 리팩터링해보기 전에는 어느 쪽이 쉬운지 확실히 알 수 없을 때도 많습니다.

## 리팩터링 시 고민할 문제

### 새 기능 개발 속도 저하

- 리팩터링의 궁극적인 목적은 개발 속도를 높여서, 더 적은 노력으로 더 많은 가치를 창출하는 것입니다. 하지만 상황에 맞게 조율해야 합니다.
- 준비를 위한 리팩터링을 하면 변경을 훨씬 쉽게 할 수 있습니다.
- 리팩터링의 본직은 코드 베이스를 예쁘게 꾸미는 데 있지 않습니다. 오로지 경제적인 이유로 하는 것입니다. 리팩터링은 개발 기간을 단축하고자 하는 것입니다.

### 코드 소유권

- 코드 소유권을 작은 단위로 나눠 엄격히 관리하는 데 반대합니다.
- 코드의 소유권을 팀에 두는 것이 좋습니다.

### 브랜치

- 지속적인 통합(CI), 또는 트렁크 기반 개발(TBD)를 추천합니다. CI에 따르면 모든 팀원이 하루에 최소 한 번은 마스터와 통합합니다. 하지만 CI를 적용하기 위해서는 치러야 할 대가가 있습니다. 마스터를 건강하게 유지하고, 거대한 기능을 짧게 쪼개는 법을 배우고, 각 기능을 끌 수 있는 기능 토글(기능 플래그)을 적용하여 완료되지 않은 기능이 시스템 전체를 망치지 않도록 해야 합니다.
- 프로그램 전체에서 자주 사용하는 함수의 이름을 바꾸는 경우에 머지 과정에서 의미 출돌이 생기기 쉽습니다. 특히 기능별 브랜치 방식에서는 리팩터링을 도저히 진행할 수 없을 정도로 심각한 머지 문제가 발생하기 쉽습니다. 켄트 벡이 CI와 리팩터링을 합쳐서 익스트림 프로그램이(XP)을 만드는 이유도 바로 두 기법의 궁합이 잘 맞기 때문입니다.
- 기능별 브랜치를 사용하면 절대 안 된다는 말은 아닙니다. 브랜치를 자주 통합할 수만 있다면 문제가 발생할 가능성을 크게 줄일 수 있습니다.
- CI를 완벽히 적용하지는 못하더라도 통합 주기만큼은 최대한 짧게 잡아야 합니다. 참고로 CI를 적용하는 편이 소프트웨어를 배포하는 데 훨씬 효과적입니다.

### 테스팅

- 리팩터링하기 위해서는 (대부분의 경우에) 자가 테스트 코드를 마련해야 합니다.
- 자가 테스트 코드는 리팩터링을 할 수 맀게 해줄 뿐만 아니라, 새 기능 추가도 훨씬 안전하게 진행할 수 있도록 도와줍니다. 실수로 만든 버그를 빠르게 찾아서 제거할 수 있기 때문입니다.
- 테스트 주기가 짧다면 단 몇 줄만 비교하면 되며, 문제를 일으킨 부분이 그 몇 줄 안에 있기 때문에 버그를 훨씬 쉽게 찾을 수 있습니다. 또한 리팩터링 과정에서 버그가 생길 위험이 아주 크다는 불암감을 해소할 수 있습니다.
- 안전한 자동 리팩터링만을 활용한다면 테스트 없이 리팩터링해도 좋습니다.
- 자가 테스트 코드는 통합 과정에서 발생하는 의미 충돌을 잡는 메커니즘으로 활용할 수 있어서 자연스럽게 CI와도 밀접하게 연관됩니다. CI에 통합된 테스트는 XP의 권장사항이자 지속적 배포(CD)의 핵심이기도 합니다.

### 레거시 코드

- 레거시 시스템을 파악할 때 리팩터링이 굉장히 도움됩니다.
- 대규모 레거시 시스템을 테스트 코드 없이 명료하게 리팩터링하기는 어렵습니다.
- 서로 관련된 부분끼리 나눠서 하나씩 공략합니다. 코드의 한 부분을 훑고 넘어갈 때마다 예전보다 조금이라도 개선하려고 노력합니다.

### 데이터베이스

- 전체 변경 과정을 작고 독립된 단계들로 쪼개는 것이 핵심입니다. 그래야 마이그레이션 후에도 정상 작동할 수 있습니다. 단계를 잘게 나누면 코드도 쉽게 작성할 수 있습니다.
- 데이터베이스 리팩터링은 프로덕션 환경에 여러 단계로 나눠서 릴리스하는 것이 대체로 좋다는 점에서 다른 리팩터링과 다릅니다. 이렇게 하면 프로덕션 환경에서 문제가 생겼을 때 변경을 되돌리기 쉽습니다.

## 리팩터링, 아키텍처, 애그니(YAGNI)

- 수년 동안 운영되던 소프트웨어라도 아키테겇를 대폭 변경할 수 있습니다.
- 리팩터링이 아키텍처에 미치는 실질적인 효과는 요구사항 변화에 자연스럽게 대응하도록 코드 베이스를 잘 설계해준다는 데 있습니다.
- 코딩 전에 아키텍처를 확정지으려 할 때의 대표적인 문제는 소프트웨어 요구사항을 사전에 모두 파악해야 한다는 것입니다.
- 리팩터링을 미루면 훨씬 힘ㄷ르어진다는 확신일 뜰 때만 유연성 메커니즘을 미리 추가합니다.

## 리팩터링과 소프트웨어 개발 프로세스

- 자가 테스트 코드와 리팩터링을 묶어서 테스트 주도 개발(TDD)이라 합니다.
- 리팩토링의 첫 번째 토대는 자가 테스트 코드입니다.
- 자가 테스트 코드, 지속적 통합, 리팩터링이라는 세 기법은 서로 강력한 상승효과를 발휘합니다. 이상의 세 실천법을 적용한다면 YAGNI 설계 방식으로 개발을 진행할 수 있습니다. 리팩터링과 YAGNI는 서로 긍적적인 영향을 줍니다. 단순한 시스템이 변경하기가 훤씬 쉽기 때문입니다.

## 리팩터링과 성능

- 소프트웨어를 이해하기 쉽게 만들기 위해 속도가 느려지는 방향으로 수정하는 경우가 많습니다. `직관적 설계 vs 성능`은 중요한 주제입니다.
- 리팩터링하면 스프트웨어가 느려질 수 도 있는 건 사실입니다. 하지만 그와 동시에 성능을 튜닝하기는 더 쉬워집니다. 하드 리얼타임 시스템을 제외한 소프트웨어를 빠르게 만드는 비결은, 먼저 튜닝하기 쉽게 만들고 낫 ㅓ원하는 속도가 나게끔 튜닝하는 것입니다.
- 성능에 대한 흥미로운 사실은, 대부분 프로그램은 전체 코드 중 극히 일부에서 대부분의 시간을 소비한다는 것입니다. 그래서 코드 전체를 고르게 최적화한다면 그중 90%는 효과가 거의 없기 때문에 시간 낭비인 셈입니다.
- 의도적으로 성능 최적화에 돌입하기 전까지는 성능에 신경을 쓰지 않고 코드를 다루기 쉽게 만드는 데 집중합니다. 그러다 성능 최적화 단계가 되면 다음의 구체적인 절차를 따라 프로그램을 튜닝합니다.
  - 먼저 프로파일러로 프로그램을 분석하여 시간과 공간을 많이 잡아먹는 지점을 알아냅니다. 그러면 성능에 큰 영향을 주는 작은 부분들을 찾울 수 있습니다.
  - 그런 다음 전체를 고르게 최적화할 때와 마찬가지 방법으로 그 부분들을 개선하니다.
  - 이렇게 하면 성능에 큰 영향을 주는 부분만 집중해서 최적화 하기 때문에 적은 노력으로 훨씬 큰 효과를 볼 수 있습니다.
- 프로그램을 잘 리팩터링해두면 이런 식의 최적화에 두 가지 면에서 도움이 됩니다.
  - 첫째, 성능 튜닝에 투입할 시간을 벌 수 있습니다. 리팩터링이 잘 되어 있다면 기능 추가가 빨리 끝나서 넝을에 집중할 시간을 더 벌 수 있습니다.(또한 프로파일링을 하면 이렇게 확보한 시간을 낭비 없이 쓸수 있습니다.)
  - 둘쨰, 리팩터링이 잘 되어 있는 프로그램은 성능을 더 세밀하게 분석할 수 있습니다. 프롤파일러가 지적해주는 코드의 범위가 더 좁아질 것이고, 그래서 튜닝하기 쉬워집니다. 깔끔하면 개선안들이 더 잘 떠오를 것이고, 그중 어떤 튜닝이 효과가 좋을지 파악하기 쉽습니다.

## 리팩터링의 유래

## 리팩터링 자동화

## 더 알고 싶다면
