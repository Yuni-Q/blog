---
title: CHAPTER 09 - 데이터 조직화
date: 2021-09-18 02:09:67
category: 리팩토링 2판
tags: []
draft: true
---

- 하나의 값이 여러 목적으로 사용된다면 혼란과 버그를 낳습니다.

## 9.1 변수 쪼개기(Split Variable)

- 1판에서의 이름 : 매개변수로의 값 대입 제거, 임시변수 분리

```js
// as-is
let temp = 2 * (height + width);
console.log(temp);
temp = height * width;
console.log(temp);

// to-be
const perimeter = 2 * (height + width);
console.log(perimeter);
const area = height * width;
console.log(area);
```

- 대입이 두 번 이상 이뤄진다면 여러 가지 역핳을 수행한다는 신호입니다.
- 역할이 둘 이상인 변수가 있다면 쪼개야 합니다.
- 역할 하나당 변수 하나입니다.
- 여러 용도로 쓰인 변수는 코드를 읽는 이에게 커다란 혼란을 주기 때문입니다.

### 절차

1. 변수를 선언한 곳과 값을 대입하는 곳에서 변수 이름을 바꿉니다.

- 이후의 대입이 항상 i = i + \<무언가> 형태라면 수집 변수이므로 쪼개면 안 됩니다. 수집 변수는 총합 계산, 문자열 연결, 스트리멩 쓰기, 컬렉션에 추가하기 등의 용도로 흔히 쓰입니다.

2. 가능하면 이때 불변으로 선언합니다.
3. 이 변수에 두 번째로 값을 대입 하는 곳 앞까지의 모든 참조(이 변수가 쓰이는 곳)를 새로운 변수 이름으로 바꿉니다.
4. 두 번째 대입 시 변수를 원래 이름으로 다시 선언합니다.
5. 테스트합니다.
6. 반복합니다. 매 반복에서 변수를 새로운 이름으로 선언하고 다음번 대입 때까지의 모든 참조를 새 변수명으로 바꿉니다. 이 과정을 마지막 대입까지 반복합니다.

## 9.2 필드 이름 바꾸기(Rename Field)

```js
// as-is
class Organization {
  get name() {
    // ...
  }
}

// to-be
class Organization {
  get title() {
    // ...
  }
}
```

- 이름은 중효합니다. 그리고 프로그램 곳곳에서 쓰이는 레코드 구조체의 필드 이름들은 특히 더 중요합니다.
- 데이터 구조는 프로그램을 이해하는 데 큰 역할을 합니다. 데이터 구조는 무슨 일이 벌어지는지를 이해하는 열쇄입니다.
- 게터와 세터 이름 바꾸기도 레코드 구조체의 필드 이름 바꾸기와 똑같이 중요합니다.

### 절차

1. 레코드의 유효 범위가 제한적이라면 필드에 접근하는 모든 코드를 수정한 후 테스트합니다. 이후 단계는 필요 없습니다.
2. 레코드가 캡슐화되지 않았다면 우선 레코드를 캡슐화합니다.
3. 캡슐화된 객체 안에 private 필드명을 변경하고, 그에 맞게 내부 메서드들을 수정합니다.
4. 테스트합니다.
5. 생성자의 매개변수 중 필드와 이름이 겹치는 게 있다면 함수 선언 바꾸기로 변경합니다.
6. 접근자들의 이름도 바꿔줍니다.

## 9.3 파생 변수를 질의 함수로 바꾸기(Replace Derived Variable with Query)

```js
// as-is
get discountedTotal() {
  return this._discountedTotal;
}
set discount(aNumber) {
  const old = this._discount;
  this._discount = aNumber;
  this._discountedTotal += old - aNumber
}

// to-be
get discountedTotal() {
  return this._baseTotal - this._discount;
}
set discount(aNumber) {
  this._discount = aNumber;
}
```

- 가변 데이터는 소프트웨어에 문제를 일으키는 가장 큰 골칫거리에 속합니다. 가변 데이터는 서로 다른 두 코드를 이상한 방식으로 결합하기도 하는데, 예컨대 한 쪽 코드에서 수정한 값이 연쇄 효과를 일으켜 다른 쪽 코드의 원인을 찾기 어려운 문제를 야기하기도 합니다.
- 값을 쉽게 계산해낼 수 있는 변수들을 모두 제거할 수 있습니다.
- 피연산자 데이터가 불변이라면 계산 결과도 일정하므로 역시 불변으로 만들 수 있습니다. 그래서 새로운 데이터 구조를 생성하는 변형 연산이라면 비록 계산 코드로 대체할 수 있더라도 그대로 두는 것이 좋습니다.
  - 데이터 구조를 감싸며 그 데이터에 기초하여 계산한 결과를 속서응로 제공하는 객체
  - 데이터 구조를 받아 다른 데이터 구조로 변환해 반환하는 함수

### 절차

1. 변수 값이 갱신되는 지점을 모두 찾습니다. 피룡하면 변수 쪼개기를 활용해 각 갱신 지점에서 변수를 분리합니다.
2. 해당 변수의 값을 계산해주는 함수를 만듭니다.
3. 해당 변수가 사용되는 모든 곳에 어서션을 추가하여 함수의 계산 결과가 변수의 값과 같은지 확인합니다.

- 필요하면 변수 캡슐화하기를 적요앟여 어서션이 드렁갈 장소를 마련해줍니다.

4. 테스트핣니다.
5. 변수를 읽는 코드를 모두 함수 호출로 대체합니다.
6. 테스트합니다.
7. 변수를 선언하고 갱신하는 코드를 죽은 코드 제거하기로 없앱니다.

## 9.4 참조를 값으로 바꾸기(Change Reference to Value)

- 반대 리팩터링 : 값을 참조로 바꾸기

```js
// as-is
class Product {
  applyDiscount(arg) {
    this._price.amount -= arg;
  }
}

// to-be
class Product {
  applyDiscount(arg) {
    this._price = new Money(this._price.amount - arg, this._price.currency);
  }
}
```

- 객체(데이터 구조)를 다른 객체(데이터 구조)에 중첩하면 내부 객체를 참조 혹은 값으로 취급할 수 있습니다. 참조냐 값이냐의 차이는 내부 속성을 갱싱한는 방식에서 극명하게 드러납니다. 참조로 다루는 경우에는 내부 객체는 그대로 둔 채 그 객체의 속성만 갱신하며, 값으로 다루는 경우에는 새로운 속성을 담은 객체로 기존 내부 객체를 통째로 대체합니다.
- 필드의 값으로 다룬다면 내부 객체의 클래스를 수정하여 값 객체로 만들 수 있습니다. 값 객체는 대체로 자유롭게 활용하기 좋은데, 특히 불변하기 때문입니다.
- 하녚ㄴ 값 객체의 이런 특성 때문에 이번 리팩터링을 적용하면 안 되는 상황도 있습니다. 예컨대 특정 객체를 여러 객체에서 공유하고자 한다면, 그래서 공유 객체의 값을 변경했을 때 이를 관련 객체 모두에 알려줘야 한다면 공유 객체를 참조로 다뤄야 합니다.

### 절차

1. 후보 클래스가 불변인지, 혹은 불변이 될 수 있는지 확인합니다.
2. 각각의 세터를 하나씩 제거합니다.
3. 이 값 객체의 필드들을 사용하는 동치성 비교 메서드를 만듭니다.

- 대부분의 언어는 이런 상뢍에 사용할 수 있도록 오버라이딩 가능한 동치성 비교 메서드를 제공합니다. 동치성 비교 메서드를 오버라이드할 때는 보통 해시코드 생성 메서드도 함께 오버라이드 해야 합니다.

## 9.5 값을 참조로 바꾸기(Change Value to Reference)

- 반대 리팩터링 : 참조를 값으로 바꾸기

```js
// as-is
let customer = new Customer(customerData);

// to-be
let customer = customerRepository(customerData.id);
```

- 논리적으로 같은 데이터를 물리적으로 복제해 사용할 때 가장 크게 문제 되는 상황은 그 데이터를 갱신해야 할 때 입니다. 모든 복제본을 찾아서 빠짐없이 갱신해야 하며, 하나라도 놓치면 데이터 일관성이 깨져버립니다. 이런 상황이라면 복제된 데이터들을 모두 참조로 바꿔주는 게 좋습니다.

### 절차

1. 같은 부류에 속하는 객체들을 보관할 저장소를 만듭니다(이미 있다면 생략).
2. 생성자에서 이 부류의 객체들 중 특정 객체를 정확히 찾아내는 방법이 있는지 확인합니다.
3. 호스트 객체의 생성자들을 수정하여 필요한 객체를 이 저장소에서 찾도록 합니다. 하나 수정할 때마다 테스트합니다.

## 9.6 매직 리터럴 바꾸기(Replace Magic Literal)

- 1판에서의 이름 : 마법 숫자를 기호 상수로 전환

```js
// as-is
function potentialEntergy(mass, height) {
  return mass * 9.81 * height;
}

// to-be
const STANDARD_GRAVITY = 9.81;
function potentialEntergy(mass, height) {
  return mass * STANDARD_GRAVITY * height;
}
```

- 매직 리터럴이란 소스 코드에 등장하는 일반적인 리터럴 값을 말합니다.
- 코드 자체가 뜻을 분명하게 드러내는 게 좋습니다. 상수를 정의하고 숫자 대신 상수를 사용하도록 바꿉니다.
- 상수가 특별한 비교 로직에 주로 쓰이는 경우에는 함수 호출로 바꾸는 것을 고려합니다.
- 상수를 과용하는 것도 좋지 않습니다. 리터럴 함수 하나에서만 쓰이고 그 함수가 맥락 정보를 충분히 제공하여 헷갈리 일이 없다면 상수로 바꿔 업ㄷ는 이득이 줄어듭니다.

### 방법

1. 상수를 선언하거 매직 리터럴을 대입합니다.
2. 해당 리터럴이 사용되는 곳을 모두 찾습니다.
3. 찾은 곳 각각에서 리터럴이 새 상수와 똑같은 의미로 쓰였는지 확인하여, 같은 의미라면 상수로 대체한 후 테스트합니다.
