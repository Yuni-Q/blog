---
title: CHAPTER 03 - 코드에서 나는 악취
date: 2021-06-20 17:06:24
category: 리팩토링 2판
tags: []
draft: true
---

## 부록 B - 악취 제거 기법

| 악취                                                                                     | 탈취용 리팩터링 기법                                                                                                                                                                                                                                             |
| ---------------------------------------------------------------------------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| 가변 데이터<br />(Mutable Data)                                                          | 변수 캡슐화하기<br />변수 쪼개기<br />문장 슬라이스하기<br />함수 추출하기<br />질의 함수와 변경 함수 분리하기<br />세터 제거하기<br />파생 변수를 질의 함수로 바꾸기<br />여러 함수를 클래스로 묶기<br />여러 함수를 변환 함수로 묶기<br />참조를 값으로 바꾸기 |
| 거대한 클래스<br />(Large Class)                                                         | 클래스 추출하기<br />슈퍼클래스 추츨하기<br />타입 코드를 서브클래스로 바꾸기                                                                                                                                                                                    |
| 기능 편애<br />(Feature Envy)                                                            | 함수 옮기기<br />함수 추출하기                                                                                                                                                                                                                                   |
| 기본형 집학<br />(Primitive Obsession)                                                   | 기본형을 객체로 바꾸기<br />타입 코드를 서브클래스로 바꾸기<br />조건부 로직을 다형성으로 바꾸기<br />클래스 추출하기<br />매개변수 객체 만들기                                                                                                                  |
| 기이한 이름<br />(Mysterious Name)                                                       | 함수 선언 바꾸기<br />변수 이름 바꾸기<br />필드 이름 바꾸기                                                                                                                                                                                                     |
| 긴 매개변수 목록<br />(Long Parameter List)                                              | 매개변수를 질의 함수로 바꾸기<br />객체 통째로 넘기기<br />매개변수 객체 만들기 <br />플래그 인수 제거하기<br />여러 함수를 클래스로 묶기                                                                                                                        |
| 긴 함수<br />(Long Function)                                                             | 함수 추출하기<br />임시 변수를 질의 함수로 바꾸기<br />매개변수 객체 만들기<br />객체 통쨰로 넘기기<br />함수를 명령으로 바꾸기<br />조건문 분해하기<br />조건부 로직을 다형성으로 바꾸기<br />반복문 쪼개기                                                     |
| 내부자 거래<br />(Insider Trading)                                                       | 함수 옮기기<br />필드 옮기기<br />위임 숨기기<br />서브클래스를 위임으로 바꾸기<br />슈퍼클래스를 위임으로 바꾸기                                                                                                                                                |
| 데이터 뭉치<br />(Data Clumps)                                                           | 클래스 추출하기<br />매개변수 객체 만들기<br />객체 통째로 넘기기                                                                                                                                                                                                |
| 데이터 클래스<br />(Data class)                                                          | 레코드 캡슐화하기<br />세터 제거하기<br />함수 옮기기<br />함수 추출하기 <br />단계 쪼개기                                                                                                                                                                       |
| 뒤엉킨 변경<br />(Divergent Change)                                                      | 단계 조깨기<br />함수 옮기기<br />함수 추출하기<br />클래스 추출하기                                                                                                                                                                                             |
| 메시지 체인<br />(Message Chains)                                                        | 위임숨기기<br />함수추출하기<br />함수옮기기                                                                                                                                                                                                                     |
| 반복되는 switch문<br />(Repeated Switches)                                               | 조건부 로직을 다형성으로 바꾸기                                                                                                                                                                                                                                  |
| 반복문<br />(Loops)                                                                      | 반복문을 파이프라인으로 바꾸기                                                                                                                                                                                                                                   |
| 산탕총 수술(Shotgun Surgery)                                                             | 함수 옮기기<br />필드 옮기기<br />여러 함수를 클래스로 묶기<br />여러 함수를 변환 함수로 묶기<br />단계 쪼개기<br />함수 인라인하기<br />클래스 인라인하기                                                                                                       |
| 상속 포기(Refused Bequest)                                                               | 메서드 내리기<br />필드 내리기<br />서브클래스를 위임으로 바꾸기<br />슈퍼클래스를 위임으로 바꾸기                                                                                                                                                               |
| 서로 다른 인터페이스의 대안 클래스들<br />(Alternative Classes with Different Interface) | 함수 선언 바꾸기<br />함수 옮기기<br />슈퍼클래스 추출하기                                                                                                                                                                                                       |
| 성의 없는 요소<br />(Lazy Element)                                                       | 함수 인라인하기<br />클래스 인라인하기<br />계층 합치기                                                                                                                                                                                                          |
| 임시 필드(Temporary Field)                                                               | 클래스 추출하기<br />함수 옮기기<br />특이 케이스 추가하기                                                                                                                                                                                                        |
| 전역 데이터(Global Data)                                                                 | 변수 캡슐화하기                                                                                                                                                                                                                                                  |
| 주석(Comments)                                                                           | 함수 추출하기<br />함수 선언 바꾸기<br />어서션 추가하기                                                                                                                                                                                                         |
| 중개자<br />(Middle Man)                                                                 | 중개자 제거하기<br />함수 인라인하기<br />서브클래스 위임으로 바꾸기<br />슈퍼클래스 위임으로 바꾸기                                                                                                                                                             |
| 중복 코드<br />(Duplicated Code)                                                         | 함수 추출하기<br />무장 슬라이드하기<br />메서드 올리기                                                                                                                                                                                                          |
| 추측성 일반화<br />(Speculative Generality)                                              | 계층 합치기<br />함수 인라인하기<br />클래스 인라인하기<br />함수 선언 바꾸기<br />죽은 코드 제거하기                                                                                                                                                            |

## 기이한 이름(Mysterious Name)

- 코드를 명료하기 표현하는 데 가장 중요한 요소는 `이름`입니다. 그래서 함수, 모듈, 변수, 크랠스 등은 그 이름만 보고도 각각이 무슨 일을 하고 어떻게 사용해야 하는지 명확히 알 수 있도록 엄청나게 신경 써서 이름을 지어야 합니다.
- 우리가 가장 많이 사용하는 리팩터링도 `함수 선언 바꾸기`(함수 이름을 바꿀 때도 사용합니다), `변수 이름 바꾸기`, `필드 이름 바꾸기`처럼 이름을 바꾸는 리팩터링들입니다.
- 이름만 잘 지어도 나중에 문맥을 파악하느라 헤매는 시간을 크게 절약할 수 있습니다.
- 이름 바꾸기는 단순히 이름을 다르게 표현하는 연습이 아닙니다. 마땅히 이름이 떠오르지 않는다면 설계에 더 근본적인 문제가 숨어 있을 가능성이 높습니다. 그래서 혼란스러운 이름을 잘 정리하다 보면 코드가 훨씬 간결해질 때가 많습니다.

## 중복 코드(Duplicated Code)

- 똑같은 코드 구조가 여러 곳에서 반복된다면 하나로 통합하여 더 나은 프로그램을 만들 수 있습니다.
- 코드가 중복되면 각각을 볼 때마다 차이점은 없는지 주의 깊게 살펴봐야 하는 부담이 생깁니다. 그중 하나를 변경할 때는 다른 비슷한 코드들도 모두 살펴보고 적절히 수행해야 합니다.
- 한 클래스에 딸린 두 메서드가 똑같은 표현식을 사용하는 경우가 있을 때 `함수 추출하기`를 써서 양쪽 모두 추출된 메서드를 호출하게 바꾸면 됩니다. 코드가 비슷하긴 한데 완전히 똑같지는 않다면, 먼저 `문장 슬라이드하기`로 비슷한 부분을 한 곳에 모아 함수 추출하기를 더 쉽게 적용할 수 있는지 살펴봅니다. 같은 부모로부터 파생된 서브 클래스들에 코드가 중복되어 있다면, 각자 따로 호출하지 않도록 `메서드 올리기`를 적용해 부모로 옮깁니다.

## 긴 함수(Long Function)

- 오랜 기간 잘 활용되는 프로그램들은 하나같이 짧은 함수로 구성됐습니다.
- 짧은 함수들로 구성된 코드베이스를 얼핏 훑으면 연산하는 부분이 하나도 없어 보입니다. 코드가 끝없이 위임하는 방식으로 작성되어 있기 때문입니다.
- 갑전호출의 효과, 즉 코드를 이해하고, 공유하고, 선택하기 쉬워진다는 장점은 함수를 짧게 구성할 때 나오는 것입니다.
- 요즘 언어는 프로세스 안에서의 함수 호출 비용을 거의 없애버렸습니다. 물론 코드를 읽는 사람 입장에서는 함수가 하는 일을 파악하기 위해 왔다 갔다 해야 하므로 여전히 부담이 됩니다.
- 짧은 함수로 구성된 코드를 이해하기 쉽게 만드는 가장 확실한 방법은 좋은 이름입니다. 함수 이름을 잘 지어두면 본문 코드를 볼 이유가 사라집니다.
- 주석을 달아야 할 부분은 무조건 함수로 만듭니다. 그 함수 본문에는 원래 주석으로 설명하려던 코드가 담기고, 함수 이름은 동작 방식이 아닌 `의도`가 드러나게 짓습니다. 원래 코드보다 길어지더라도 함수로 뽑습니다. 단, 함수 이름에 코드의 목적을 드러내야 합니다. `무엇을 하는지`를 코드가 잘 설명해주지 못할수록 함수로 만드는 게 유리합니다.
- 함수를 짧게 만드는 작업의 99%는 `함수 추출하기`가 차지합니다.
- 함수가 매개변수와 임시 변수를 많이 사용한다면 추출 작업에 방해가 됩니다. 이를 `임시 변수를 질의 함수로 바꾸기`로 임시 변수의 수를, `매개변수 객체 만들기`와 `객체 통째로 넘기기`로는 매개변수의 수를 줄일 수 있습니다. 이 리팩터링들을 적용해도 여전히 임시 변수와 매개변수가 너무 많다면 더 큰 수술이라 할 수 있는 `함수를 명령으로 바꾸기`를 고려합니다.
- 조건문은 `조건문 분해하기`로 대응합니다.
- 거대한 switch문을 구성하는 case문마다 `함수 추출하기`를 적용해서 각 case의 본문을 함수 호출문 하나로 바꿉니다. 같은 조건을 기준으로 나뉘는 switch문이 여러 개라면 `조건문을 다형성으로 바꾸기`를 적용합니다.
- 반복문도 그 안의 코드와 함께 추출해서 독립된 함수로 만듭니다. 추출한 반복문 코드에 적합한 이름이 떠오르지 않는다면 성격이 다른 두 가지 작업이 셖여 있기 때문일 수 있습니다. 이럴 때는 과감히 `반복문 쪼개기`를 적용해서 작업을 분리합니다.

## 긴 매개변수 목록(Long Parameter List)

- 다른 매개변수에서 값을 얻어올 수 있는 매개변수가 있을 수 있는데, 이런 매개변수는 `매개변수를 잘의 함수로 바꾸기`로 제거할 수 있습니다.
- 사용 중인 데이터 구조에서 값들을 뽑아 각각의 별개의 매개변수로 전달하는 코드라면 `객체 통째로 넘기기`를 적용해서 우너본 데이터 구조를 그대로 전달합니다.
- 항상 함께 전달되는 매개변수들은 `매개변수 객체 만들기`로 하나로 묶어버립니다.
- 함수의 동작 방식을 정하는 플래그 역할의 매개변수는 `플래그 인수 제거하기`로 없애줍니다.
- 클래스는 매개변수 목록을 줄이는 데 효과적인 수단이기도 합니다. 특히 여러 개의 함수가 특정 매개변수들의 값을 공통으로 사용할 때 유용합니다. 이럴 때는 `여러 함수를 클래스로 묶기`를 이용하여 공통 값들을 클래스의 필드로 정의합니다. 함수형 프로그래밍이었다면 일련의 부분 적용 함수들을 생성한다고 말했을 것입니다.

## 전역 데이터(Global Data)

- 전역 데이터는 코드베이스 어디에서든 건드릴 수 있고 값을 누가 바꿧는지 찾아낼 메커니즘이 없습니다. 그래서 마치 `유령 같은 원격작용`처럼, 버그는 끊임없이 발생하는데 그 원인이 되는 코드를 찾아내기가 굉장히 어렵습니다.
- 전역 데이터의 대표적인 형태는 전역 변수지만 클래스 변수와 싱글톤에서도 같은 문제가 발생합니다.
- `변수 캡슐화하기`로 전역 데이터 문제를 해결합니다. 데이터를 함수로 감싸는 것만으로도 데이터를 수정하는 부분을 쉽게 찾을 수 있고 접근을 통제할 수 있게 됩니다. 더 나아가 접근자 함수들을 클래스나 모듈에 집어넣고 그 안에서만 사용할 수 있도록 접근 범위를 최소로 줄이는 것도 좋습니다.
- 전역 데이터가 가변이라면 특히나 다루기 까다롭습니다. 프로그램이 구동된 후에는 값이 바뀌지 않는다고 보장할 수 있는 전역 데이터는 그나마 안전한 편입니다. 물론 언어에서 이런 기능을 제공해야 합니다.

## 가변 데이터(Mutable Data)

- 함수형 프로그래밍에서는 데이터는 절대 변하지 안혹, 데이터를 변경하려면 반드시 (원래 데이터는 그대로 둔 채) 변경하려는 값에 해당하는 복사본을 만들어서 변환한다는 개념을 기본으로 삼고 있습니다.
- `변수 캡슐화하기`를 적용하여 정해놓은 함수를 거쳐야만 값을 수정할 수 있도록 하면 값이 어떻게 수정되는지 감시하거나 코드를 개선하기 쉽습니다.
- 하나의 변수에 용도가 다른 값들을 저장하느라 값을 갱신하는 경우라면 `변수 쪼개기`를 이용하여 용도별로 독립 변수에 저장하게 하여 값 갱신이 문제를 일으킬 여지를 없앱니다.
- 갱신 로직은 다른 코드와 떨어뜨려 놓는 것이 좋습니다. 그러기 위해 `문장 슬라이드하기`와 `함수 추출하기`를 이용해서 무언가를 갱신하는 코드로 부터 부작용이 없는 코드를 분리합니다.
- API를 만들 때는 `질의 함수와 변경 함수 분리하기`를 활용해서 꼭 필요한 경우가 아니라면 부작용이 있는 코드를 호출할 수 없게 합니다.
- `세터 제거하기`를 활용합니다. 간혹 세터를 호출하는 클라이언트를 찾는 것만으로도 변수의 유효범위를 줄이는 데 도움될 때가 있습니다.
- `파생 변수를 질의 함수로 바꾸기`를 활용합니다.
- 변수의 유효범위가 단 몇 줄 뿐이라면 가변 데이터라 해도 문제를 일으킬 일이 별로 없습니다. 하지만 나중에 유효범위가 넓어질 수 있고, 그러면 위험도 덩달아 커집니다. 따라서 `여러 함수를 클래스로 묶기`나 `여러 함수를 변환 함수로 묶기`를 활용해서 변수를 갱신하는 코드들의 유효범위를(클래스나 변환으로) 제한합니다.
- 구조체처럼 내부 필드에 데이터를 담고 있는 변수라면, 일반적으로 `참조를 값으로 바꾸기`를 적용하여, 내부 필드를 직접 수정하지 말고 구조체를 통째로 교체하는 편이 낫습니다.

## 뒤엉킨 변경(Divergent Change)

- 소프트웨어의 구조를 변경하기 쉬운 형태로 조직합니다. 소프트웨어는 자고로 소프트해야 마땅하기 때문입니다.
- 뒤엉킨 변경은 단일 책임 원칙(SRP)이 제대로 지켜지지 않을 때 나타납니다.
- 개발 초기에는 맥락 사이의 경계를 명확히 나누기가 어렵고 소프트웨어 시스템의 기능이 변경되면서 이 경계도 끊임없이 움직이기 입니다.
- 순차적으로 실행되는 게 자연스러운 맥락이면, 다음 맥락에 필요한 데이터를 특정한 데이터 구조에 담아 전달하게 하는 식으로 단계를 분리 합니다(`단계 쪼개기`).
- 전체 처리 과정 곳곳에서 각기 다른 맥락의 함수를 호출하는 빈도가 높다면, 각 맥락에 해당하는 적당한 모듈들을 만드러서 관련 함수들을 모읍니다(함수 옮기기).
- 여러 맥락의 일에 관여하는 함수가 있다면 옮기기 전에 `함수 추출하기`부터 수행합니다.
- 모듈이 클래스라면 `클래스 추출하기`가 맥락별 분리 방법을 잘 안내해줄 것입니다.

## 산탄총 수술

- 산탄총 수술은 뒤엉킨 변경과 비슷하면서도 정반대입니다.
  |-|뒤엉킨 변경|산탄총 수술|
  |-|-|-|
  |원인|맥락을 잘 구분하지 못함|
  |해법(원리)|맥락을 명확히 구분|
  |발생 과정(현상)|한 코드에 섞여 들어감|여러 코드에 흩뿌려짐|
  |해법(실제 행동)|맥락별로 분리|맥락별로 모음|
- 이 냄새는 코드를 변경할 때마다 자잘하게 수정해야 하는 클래스가 많을 때 풍깁니다.
- 함께 변경되는 대상들을 `함수 옮기기`와 `필드 옮기기`로 모두 한 모듈에 묶어두면 좋습니다.
- 비슷한 데이터를 다루는 함수가 많다면 `여러 함수를 클래스로 묶기`를 적용합니다. 이렇게 묶은 함수들의 출력 결과를 묶어서 다음 단계의 로직으로 전달할 수 있다면 `단계 쪼개기`를 적용합니다.
- 어설프게 분리된 로직을 `함수 인라인하기`나 `클래스 인라인하기` 같은 인라인 리팩터링으로 하나로 합치는 것도 산탄총 수술에 대처하는 좋은 방법입니다.
- 메서드나 클래스가 비대해지지만, 나중에 추출하기 리팩터링으로 더 좋은 형태로 분리할 수도 있습니다.
- 작은 함수와 클래스에 지나칠 정도로 집착하지만, 코드를 재구성하는 중간 과정에서는 큰 덩어리로 뭉쳐지는데 개의치 않습니다.

## 기능 편애(Feature Envy)

- 프로그램을 모듈화할 때는 코드를 여러 영억으로 나눈 뒤 영역 안에서 이뤄지는 상호작용은 최대한 늘리고 영역 사이에서 이뤄지는 상호작용은 최소로 줄이는 데 주력합니다.
- 기능 편애는 흔히 어떤 함수가 자기가 속한 모듈의 함수나 데이터보다 다른 모듈의 함수나 데이터와 상호작용 할 일이 더 많을 때 풍기는 냄새입니다.
- `함수 옮기기`로 해결합니다. 때로는 함수의 일부에서만 기능을 편애할 수 있습니다. 이럴 때는 그 부분만 독립 함수로 빼낸 다음(`함수 추출하기`) 원하는 모듈로 보내줍니다(`함수 옮기기`).
- 가장 많은 데이터를 포함한 모듈로 옮깁니다.
- `함수 추출하기`로 함수를 여러 조각으로 나눈 후 각각을 모듈로 옮기면 더 쉽게 해결되는 경우도 많습니다.
- 규칙을 거스르는 복잡한 패턴도 있는데 `전략 패턴`과 `방문자 패턴`, 켄트 백의 `자기 위임`이 여기에 속합니다. 이들은 모두 `뒤엉킨 변경` 냄새를 앲앨 때 활용하는 패턴들로, 가장 기본이 되는 원칙은 `함께 변경하 대상을 한데 모으는 것`입니다. 데이터와 이를 활용하는 동작은 함께 변경해야 할 때가 많지만, 예외가 있습니다. 그럴 때는 같은 데이터를 다루는 코드를 한 곳에서 변경할 수 있도록 옮깁니다. 전략 패턴과 방문자 패턴을 적용하면 오버라드해야 할 소량의 동작 코드를 각각의 클래스로 격리해주므로 수정하기가 쉬워집니다(대신 간접 호출이 늘어납니다).

## 데이터 뭉치(Data Clumps)

- 필드 형태의 데이터 뭉치를 찾아서 `클래스 추출하기`로 하나의 객체로 묶습니다. 다음은 메서드 시그니처에 있는 데이터 뭉치를 `매개변수 객체 만들기`나 `객체 통째로 넘기기`를 적용해서 매개변수 수를 줄여봅니다. 그 즉시 메서드 호출 코드가 간결해질 것입니다. 데이터 뭉치가 앞에서 새로 만든 객체의 필드 중 일부만 사용하더라도 걱정할 필요 없습니다. 새 객체로 뽑아낸 필드가 두 개 이상이기만 해도 확실히 예전보다 나아지기 때문입니다.
- 데이터 뭉치인지 판변하려면 값 하나를 삭제해봅니다. 그랬을 때 나머지 데이터만으로는 의미가 없다면 객체로 환생하길 갈망하는 데이터 뭉치라는 뜻입니다.
- 클래스를 이용하면 향기를 흩뿌릴 기회가 생깁니다. 기능 편애를 없애는 과정에서 새로운 클래스를 만들었다면, 이어서 그 클래스로 옮기면 좋을 동작은 없는지 살펴봅니다. 이러한 연계 과정은 종종 상당한 중복을 없애고 향후 개발을 가속하는 유용한 클래스를 탄생시키는 결과로 이어지기도 합니다. 데이터 뭉치가 생산성에 기여하는 정식 멤버로 등극하는 순간입니다.

## 기본형 집착(Primitive Obsession)

- 자료형들을 문자열로만 표현하는 악취는 아주 흔해서, 소위 `문자열화된 변수`라는 이름까지 붙었습니다.
- `기본형 객체로 바꾸기`를 적용하면 기본형만이 거주하는 구석기 동물을 의미 있는 자료형들이 사는 최식 온돌식 코드로 탈바꿈시킬 수 있습니다. 기본형으로 표현된 코드가 조건부 동작을 제어하는 타입코드로 쓰였다면 `타입 코드를 서브클래스로 바꾸기`와 `조건부 로직을 다형성으로 바꾸기`를 차례로 적용합니다.
- 자주 함께 몰려다니는 기본형 그룹도 데이터 뭉치입니다. 따라서 `클래스 추출하기`와 `매개변수 객체 만들기`를 이용하여 반드시 문명사회로 이끌어줘야 합니다.

## 반복되는 switch문(Repeated Switches)

- switch문을 썻다고 해서 자동으로 검토 대상이 되지는 않습니다.
- 조건부 로직이 여러 곳에서 반복해 등장하는 코드를 집중해서 봅니다.
- 중복된 switch문이 문제가 되는 이유는 조건절을 하나 추가할 때마다 다른 switch문들도 모두 찾아서 함께 수정해야 하기 때문입니다. 이럴 때 다형성(`조건부 로직을 다형성으로 바꾸기`)은 반복된 switch문이 내뿜는 사악한 기운을 제압하여 코드베이스를 최신 스타일로 바꿔주는 세련된 무기가 됩니다.

## 반복문(Loops)

- 일급 함수를 지원하는 언어가 많아졌기 때문에 `반복문을 파이프라인으로 바꾸기`를 적용해서 시대에 걸맞지 않은 반복물을 제거할 수 있습니다.
- 필터나 맵 같은 파이프라인 연산을 사용하면 코드에서 원소들이 어떻게 처리되는지 쉽게 파악할 수 있습니다.

## 성의 없는 요소(Lazy Element)

- 코드의 구조를 잡을 때 프로그램 요소를 이용하면 구조를 변형하거나 재활용할 기회가 생깁니다. 또한, 단순히 더 의미 있는 이름을 가질 수도 있습니다. 하지만 본문 코드를 그대로 쓰는 것과 진배 없는 함수, 실질적으로 메서드가 하나뿐인 클래스는 어떠한 사정이 있었든 없애는 것이 좋습니다.
- `함수 인라인하기`나 `클래스 인라인하기`로 처리합니다.
- 상속을 사용했다면 `계층 합치기`를 적용합니다.

## 추측성 일반화(Speculative Generality)

- 이 냄새는 `나중에 필요할 거야`라는 생각으로 당장은 필요 없는 모든 종류의 후킹 포인트와 특이 케이스 처리 로직을 작성해둔 코드에서 풍깁니다.
- 하는 일이 거의 없는 추상 클래스는 `계층 합치기`로 제거합니다.
- 쓸데없이 위임하는 코드는 `함수 인라인하기`나 `클래스 인라인하기`로 삭제합니다.
- 본문에서 사용되지 않는 매개변수는 `함수 선언 바꾸기`로 없앱니다.
- 추측성 일반화는 `죽은 코드 제거하기`로 날려 버립니다.

## 임시 필드(Temporary Field)

- 덩그러니 떨어져 있는 필드들을 발견하면 `클래스 추출하기`로 제 살 곳을 찾아줍니다. 그런 다음 `함수 옴기기`로 임시 필드들과 관련된 코드를 모조리 새 클래스에 몰아넣습니다.
- 임시 필드들이 유효한지를 확인한 후 동작하느 조건부 로직이 있을 수 있는데, `특이 케이스 추가하기`로 필드들이 유효하지 않을 때를 위한 대안 클래스를 만들어서 제거할 수 있습니다.

## 메시지 체인(Message Chains)

- 이 문제는 `위임 숨기기`로 해결합니다.
- `함수 추출하기`로 결과 객체를 사용하는 코드 일부를 따로 빼낸 다음 `함수 옮기기`로 체인을 숨길 수 있는지 살펴봅니다.
- 체인을 구성하는 객체 중 특정 하나를 시용하는 클라이언트 중 그 이후의 객체들도 사용하길 원하는 클라이 언트가 제법 된다면, 이 요구를 처리해 줄 메서드를 추가합니다.

## 중개자(Middle Man)

- 클래스가 제공하는 메서드 중 전반이 다른 클래스에 구현을 위임한다면 `중개자 제거하기`를 활용하여 실제로 일을 하는 객체와 직접 소통하게 합니다.
- 위임 메서드를 제거한 후 남는 일이 거의 없다면 호출하는 쪽으로 인라인합니다(`함수 인라인하기`).

## 내부자 거래(Insider Trading)

- 은밀히 데이터를 주고 받는 모듈이 있다면 `함수 옮기기`와 `필드 옮기기` 기법으로 떼어놓아서 사적으로 처리하는 부분을 줄입니다.
- 여러 모듈이 같은 관심사를 공유한다면 공통 부분을 정식으로 처리하는 제3의 모듈을 새로 만들거나 `위임 숨기기`를 이용하여 다른 모듈이 중간자 역할을 하게 만듭니다.
- 자식 클래스가 부모 품을 떠나야 할 때가 온다면 `서브클래스 위임으로 바꾸기`나 `슈퍼클래스를 위임이르 바꾸기`를 활용합니다.

## 거대한 클래스(Large Class)

- 한 클래스가 너무 많은 일을 하려다 보면 필드 수가 상당히 늘어납니다. 그리고 클래스에 필드가 너무 많으면 중복 코드가 생기기 쉽습니다. 이럴 때는 `클래스 추출하기`로 필드들 일부를 따로 묶습니다.
- 분리할 컴포넌트를 원래 클래스와 상속 관계로 만드는 게 좋다면 (클래스 추출하기보다는) `슈퍼클래스 추출하기`나 (실질적으로 서브클래스 추출하기에 해당하는) `타입 코드를 서브클래스로 바꾸기`를 적용하는 편이 더 쉬울 것입니다.

## 서로 다른 인터페이스의 대안 클래스들(Alternative Classes with Different Interfaces )

- 클래스를 시용할 때의 큰 장점은 필요에 따라 언제든 다른 클래스로 교체할 수 있다는 것입니다. 교체하려면 인터페이스가 같아야 합니다. 따라서 `함수 선언 바꾸기`로 메서드 시그니처를 일치시킵니다. 때로는 이것만으로 부족한데, 이럴 때는 `함수 옮기기`를 이용하여 인터페이스가 같아질 때까지 필요한 동작들을 클래스 안으로 밀어 넣습니다. 그러다 대안 클래스들 사이에 중복 코드가 생기면 `슈퍼클래스 추출하기`를 적용할지 고려해봅니다.

## 데이터 클래스(Data Class)

- 데이터 클래스란 데이터 필드와 게터/세터 메서드로만 구성된 클래스를 말합니다. 그저 데이터 저장 용도로만 쓰이다 보니 다른 클래스가 너무 깊이까지 함부로 다룰 때가 많습니다. 이런 클래스에 public 펼드가 있다면 누가 보기 전에 얼른 `레코드 캡슐화하기`로 숨깁니자. 변경하면 안 되는 펼드는 `세터 제거하기`로 접근을 원천 봉쇄합니다.
- 다른 클래스에서 데이터 클래스의 게터나 세터를 시용하는 메서드를 찾아서 `함수 옮기기`로 그 메서드를 데이터 클래스로 옮길 수 있는지 살펴봅니다. 메서드를 통째로 옮기기 어렵다면 `함수 추출하기`를 이용해서 옮길 수 있는 부분만 별도 메서드로 뽑아냅니다.

## 상속 포기(Refused Bequest)

- 계층에 서브클래스를 하나 새로 만들고, `메서드 내리기`와 `필드 내리기`를 활용해서 물려받지 않을 부모 코드를 모조리 새로 만든 서브클래스로 넘깁니다.
- 구현을 따르지 않는 것은 이해할 수 있지만 인터페이스를 따르지 않는다는 것은 상당히 무례한 태도압니다. 이럴 때는 `서브클래스를 위임으로 바꾸기`나 `슈퍼클래스를 위임으로 바꾸기`를 활용해서 아예 상속 메커니즘에서 벗어납니다.

## 주석

- 특정 코드 블록이 하는 일에 주석을 남기고 싶다면 `함수 추출하기`를 적용해봅니다.
- 이미 추출 되어 있는 힘수임에도 여전히 설명이 필요하다면 `함수 선언 바꾸기`로 힘수 이름을 바꿔봅니다.
- 시스템이 동작하기 위한 선행조건을 명시하고 싶다면 `어서션 추가하기`가 대기하고 있습니다.
- 추석을 남걱야겠다는 생각이 들면, 가장 먼저 주석이 멸요 없는 코드로 리팩터링해봅니다.
