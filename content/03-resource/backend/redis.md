---
title: redis
date: 2020-07-24 08:07:43
category: backend
draft: true
---

## 1. Strings

- SET을 이용해서 값을 저장하고, GET을 이용해서 값을 가져올 수 있습니다.
- 이미 있는 key에 대해서 값을 설정하면, 값을 덮어씁니다.
- MSET과 MGET을 이용해서 한 번에 여러 개의 key, value를 저장하고 읽을 수 있습니다.

## 2. 리스트

- LPUSH를 이용해서 리스트의 맨 앞(왼쪽-left)에, RPUSH를 이용해서 리스트의 맨 뒤에 값을 밀어넣을 수 있습니다.
- LRANGE로 일정 범위의 값을 읽을 수 있습니다. LRANGE는 시작과 끝을 위한 두 개의 index 값이 필요합니다. 인덱스가 마이너스(-)이면, 리스트의 끝(오른쪽)을 기준으로 인덱스 값을 메깁니다. 오른쪽 끝의 인덱스는 -1입니다. 따라서 "0 -1"은 0번째 부터 마지막 까지의 범위를 의미합니다.
- pop은 Redis list에서 가장 중요한 연산일 것입니다. 이 연산은 리스트에서 값을 읽는게, 아니라 꺼냅니다. 읽으면서 값을 지웁니다.

### 2.1. Capped Lists

- 소셜 네트워크 메시지 서비스혹은 로그 경우 마지막에 저장된 값만 필요한 경우가 많습니다. LTRIM을 이용해서 특정 영역의 값만 남기고 나머지는 삭제할 수가 있습니다.

### 2.2. Blocking operation on lists

- BRPOP과 BLPOP 명령을 이용하면, blocking 작업이 가능합니다. 이들 명령을 호출하면, 데이터가 없을 경우 데이터가 준비될 때까지 block됩니다. 물론 block 시간 설정도 가능합니다.

## 3. Hash

- Hash는 값으로 field&value의 쌍으로 이루어진 테이블을 저장할 수 있는 데이터 타입입니다.

### 4. Set

- Set은 정렬되지 않은 string의 집합이다. SADD 명령을 이용해서 set에 새로운 값을 추가할 수 있습니다.
- SISMEMBER명령으로 값이 set에 있는지 확인할 수 있습니다.

## 5. Sorted Set

- Set과 hash를 섞은 데이터 타입입니다. Set과 마찬가지로 키는 유니크하며, 키로 정렬됩니다.
- ZADD의 사용법은 SADD와 비슷하다. 정렬에 사용 할 score 매개변수가 하나 더 추가된다는 것만 다릅니다. 이제 값을 가져 오면 score를 키로 정렬된 결과를 받아볼 수 있습니다. Sorted set은 값을 입력 할 때, 정렬이 되기 때문에, O(long(N))의 시간 복잡도를 가집니다.
- WITHSCORES옵션으로 score 값도 함께 읽을 수 있습니다.

### 5.1. Operation on ranges

- Sorted set은 범위 검색을 위한 몇 가지 툴을 제공합니다. ZRANGEBYSCORE 명령을 이용해서 검색할수 있습니다.

### 5.2. Lexicographical scores

- Redis 2.8에 lexicographical scores가 추가됐습니다. score가 같을 경우, 값을 비교해서 정렬합니다. 비교 함수로 C의 memcmp 함수를 사용합니다.

## 6. Bitmaps

- Bitmap의 가장 큰 장점은 0과 1의 상태를 가지는 아이템들을 대단히 효율적으로 저장하고, 읽을 수 있다는데 있습니다.
- 하루 동안의 유니크 방문자를 계산해야 한다고 가정해 보겠습니다. 유저가 방문할 때, 유저 아이디에 해당하는 bit 값을 1로 만들어 주는 걸로 간단하게 유저의 방문여부를 알 수 있습니다. 이때 필요한 메모리는 단지 1bit이기 때문에 512MB의 메모리로 40억(512 _ 1024 _ 1024 \* 8)의 유저의 방문정보를 기록할 수 있습니다.

## 7. HyperLogLogs

- 어떤 데이터셋에서 집합에서 유일한 원소의 갯수를 검사하기 위해서 사용하는 알고리즘입니다.
- 세익스피어 전집에서 unique한 단어의 갯수를 계산하려면 매우 큰 메모리가 필요할 것입니다. HyperLogLogs를 이용하면 약간의 오차를(대략 1billion에 대해서 2% 정도) 허용하는 대신 매우 작은 메모리로 유니크한 원소의 갯수를 검사할 수 있습니다. 셰액스 피어의 전집에 나오는 유일한 영어 단어 개수를 세는 것으로 비교하자면, HashSet을 이용할 경우 10,4447,016 크기의 메모리가 필요한 반면, HyperLogLogs는 512바이트가 필요합니다. 물론 Hashet의 오차는 0%, HyperLogLogs는 3%의 오차가 발생합니다.

## 참고

- [REDIS 소개, 설치, 데이터 타입 테스트](https://www.joinc.co.kr/w/man/12/REDIS/IntroDataType)
