### SICP 저11판(1984 서문)

- 첫째로, 사람들이 읽을 것을 염두에 두고 프로그램을 작성해야 하며, 컴퓨터로 프로그램을 실행하는 것은 부차적인 일일 뿐입니다.
- 둘째로, 이런 수준의 컴퓨터 과학 교과 과목에서 다루어야 할 본질적인 내용은 대규모 소프트웨어 시스템의 지적인 복잡성을 제어하는 데 사용 히는 기법들이라고 믿습니다.
- 이 과목을 제대로 공부한 학생은 대규모 시스랩의 복잡성을 제어히는 주요 기법들에 익숙할 것입니다.
- 우리는 설계의 특정 측면들을 강조하고 그 밖의 측면들은 덜 강조하는 새로운 설계 서술 언어들을만 들어서 복잡성을 통제합니다.
  - 우리는 적절한 때에 세부사항들을 숨기는 추상들을 구축함으로써 복잡성을 통제합니다.
- 이 과목에 대한 우리의 접근 방식에는, '컴퓨터 과학'이 사실은 과학이 아니며 컴퓨터 과학의 중요성은 컴퓨터와 별로 관련이 없다는 우리의 신념이 깔려 있습니다. 컴퓨터 혁명이 혁신적으로 바꾸는 것은 `우리가 생각하는 방식과 그 생각을 표현하는 방식`입니다. 그러한 변화의 핵심은 절치적 인식론(procedural epistemology)이라고 부를 만한 분야의 탄생입니다. 이 분야에서는 지식의 구조를 전통적인 수학 과목이 취히는 선언적(declarative) 관점이 아니라 명령적(imperative) 관점에서 고찰합니다. 수학은 '이것은 무엇인가(what is)'라는 개념(선언적 지식)을 엄밀하게 다루기 위한 틀을 제공하는 반면에 컴퓨터는 '어떻게 하는가(how to)'라는 개념(명령적 지식)을 엄밀하게 다루기 위한틀을 제공합니다.

## 감사의 글

## 감사의 글(1996년 제2판)

# 제 1장 함수를 이용한 추상화

## 단순 관념 (simple idea)에 그 힘을 행사하는 지성의 행위는 주로 다음 세 가지입니다.

1. 다수의 단순 관념을 하나의 복합(compound) 관념으로 조합한다. 복잡한 (complex) 관념들은 모두 이런 식으로 만들어집니다.
2. 두 관념(단순 관념이든 복합 관념이든)을 가져와 또 다른 관념으로 설정함으로써 그 둘을 하나의 관념으로 통합하지 않고도 두 관념을 한 번에 볼 수 있게 만드는 것입니다. 관계에 관한 관념은 모두 이런 식으로 만들어집니다.
3. 하나의 관념을 그 실제 존재에 수반하는 다른 모든 관념으로부터 분리하는 것입니다. 이를 추상화라고 부르며, 일반적인 관념은 모두 이런 식으로 만들어집니다.

## 자바스크립트 프로그램

- 자바스크립트는 프로그래밍 언어 스킴과 셀프의 핵심 기능들을 물려받았다. 스킴은 리스프의 한 방언으로, 이 책의 원판에서 예제를 위한 프로그래밍 언어로 쓰였다. 어휘순 범위(lexically scoped) 일급 힘수나 동적 형식 적용 같은 자바스크립트의 가장 근본적인 설계 원칙들은 스킴에서 물려받은 것이다.
- 어휘순 범위 일급 함수를 람다 표현식을 통해 문법적으로 지원하는 덕분에 함수적 추상들에 직접적으로 간결하게 접근할 수 있으며, 동적 형식 적용 덕분에 이 책을 스킴을 이용한 원판 SICP와 최대한 가깝게 유지할 수 있다.

## 1.1 프로그래밍의 기본요소

### 모든 강력한 언어는 이를 위해 다음 세 가지 메커니즘을 제공한다.

- 원시 표현식(primitive expression): 언어와 관련한 가장단순한 개체(entity)를 나타낸다.
- 조합(combination) 수단: 단순한 요소들로부터 복합적인 요소를 만드는 데 쓰인다.
- 추상화(abstraction) 수단: 복합적인 요소들에 이름을 붙여서 하나의 단위로 다루는 데 쓰인다.

### 프로그래밍에서 우리가 다루는 요소(element)들은 크게 함수와 데이터로 나쥔다.

- 나중에 이 둘이 사실 아주 명백하게 구분되지는 않는다는 점을 알게 될 것이다.
- 거칠게 비유 하자면 데이터는 우리가 조작하고자 하는 `재료`이고, 함수는 `데이터를 다루는 규칙들을 서술(description)`한 것이다. 따라서 모든 강력한 프로그래밍 언어는 반드시 원시 데이터(primitive data)와 원시 힘수(primitive function)를 서술히는 기능이 있어야 하고, 그런 함수들과 데이터를 조합하고 추상화하는 수단들도 제공해야 한다.

## 1.1.1 표현식

- 사람과 해석기의 전형적인 상호작용 방식이란, 사람이 해석기의 프롬프트에서 하나의 문장(statement)을 입력하고, 해석기가 그 문장을 평가(evaluation)해서 그 결과를 화면에 표시하는 것이다.
- 다른 표현식을 구성요소로 담고 있는 표현식을 가리켜 조합(combination)이라고 부른다.
  - 가운데에 연산자(operator)가 있고 그 왼쪽과 오른쪽에 피연산자(operand) 표현식들이 있는 형태의 조합을 연산자 조합(operator combination)이라고 부른다. 연산자 조합의 값은 연산자로 지정된 힘수를 인수(argument)들, 즉 피연산자 값들에 적용해서구한다.
- 연산자를 두 피연산자 사에에 배치하는 관례를 중위 표기법(infix notation)이라고 부른다.
  - 중위 표기법은 학교와 일상 생활에서 익숙한 수학 표기법과 동일하다.
- 복잡한 표현석 문장이 주어져도 해석기는 항상 통일한 기본 주기(cycle)로 작통한다. 해석 기는 사용자가 입력한 문장을 읽고(read), 그 문장을 평가하고(evaluate), 결과를 출력한다(print). 이러한 주기를 반복하는 것을 가리켜 REPL(read-evaluate-print loop)라고 부른다.

## 1.1.2 이름 붙이기와 환경

- 계산적 객체(computational object)에 이름(name)을 붙여서 이름으로 그 객체를 지칭하는 수단들은 프로그래밍 언어의 필수 기능에 해당한다. 그런 수단으로 가장 먼저 살펴볼 것은 상수(constant)이다. 상수의 이름은 해당 객체의 값(value)을 지칭히는 용도로 쓰인다.
- 복합적인 연산의 결괴를 간단한 이름으로 지칭할 수 있다는 점에서, 상수 선언은 우리의 언어에서 가장 단순한 추상화 수단이다.
- 해석기를 이용히면 이름-객체 연관 관계를 일련의 상호작용을 통해서 점진적으로 만들어 나갈 수 있으므로 이처럼 프로그램을 단계적으로 구축 하기가 특히나 편하다.

## 1.1.3 연산자 조합의 평가

### 주어진 연산자 조합을 펑가하기 위해 다음을 수행한다

1. 조합의 피연산자 표현식들을 명가한다.
2. 연산자가 나타내는 함수를 인수(피연산자들의 값)들에 적용한다.

### 단순하긴 하지만, 위 규칙은 계산적인 과정에 관해 일반적으로 중요한 사항 몇 가지를 잘 보여 준다.

- 재귀라는 개념 덕분에 깊게 중첩된 조합의 평가 규칙도 아주 간결하게 표현할 수 있습니다. 만일 재귀가 없었다면 평가 과정을 상당히 복잡하게 서술해야 합니다.
- 평가가 일어나는 문맥을 제공하는 환경이라는 일반적인 개념은 우리가 프로그램의 실행을 이해할 때 중요한 역할을 한다.
- 평가 규칙이 선언에는 적용되지 않습니다.
- 키워드를 포함한 문장을 구문형(syntactic form)이 라고부르는데, 각각의 구문형마다 고유한 평가 규칙이 있다. 다양한 종류의 문장들과 표현식들(각자 나름의 평가 규칙을 가진)은 프로그래밍 언어의 구문론(syntax)을 형성한다.

## 1.1.4 복합함수

### 자바스크립트 프로그래밍의 원시 요소들(강력한 프로그래밍 언어라면 반드시 갖추어야 할)

- 수치와 산술 연산은 원시 데이터와 원시 함수에 해당한다.
- 조합의 중첩은 연산들을 조합하는 수단을 제공한다.
- 이름과 값을 연관시키는 상수 선언은 제한적이나마 추상화의 수단을 제공한다.

### 함수 선언(function declaration)을 살펴본다.

- 복합 연산(compound operation)에 이름을 붙여서 그 연산을 하나의 단위로 지칭하게 하는 함수 선언은 상수 선언 보다 훨씬 강력한 추상화 기법이다.
- `function 이름 (매개변수들) { return 표현식 }`
  - 이름은 환경 안에서 함수 정의와 연관시킬 기호이다.
  - 매개변수들은 함수의 본문 안에서 함수의 인수들을 지칭히는 데 사용할 지역 이름들이다.
  - 함수 선언에서 힘수의 본문(body)은 반환문(return statement) 하나로만 구성되는데 반환문은 키워드 return 다음에 반환표현식(return expression)이 오는 형태이다. 반환 표현식은 함수 적용(function application)의 값을 산출한다.
- `함수-표현식(인수 표현식들)`
  1. 적용의 부분식들, 즉 함수 표현식과 인수 표현식들을 각각 평가한다.
  2. 함수, 즉 함수 표현식의 값을 인수 표현식 값들에 적용한다.
- 함수 적용 표현식을 다른 함수 적용의 인수 표현식으로 시용하는 것도 당연히 가능하다.

## 1.1.5 함수 적용의 치환모형

- 해석기는 먼저 함수 적용의 요소들을 평가한 후 함수(힘수 적용 중 함수 표현식의 값)를 인수들(함수 적용 중 인수표현식들의 값들)에 적용한다.
- 치환모형(substitution model; 또는대입 모형)은 함수 적용의 '의미'를 결정하는 모형으로 보아도 된다.
- 치환 모형은 함수 적용을 이해하는 데 도움을 주기 위한 것일 뿐, 해석기가 반드시 이런 식으로 작동한다는 뜻은 아니다. 전형적인 해석기들이 함수 본문 텍스트의 매개 변수들을 치환하는 식으로 함수 적용을 평가하지는 않는다. 실제 해석기들은 매개변수들에 대한 지역 환경을 이용해서 '치환'을 처리한다.

### 인수 우선 평가 대 정상 순서 평가

- '먼저 완전히 전개한 후 축약'하는 평가 방법을 `정상 순서 평가(normal-order evaluation; 또는 표준 순서 평가)`라고 부른다.
- '먼저 인수들을 평가한 후 적용'하는 명가 방법(해석기가 실제로 시용하는)은 `인수 우선 평가` 또는 `적용적 순서 평가 (applicative-order evaluation)`라고 부른다.
- 자바스크립트는 인수우선 평가 방식을 사용하는데 표현식이 여러 번 평가되어서 생기는 비효율성을 피히는 것도 이유이긴 하지만, 좀 더 중요한 이유는 치환 모형을 벗어난 함수들에 대해서는 정상 순서 평가가 훨씬 복잡하다는 점이다.

## 1.1.6 조건부 표현식과 술어

- `술어 ? 귀결-표현식 : 대안-표현식`
- 하나의 사례 분석 구조는 일련의 절들 끝에 하나의 최종 대안 표현식이 있는 형태라고 할 수 있다.

### 복합 술어(compound predicate)를 구축하는 데 사용할 수 있는 논리 조합 연산들도 있다.

- `표현식1 && 표현식2`
  - 이 연산은 논리곱(logical conjunction)에 해당한다. 의미는 영단어 `and`와 대략 같다.
  - 이 구문형은 `표현식1 ? 표현식2 : false`의 문법적 설탕(편의 구문)이다.
- `표현식1 || 표현식2`
  - 이 연산은 논리합(logical disjunction)에 해당한다. 의미는 영단어 `or`와 대략 비슷하다.
  - 이 구문형은 `표현식1 ? true : 표현식2`의 문법적 설탕이다.
- `!표현식`
  - 이 연산은 논리 부정(logical negation; 줄여서 부정)에 해당한다. 의미는 영단어 `not`과 대략 비슷하다.
  - 논리 부정 표현식의 값은 표현식이 거짓으로 평가되면 참이고 참으로 평가 되면 거짓이다.
- `&&`와 `||`는 연산자가 아니라 `구문형`임을 주의하자. 이들의 우변에 오는 표현식이 항상 평가 되지는 않는다. 반면에 `!`는 연산자이며 1.1.3 평가 규칙을 따른다.
- 다른 연산 자들은 인수를 두 개 받는 이항(binary) 연산자이지만, 이 `!`는 인수 하나만 받는 단항(unary) 연산자이다.
- 연산자 `!`를 인수 앞에 둔다는 점도 주목하자. 이런 방식의 연산지를 전위 연산자 (prefix operator)라고 부른다.
- 구문형 `&&`는 우선순위가 비교 연산자 `>`보다 낮다. 그리고 조건부 표현식 구문형 `...? ... : ...`의 우선순위는 지금까지 배운 모든 연산자보다 낮다.
  - 조건부 표현식 구문형의 우선 순위가 산술연산자 `+`와 `*`보다 낮다.

### 연습문제 1.1

- 다음은 일련의 문장들이다. 각 문장에 대해 해석기가 출력하는 결과는 무엇인가? 해석기가 문장들을 차례로(위에서 아래로) 평가한다고 가정할 것.

```js
10;
// 10
5 + 3 + 4;
// 12
9 - 1;
// 8
6 / 2;
// 3
2 * 4 + (4 - 6);
// 6
const a = 3;
// undefined
const b = a + 1;
// undefined
a + b + a * b;
// 19
a === b;
//  false
b > a && b < a * b ? b : a;
// 4
a === 4 ? 6 : b === 4 ? 6 + 7 + a : 25;
// 16
2 + (6 > a ? b : a);
// 6
(a > b ? a : a < b ? b : -1) * (a + 1);
// 16
```

### 연습문제 1.2

- 다음 수석을 자바스크립트 표현식으로 옮겨라.

```js
(5 + 4(2 - (3 - (6 + 4 / 5)))) / 3(6 - 2)(2 - 7);
```

### 연습문제 1.3

- 세 개의 수를 받고 셋 중 가장 작은 것을 제외한 두 수의 제곱들을 합한 결괴를 돌려주는 함수를 선언하라.

```js
const square = (x) => x * x;
const squareSum = (x, y) => square(x) + square(y);
const fn = (a, b, c) =>
  a > c && b > c
    ? squareSum(a, b)
    : a > c && c > b
    ? squareSum(a, c)
    : squareSum(b, c);
```

### 연습문제 1.4

- 앞에서 본 함수 적용 평가 모형은 함수표현식이 복합 표현식인 경우도 허용한다. 이 점을 고려해서 a_plus_abs_b 함수의 작동 방식을 서술하라.

```js
// 더하기
function plus(a, b) {
  return a + b;
}
// 빼기
function minus(a, b) {
  return a - b;
}
// b를 절대값으로 치환하여 더하기
function a_plus_abs_b(a, b) {
  return (b >= 0 ? plus : minus)(a, b);
}
```

### 연습문제 1.5

- 벤 빗디들은 주어진 해석기가 인수 우선 평가를 사용하는지 정상 순서 평가를 사용히는지 파악하는 방법을 고안했다. 이를 위해 벤은 다음 두 함수를 선언했다.

```js
function p() {
  return p();
}
function test(x, y) {
  return x === 0 ? 0 : y;
}
```

- 이제 다음과 같은 문장을 펑가하면 해석기의 평가 방식을 파약할 수 있다.

```js
test(0, p());
```

- 해석기가 인수 우선 평가를 사용할 때와 정상 순서 평가를 사용할 때 이 문장이 어떤 식으로 평가 되는지를 각각 서술하라. (해석기가 정상 순서이든 인수 우선이든 조건부 표현식의 평가 규칙은 동일하다고 가정할 것. 즉, 어떤 경우이든 술어 표현식이 제일 먼저 평가되고, 그 결과에 따라 귀결표현식 또는 대안표현식이 평가된다.)

#### 답

- 인수 우선 평가: RangeError: Maximum call stack size exceeded.
- 정상 순서 평가: 0

## 1.1.7 예제: 뉴턴 방법으로 제곱근 구하기

- 수학 함수와 컴퓨터 함수의 중요한 차이점은 컴퓨터의 함수는 반드시 효과적(effective)이어야 한다는 점이다.
  - '효율적(efficient)'이 아님을 주의하자. 여기서 `효과적`은 예상한 대로의 효과나 결과를 산출한다는 뜻으로, `실 효성이 있다`라고 이해해도 될 것이다.
- 수학에서는 주로 선언적 서술(이것은무엇인가?)에 관심을 두지만 컴퓨터 과학에서는 주로 명령적 서술(어떻게 하는가?)에 관심을 둔다.
  - 프로그래머가 자신이 원하는 일을 서솔하기만 하면 그 일을 실행하는 방법을 생성할 정도로 정교한 해석기를 만들려고 했다. 일반적으로 이는 불가능한 일이지만 몇몇 주요분야에서 성과가 있긴 했다.
- sqrt_iter 함수는 특별한 반복 구조(루프문) 없이 그냥 힘수를 호출하는 평범한 능력만으로도 반복을 구현할 수 있음을 보여준다.

### 연습문제 1.6

- 문자 `?`와 `:`가 관여하는 조건부 표현식 문법이 마음에 들지 않은 알리사 P. 해커는 '그냥 조건부 표현식처럼 작동하는 보통의 조건부 함수를 선언해서 사용하면 안 될까?'라고 물었다. 알리사의 동료 에바 루 에이터는 실제로 그런 힘수를 만드는 것이 가능하다고 주장하고, 다음과 같은 conditional 함수를 선언했다.

```js
function conditional(predicate, then_clause, else_clause) {
  return predicate ? then_clause : else_clause;
}
```

- 그러고는 아래와 같이 이 힘수의 사용법을 알리사에게 시연했다.

```js
conditional(2 === 3, 0, 5);
// 5
conditional(1 === 1, 0, 5);
// 0
```

- 이를 반긴 알리사는 conditional을 이용해서 다음과 같은 제곱근 계산 함수를 작성했다.

```js
function sqrt_iter(guess, x) {
  return conditional(
    is_good_enough(guess, x),
    guess,
    sqrt_iter(improve(guess, x), x),
  );
}
```

- 이 함수로 제곱근을 계산하면 어떤 일이 생기는지 설명하라.

#### 답

- RangeError: Maximum call stack size exceeded.

### 연습문제 1.7

- 제곱근 계산에 쓰인 is_good_enough 술어의 판정 방식은 아주 작은 수의 제곱근을 구할 때는 그리 효과적이지 않다. 그리고 실제 컴퓨터에서 산술 연산은 거의 항상 정밀도(유효자릿수)가 제한된 상태로 수행되기 때문에, is_good_enough의 판정 방식은 아주 큰 수의 제곱근 계산에도 부적합하다. 이러한 점을 좀 더 자세히 설명하고 작은수와 큰수에 대해 판정이 실패 하는 사례들을 제시하라. is_good_enough를 구현하는 또 다른 전략은 반복 과정에서 guess의 변화랑을 추적하면서 변화량이 guess의 아주 작은 비율보다 작으면 충분히 좋은 추측값이 라고 판정하는 것이다. 이런 종류의 반복 종료 판정 방식을 사용하는 제곱근 함수를 설계하라. 작은 수와 큰 수에 대해 그 함수가 본문의 함수보다 더 잘 작동하는가?

#### 답

- 숫자가 크면 대부분의 경우 계산이 완료되지 않습니다.
- 작은 숫자를 사용하면 결과가 매우 부정확할 수 있습니다.
  - 부동 소수점 숫자 문제로 값이 제대로 나오지 못합니다.
    - 대부분의 경우 부동 소수점 숫자는 실수의 근사치입니다. 이로 인해 반올림 문제가 발생합니다.

```js
const improve = (guess, x) => average(guess, x / guess);
const square = (x) => x * x;
const goodEnough = (previousGuess, guess) =>
  Math.abs((guess - previousGuess) / guess) > 0.00000000001;
const sqrtIter = (guess, x) =>
  goodEnough(guess, improve(guess, x)) ? guess : sqrtIter(improve(guess, x), x);
const average = (x, y) => (x + y) / 2;
const sqrt = (x) => sqrtIter(1.0, x);
```

### 연습문제 1.8

- 세제곱근을 위한 뉴턴 방법에서는, y가 x의 세제곱근을 근사하는 값이라고 할 때 다음 공식으로 더 나은 근삿값을 구한다.
- 공식
- 이 공식을 이용해서 제곱근 함수와 비슷한 형태의 세제곱근 함수를 구현하라. (1.3.4에서는 이 제곱근 함수와 세제곱근 함수를 추상화한 것에 해당하는 일반적인 뉴턴 방법의 구현을 이야기한다.)

```js
const improve = (guess, x) => (x / (guess * guess) + 2 * guess) / 3;
const cube = (x = x * x * x);
const goodEnough = (previousGuess, guess) =>
  Math.abs((guess - previousGuess) / guess) > 0.00000000001;
const cubeRootIter = (guess, x) =>
  goodEnough(improve(guess, x), guess)
    ? guess
    : cubeRootIter(improve(guess, x), x);
const cubeRoot = (x) => cubeRootIter(1.0, x);
```

## 1.1.8 블랙박스 추상으로서의 함수

- 프로그램은 문제를 부분문제들로 분해한 것에 대응되는 함수들의 군집(cluster)이라고 할 수 있다.
  - 세부사항을 나중으로 미루어도 된다(합수적 추상).
- 함수는 세부사항을 숨길 수 있어야 한다.
- 힘수의 의미가 함수 작성자가 정한 매개변수 이름과는 독립적이어야 한다는 원칙이 당연하게 느껴지겠지만, 이 원칙은 함수의 작성과 사용에 심오한 영향을 미친다. 가장 간단한 영향은 함수 매개변수 이름이 반드시 함수 본문 안에서만 유효한 지역 이름(local name)이어야 한다는 것이다.
- 함수 선언은 자신의 매개변수들을 자신에게 묶는다. 묶인 이름들을 함수 선언 전체에서 일관되게 다른 이름으로 바꾼다면 힘수 선언의 의미는 변하지 않는다.
  - 함수 선언에서, 힘수의 매개변수로 선언된 묶인 이름들의 범위는 함수의 본문 전체이다.

### 내부 선언과 블록 구조

- 블록 안에서 선언된 이름들은 그 블록 내부로만 한정된다.
- lexical은 해석기 또는 컴파일러가 어휘 분석(lexical analysis) 과정에서 소스 코드의 토큰들을 인식하 는 순서(이주 간단히 말하면 위에서 아래， 왼쪽에서 오른쪽)와 관련되며, 그래서 이 번역서에서는 '어휘순'이라는 용어를 사용한다 '동적 범위 (dynamic scope)'와는 대조되는 범위라는 점에서 어휘순 범위를 `정적 범위 (static scope)`라고 부르 기도한다.
  - 어휘순 범위 적용에서는 주어진 험수의 자유 이름들이 그 함수를 감싸는 함수 선언의 바인딩들을 참조한다. 다른 말로 하면, 자유 이름의 값은 그 함수가 선언된 환경에서 조회된다.
